
/**
 * Client
**/

import * as runtime from '@prisma/client/runtime/library.js';
import $Types = runtime.Types // general types
import $Public = runtime.Types.Public
import $Utils = runtime.Types.Utils
import $Extensions = runtime.Types.Extensions
import $Result = runtime.Types.Result

export type PrismaPromise<T> = $Public.PrismaPromise<T>


/**
 * Model Tenant
 * 
 */
export type Tenant = $Result.DefaultSelection<Prisma.$TenantPayload>
/**
 * Model User
 * 
 */
export type User = $Result.DefaultSelection<Prisma.$UserPayload>
/**
 * Model Membership
 * 
 */
export type Membership = $Result.DefaultSelection<Prisma.$MembershipPayload>
/**
 * Model Site
 * 
 */
export type Site = $Result.DefaultSelection<Prisma.$SitePayload>
/**
 * Model Device
 * 
 */
export type Device = $Result.DefaultSelection<Prisma.$DevicePayload>
/**
 * Model DeviceSecret
 * 
 */
export type DeviceSecret = $Result.DefaultSelection<Prisma.$DeviceSecretPayload>
/**
 * Model Telemetry
 * 
 */
export type Telemetry = $Result.DefaultSelection<Prisma.$TelemetryPayload>
/**
 * Model DeviceTwin
 * 
 */
export type DeviceTwin = $Result.DefaultSelection<Prisma.$DeviceTwinPayload>
/**
 * Model Command
 * 
 */
export type Command = $Result.DefaultSelection<Prisma.$CommandPayload>
/**
 * Model FirmwarePackage
 * 
 */
export type FirmwarePackage = $Result.DefaultSelection<Prisma.$FirmwarePackagePayload>
/**
 * Model OtaJob
 * 
 */
export type OtaJob = $Result.DefaultSelection<Prisma.$OtaJobPayload>
/**
 * Model SimInfo
 * 
 */
export type SimInfo = $Result.DefaultSelection<Prisma.$SimInfoPayload>
/**
 * Model SimAction
 * 
 */
export type SimAction = $Result.DefaultSelection<Prisma.$SimActionPayload>
/**
 * Model AlertRule
 * 
 */
export type AlertRule = $Result.DefaultSelection<Prisma.$AlertRulePayload>
/**
 * Model AlertEvent
 * 
 */
export type AlertEvent = $Result.DefaultSelection<Prisma.$AlertEventPayload>
/**
 * Model NotificationChannel
 * 
 */
export type NotificationChannel = $Result.DefaultSelection<Prisma.$NotificationChannelPayload>
/**
 * Model NotificationEvent
 * 
 */
export type NotificationEvent = $Result.DefaultSelection<Prisma.$NotificationEventPayload>
/**
 * Model DailyRollup
 * 
 */
export type DailyRollup = $Result.DefaultSelection<Prisma.$DailyRollupPayload>
/**
 * Model Entitlement
 * 
 */
export type Entitlement = $Result.DefaultSelection<Prisma.$EntitlementPayload>
/**
 * Model AuditLog
 * 
 */
export type AuditLog = $Result.DefaultSelection<Prisma.$AuditLogPayload>
/**
 * Model WeatherData
 * 
 */
export type WeatherData = $Result.DefaultSelection<Prisma.$WeatherDataPayload>

/**
 * Enums
 */
export namespace $Enums {
  export const TenantType: {
  MANUFACTURER: 'MANUFACTURER',
  RETAILER: 'RETAILER',
  INSTALLER: 'INSTALLER',
  PROPERTY_MANAGER: 'PROPERTY_MANAGER'
};

export type TenantType = (typeof TenantType)[keyof typeof TenantType]


export const TenantStatus: {
  ACTIVE: 'ACTIVE',
  SUSPENDED: 'SUSPENDED',
  ARCHIVED: 'ARCHIVED'
};

export type TenantStatus = (typeof TenantStatus)[keyof typeof TenantStatus]


export const UserStatus: {
  ACTIVE: 'ACTIVE',
  INVITED: 'INVITED',
  SUSPENDED: 'SUSPENDED'
};

export type UserStatus = (typeof UserStatus)[keyof typeof UserStatus]


export const MembershipRole: {
  PLATFORM_ADMIN: 'PLATFORM_ADMIN',
  TENANT_ADMIN: 'TENANT_ADMIN',
  INSTALLER: 'INSTALLER',
  SUPPORT_AGENT: 'SUPPORT_AGENT',
  END_USER: 'END_USER'
};

export type MembershipRole = (typeof MembershipRole)[keyof typeof MembershipRole]


export const LocationSource: {
  MOBILE_GPS: 'MOBILE_GPS',
  EDGE_GNSS: 'EDGE_GNSS',
  EDGE_CELL: 'EDGE_CELL',
  MANUAL: 'MANUAL'
};

export type LocationSource = (typeof LocationSource)[keyof typeof LocationSource]


export const DeviceStatus: {
  PROVISIONED: 'PROVISIONED',
  INSTALLED: 'INSTALLED',
  ACTIVE: 'ACTIVE',
  SUSPENDED: 'SUSPENDED',
  RETIRED: 'RETIRED'
};

export type DeviceStatus = (typeof DeviceStatus)[keyof typeof DeviceStatus]


export const DeviceLocationSource: {
  EDGE_GNSS: 'EDGE_GNSS',
  EDGE_CELL: 'EDGE_CELL'
};

export type DeviceLocationSource = (typeof DeviceLocationSource)[keyof typeof DeviceLocationSource]


export const CommandType: {
  REMOTE_BOOST_SET: 'REMOTE_BOOST_SET',
  SET_SCHEDULE: 'SET_SCHEDULE',
  SET_CONFIG: 'SET_CONFIG'
};

export type CommandType = (typeof CommandType)[keyof typeof CommandType]


export const CommandStatus: {
  QUEUED: 'QUEUED',
  DELIVERED: 'DELIVERED',
  ACKED: 'ACKED',
  FAILED: 'FAILED',
  EXPIRED: 'EXPIRED'
};

export type CommandStatus = (typeof CommandStatus)[keyof typeof CommandStatus]


export const OtaTargetType: {
  DEVICE: 'DEVICE',
  GROUP: 'GROUP'
};

export type OtaTargetType = (typeof OtaTargetType)[keyof typeof OtaTargetType]


export const OtaJobStatus: {
  SCHEDULED: 'SCHEDULED',
  IN_PROGRESS: 'IN_PROGRESS',
  SUCCESS: 'SUCCESS',
  FAILED: 'FAILED',
  CANCELED: 'CANCELED'
};

export type OtaJobStatus = (typeof OtaJobStatus)[keyof typeof OtaJobStatus]


export const SimStatus: {
  ACTIVE: 'ACTIVE',
  SUSPENDED: 'SUSPENDED',
  INACTIVE: 'INACTIVE',
  UNKNOWN: 'UNKNOWN'
};

export type SimStatus = (typeof SimStatus)[keyof typeof SimStatus]


export const SimActionType: {
  ACTIVATE: 'ACTIVATE',
  DEACTIVATE: 'DEACTIVATE',
  SUSPEND: 'SUSPEND',
  RESUME: 'RESUME'
};

export type SimActionType = (typeof SimActionType)[keyof typeof SimActionType]


export const SimActionStatus: {
  REQUESTED: 'REQUESTED',
  COMPLETED: 'COMPLETED',
  FAILED: 'FAILED'
};

export type SimActionStatus = (typeof SimActionStatus)[keyof typeof SimActionStatus]


export const AlertRuleType: {
  NO_TELEMETRY: 'NO_TELEMETRY',
  OVER_TEMP: 'OVER_TEMP',
  POSSIBLE_LEAK: 'POSSIBLE_LEAK',
  SENSOR_OUT_OF_RANGE: 'SENSOR_OUT_OF_RANGE'
};

export type AlertRuleType = (typeof AlertRuleType)[keyof typeof AlertRuleType]


export const AlertSeverity: {
  INFO: 'INFO',
  WARNING: 'WARNING',
  CRITICAL: 'CRITICAL'
};

export type AlertSeverity = (typeof AlertSeverity)[keyof typeof AlertSeverity]


export const AlertEventStatus: {
  OPEN: 'OPEN',
  ACKNOWLEDGED: 'ACKNOWLEDGED',
  CLOSED: 'CLOSED'
};

export type AlertEventStatus = (typeof AlertEventStatus)[keyof typeof AlertEventStatus]


export const NotificationChannelType: {
  EMAIL: 'EMAIL',
  SMS: 'SMS',
  WEBHOOK: 'WEBHOOK'
};

export type NotificationChannelType = (typeof NotificationChannelType)[keyof typeof NotificationChannelType]


export const NotificationEventStatus: {
  QUEUED: 'QUEUED',
  SENT: 'SENT',
  FAILED: 'FAILED'
};

export type NotificationEventStatus = (typeof NotificationEventStatus)[keyof typeof NotificationEventStatus]


export const EntitlementScope: {
  TENANT: 'TENANT',
  DEVICE: 'DEVICE'
};

export type EntitlementScope = (typeof EntitlementScope)[keyof typeof EntitlementScope]


export const EntitlementKey: {
  BASIC_REMOTE_BOOST: 'BASIC_REMOTE_BOOST',
  SMART_HOME_INTEGRATION: 'SMART_HOME_INTEGRATION'
};

export type EntitlementKey = (typeof EntitlementKey)[keyof typeof EntitlementKey]


export const ActorType: {
  USER: 'USER',
  DEVICE: 'DEVICE',
  SYSTEM: 'SYSTEM'
};

export type ActorType = (typeof ActorType)[keyof typeof ActorType]

}

export type TenantType = $Enums.TenantType

export const TenantType: typeof $Enums.TenantType

export type TenantStatus = $Enums.TenantStatus

export const TenantStatus: typeof $Enums.TenantStatus

export type UserStatus = $Enums.UserStatus

export const UserStatus: typeof $Enums.UserStatus

export type MembershipRole = $Enums.MembershipRole

export const MembershipRole: typeof $Enums.MembershipRole

export type LocationSource = $Enums.LocationSource

export const LocationSource: typeof $Enums.LocationSource

export type DeviceStatus = $Enums.DeviceStatus

export const DeviceStatus: typeof $Enums.DeviceStatus

export type DeviceLocationSource = $Enums.DeviceLocationSource

export const DeviceLocationSource: typeof $Enums.DeviceLocationSource

export type CommandType = $Enums.CommandType

export const CommandType: typeof $Enums.CommandType

export type CommandStatus = $Enums.CommandStatus

export const CommandStatus: typeof $Enums.CommandStatus

export type OtaTargetType = $Enums.OtaTargetType

export const OtaTargetType: typeof $Enums.OtaTargetType

export type OtaJobStatus = $Enums.OtaJobStatus

export const OtaJobStatus: typeof $Enums.OtaJobStatus

export type SimStatus = $Enums.SimStatus

export const SimStatus: typeof $Enums.SimStatus

export type SimActionType = $Enums.SimActionType

export const SimActionType: typeof $Enums.SimActionType

export type SimActionStatus = $Enums.SimActionStatus

export const SimActionStatus: typeof $Enums.SimActionStatus

export type AlertRuleType = $Enums.AlertRuleType

export const AlertRuleType: typeof $Enums.AlertRuleType

export type AlertSeverity = $Enums.AlertSeverity

export const AlertSeverity: typeof $Enums.AlertSeverity

export type AlertEventStatus = $Enums.AlertEventStatus

export const AlertEventStatus: typeof $Enums.AlertEventStatus

export type NotificationChannelType = $Enums.NotificationChannelType

export const NotificationChannelType: typeof $Enums.NotificationChannelType

export type NotificationEventStatus = $Enums.NotificationEventStatus

export const NotificationEventStatus: typeof $Enums.NotificationEventStatus

export type EntitlementScope = $Enums.EntitlementScope

export const EntitlementScope: typeof $Enums.EntitlementScope

export type EntitlementKey = $Enums.EntitlementKey

export const EntitlementKey: typeof $Enums.EntitlementKey

export type ActorType = $Enums.ActorType

export const ActorType: typeof $Enums.ActorType

/**
 * ##  Prisma Client ʲˢ
 * 
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Tenants
 * const tenants = await prisma.tenant.findMany()
 * ```
 *
 * 
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  ClientOptions extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  U = 'log' extends keyof ClientOptions ? ClientOptions['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<ClientOptions['log']> : never : never,
  ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }

    /**
   * ##  Prisma Client ʲˢ
   * 
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Tenants
   * const tenants = await prisma.tenant.findMany()
   * ```
   *
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<ClientOptions, Prisma.PrismaClientOptions>);
  $on<V extends U>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent) => void): void;

  /**
   * Connect with the database
   */
  $connect(): $Utils.JsPromise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): $Utils.JsPromise<void>;

  /**
   * Add a middleware
   * @deprecated since 4.16.0. For new code, prefer client extensions instead.
   * @see https://pris.ly/d/extensions
   */
  $use(cb: Prisma.Middleware): void

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;


  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => $Utils.JsPromise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<R>


  $extends: $Extensions.ExtendsHook<"extends", Prisma.TypeMapCb, ExtArgs>

      /**
   * `prisma.tenant`: Exposes CRUD operations for the **Tenant** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Tenants
    * const tenants = await prisma.tenant.findMany()
    * ```
    */
  get tenant(): Prisma.TenantDelegate<ExtArgs>;

  /**
   * `prisma.user`: Exposes CRUD operations for the **User** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Users
    * const users = await prisma.user.findMany()
    * ```
    */
  get user(): Prisma.UserDelegate<ExtArgs>;

  /**
   * `prisma.membership`: Exposes CRUD operations for the **Membership** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Memberships
    * const memberships = await prisma.membership.findMany()
    * ```
    */
  get membership(): Prisma.MembershipDelegate<ExtArgs>;

  /**
   * `prisma.site`: Exposes CRUD operations for the **Site** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Sites
    * const sites = await prisma.site.findMany()
    * ```
    */
  get site(): Prisma.SiteDelegate<ExtArgs>;

  /**
   * `prisma.device`: Exposes CRUD operations for the **Device** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Devices
    * const devices = await prisma.device.findMany()
    * ```
    */
  get device(): Prisma.DeviceDelegate<ExtArgs>;

  /**
   * `prisma.deviceSecret`: Exposes CRUD operations for the **DeviceSecret** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more DeviceSecrets
    * const deviceSecrets = await prisma.deviceSecret.findMany()
    * ```
    */
  get deviceSecret(): Prisma.DeviceSecretDelegate<ExtArgs>;

  /**
   * `prisma.telemetry`: Exposes CRUD operations for the **Telemetry** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Telemetries
    * const telemetries = await prisma.telemetry.findMany()
    * ```
    */
  get telemetry(): Prisma.TelemetryDelegate<ExtArgs>;

  /**
   * `prisma.deviceTwin`: Exposes CRUD operations for the **DeviceTwin** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more DeviceTwins
    * const deviceTwins = await prisma.deviceTwin.findMany()
    * ```
    */
  get deviceTwin(): Prisma.DeviceTwinDelegate<ExtArgs>;

  /**
   * `prisma.command`: Exposes CRUD operations for the **Command** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Commands
    * const commands = await prisma.command.findMany()
    * ```
    */
  get command(): Prisma.CommandDelegate<ExtArgs>;

  /**
   * `prisma.firmwarePackage`: Exposes CRUD operations for the **FirmwarePackage** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more FirmwarePackages
    * const firmwarePackages = await prisma.firmwarePackage.findMany()
    * ```
    */
  get firmwarePackage(): Prisma.FirmwarePackageDelegate<ExtArgs>;

  /**
   * `prisma.otaJob`: Exposes CRUD operations for the **OtaJob** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more OtaJobs
    * const otaJobs = await prisma.otaJob.findMany()
    * ```
    */
  get otaJob(): Prisma.OtaJobDelegate<ExtArgs>;

  /**
   * `prisma.simInfo`: Exposes CRUD operations for the **SimInfo** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more SimInfos
    * const simInfos = await prisma.simInfo.findMany()
    * ```
    */
  get simInfo(): Prisma.SimInfoDelegate<ExtArgs>;

  /**
   * `prisma.simAction`: Exposes CRUD operations for the **SimAction** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more SimActions
    * const simActions = await prisma.simAction.findMany()
    * ```
    */
  get simAction(): Prisma.SimActionDelegate<ExtArgs>;

  /**
   * `prisma.alertRule`: Exposes CRUD operations for the **AlertRule** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more AlertRules
    * const alertRules = await prisma.alertRule.findMany()
    * ```
    */
  get alertRule(): Prisma.AlertRuleDelegate<ExtArgs>;

  /**
   * `prisma.alertEvent`: Exposes CRUD operations for the **AlertEvent** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more AlertEvents
    * const alertEvents = await prisma.alertEvent.findMany()
    * ```
    */
  get alertEvent(): Prisma.AlertEventDelegate<ExtArgs>;

  /**
   * `prisma.notificationChannel`: Exposes CRUD operations for the **NotificationChannel** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more NotificationChannels
    * const notificationChannels = await prisma.notificationChannel.findMany()
    * ```
    */
  get notificationChannel(): Prisma.NotificationChannelDelegate<ExtArgs>;

  /**
   * `prisma.notificationEvent`: Exposes CRUD operations for the **NotificationEvent** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more NotificationEvents
    * const notificationEvents = await prisma.notificationEvent.findMany()
    * ```
    */
  get notificationEvent(): Prisma.NotificationEventDelegate<ExtArgs>;

  /**
   * `prisma.dailyRollup`: Exposes CRUD operations for the **DailyRollup** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more DailyRollups
    * const dailyRollups = await prisma.dailyRollup.findMany()
    * ```
    */
  get dailyRollup(): Prisma.DailyRollupDelegate<ExtArgs>;

  /**
   * `prisma.entitlement`: Exposes CRUD operations for the **Entitlement** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Entitlements
    * const entitlements = await prisma.entitlement.findMany()
    * ```
    */
  get entitlement(): Prisma.EntitlementDelegate<ExtArgs>;

  /**
   * `prisma.auditLog`: Exposes CRUD operations for the **AuditLog** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more AuditLogs
    * const auditLogs = await prisma.auditLog.findMany()
    * ```
    */
  get auditLog(): Prisma.AuditLogDelegate<ExtArgs>;

  /**
   * `prisma.weatherData`: Exposes CRUD operations for the **WeatherData** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more WeatherData
    * const weatherData = await prisma.weatherData.findMany()
    * ```
    */
  get weatherData(): Prisma.WeatherDataDelegate<ExtArgs>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = $Public.PrismaPromise<T>

  /**
   * Validator
   */
  export import validator = runtime.Public.validator

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError
  export import NotFoundError = runtime.NotFoundError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql



  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics 
   */
  export type Metrics = runtime.Metrics
  export type Metric<T> = runtime.Metric<T>
  export type MetricHistogram = runtime.MetricHistogram
  export type MetricHistogramBucket = runtime.MetricHistogramBucket

  /**
  * Extensions
  */
  export import Extension = $Extensions.UserArgs
  export import getExtensionContext = runtime.Extensions.getExtensionContext
  export import Args = $Public.Args
  export import Payload = $Public.Payload
  export import Result = $Public.Result
  export import Exact = $Public.Exact

  /**
   * Prisma Client JS version: 5.22.0
   * Query Engine version: 605197351a3c8bdd595af2d2a9bc3025bca48ea2
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion 

  /**
   * Utility Types
   */


  export import JsonObject = runtime.JsonObject
  export import JsonArray = runtime.JsonArray
  export import JsonValue = runtime.JsonValue
  export import InputJsonObject = runtime.InputJsonObject
  export import InputJsonArray = runtime.InputJsonArray
  export import InputJsonValue = runtime.InputJsonValue

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }

  type SelectAndOmit = {
    select: any
    omit: any
  }

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => $Utils.JsPromise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : T extends SelectAndOmit
        ? 'Please either choose `select` or `omit`.'
        : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? K : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;



  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but additionally can also accept an array of keys
   */
  type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    Tenant: 'Tenant',
    User: 'User',
    Membership: 'Membership',
    Site: 'Site',
    Device: 'Device',
    DeviceSecret: 'DeviceSecret',
    Telemetry: 'Telemetry',
    DeviceTwin: 'DeviceTwin',
    Command: 'Command',
    FirmwarePackage: 'FirmwarePackage',
    OtaJob: 'OtaJob',
    SimInfo: 'SimInfo',
    SimAction: 'SimAction',
    AlertRule: 'AlertRule',
    AlertEvent: 'AlertEvent',
    NotificationChannel: 'NotificationChannel',
    NotificationEvent: 'NotificationEvent',
    DailyRollup: 'DailyRollup',
    Entitlement: 'Entitlement',
    AuditLog: 'AuditLog',
    WeatherData: 'WeatherData'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }

  interface TypeMapCb extends $Utils.Fn<{extArgs: $Extensions.InternalArgs, clientOptions: PrismaClientOptions }, $Utils.Record<string, any>> {
    returns: Prisma.TypeMap<this['params']['extArgs'], this['params']['clientOptions']>
  }

  export type TypeMap<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> = {
    meta: {
      modelProps: "tenant" | "user" | "membership" | "site" | "device" | "deviceSecret" | "telemetry" | "deviceTwin" | "command" | "firmwarePackage" | "otaJob" | "simInfo" | "simAction" | "alertRule" | "alertEvent" | "notificationChannel" | "notificationEvent" | "dailyRollup" | "entitlement" | "auditLog" | "weatherData"
      txIsolationLevel: Prisma.TransactionIsolationLevel
    }
    model: {
      Tenant: {
        payload: Prisma.$TenantPayload<ExtArgs>
        fields: Prisma.TenantFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TenantFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TenantPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TenantFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TenantPayload>
          }
          findFirst: {
            args: Prisma.TenantFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TenantPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TenantFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TenantPayload>
          }
          findMany: {
            args: Prisma.TenantFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TenantPayload>[]
          }
          create: {
            args: Prisma.TenantCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TenantPayload>
          }
          createMany: {
            args: Prisma.TenantCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.TenantCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TenantPayload>[]
          }
          delete: {
            args: Prisma.TenantDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TenantPayload>
          }
          update: {
            args: Prisma.TenantUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TenantPayload>
          }
          deleteMany: {
            args: Prisma.TenantDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.TenantUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.TenantUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TenantPayload>
          }
          aggregate: {
            args: Prisma.TenantAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTenant>
          }
          groupBy: {
            args: Prisma.TenantGroupByArgs<ExtArgs>
            result: $Utils.Optional<TenantGroupByOutputType>[]
          }
          count: {
            args: Prisma.TenantCountArgs<ExtArgs>
            result: $Utils.Optional<TenantCountAggregateOutputType> | number
          }
        }
      }
      User: {
        payload: Prisma.$UserPayload<ExtArgs>
        fields: Prisma.UserFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findFirst: {
            args: Prisma.UserFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findMany: {
            args: Prisma.UserFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          create: {
            args: Prisma.UserCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          createMany: {
            args: Prisma.UserCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.UserCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          delete: {
            args: Prisma.UserDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          update: {
            args: Prisma.UserUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          deleteMany: {
            args: Prisma.UserDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UserUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.UserUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          aggregate: {
            args: Prisma.UserAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUser>
          }
          groupBy: {
            args: Prisma.UserGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserCountArgs<ExtArgs>
            result: $Utils.Optional<UserCountAggregateOutputType> | number
          }
        }
      }
      Membership: {
        payload: Prisma.$MembershipPayload<ExtArgs>
        fields: Prisma.MembershipFieldRefs
        operations: {
          findUnique: {
            args: Prisma.MembershipFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MembershipPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.MembershipFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MembershipPayload>
          }
          findFirst: {
            args: Prisma.MembershipFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MembershipPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.MembershipFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MembershipPayload>
          }
          findMany: {
            args: Prisma.MembershipFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MembershipPayload>[]
          }
          create: {
            args: Prisma.MembershipCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MembershipPayload>
          }
          createMany: {
            args: Prisma.MembershipCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.MembershipCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MembershipPayload>[]
          }
          delete: {
            args: Prisma.MembershipDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MembershipPayload>
          }
          update: {
            args: Prisma.MembershipUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MembershipPayload>
          }
          deleteMany: {
            args: Prisma.MembershipDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.MembershipUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.MembershipUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MembershipPayload>
          }
          aggregate: {
            args: Prisma.MembershipAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateMembership>
          }
          groupBy: {
            args: Prisma.MembershipGroupByArgs<ExtArgs>
            result: $Utils.Optional<MembershipGroupByOutputType>[]
          }
          count: {
            args: Prisma.MembershipCountArgs<ExtArgs>
            result: $Utils.Optional<MembershipCountAggregateOutputType> | number
          }
        }
      }
      Site: {
        payload: Prisma.$SitePayload<ExtArgs>
        fields: Prisma.SiteFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SiteFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SitePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SiteFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SitePayload>
          }
          findFirst: {
            args: Prisma.SiteFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SitePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SiteFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SitePayload>
          }
          findMany: {
            args: Prisma.SiteFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SitePayload>[]
          }
          create: {
            args: Prisma.SiteCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SitePayload>
          }
          createMany: {
            args: Prisma.SiteCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.SiteCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SitePayload>[]
          }
          delete: {
            args: Prisma.SiteDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SitePayload>
          }
          update: {
            args: Prisma.SiteUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SitePayload>
          }
          deleteMany: {
            args: Prisma.SiteDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SiteUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.SiteUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SitePayload>
          }
          aggregate: {
            args: Prisma.SiteAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSite>
          }
          groupBy: {
            args: Prisma.SiteGroupByArgs<ExtArgs>
            result: $Utils.Optional<SiteGroupByOutputType>[]
          }
          count: {
            args: Prisma.SiteCountArgs<ExtArgs>
            result: $Utils.Optional<SiteCountAggregateOutputType> | number
          }
        }
      }
      Device: {
        payload: Prisma.$DevicePayload<ExtArgs>
        fields: Prisma.DeviceFieldRefs
        operations: {
          findUnique: {
            args: Prisma.DeviceFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DevicePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.DeviceFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DevicePayload>
          }
          findFirst: {
            args: Prisma.DeviceFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DevicePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.DeviceFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DevicePayload>
          }
          findMany: {
            args: Prisma.DeviceFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DevicePayload>[]
          }
          create: {
            args: Prisma.DeviceCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DevicePayload>
          }
          createMany: {
            args: Prisma.DeviceCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.DeviceCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DevicePayload>[]
          }
          delete: {
            args: Prisma.DeviceDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DevicePayload>
          }
          update: {
            args: Prisma.DeviceUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DevicePayload>
          }
          deleteMany: {
            args: Prisma.DeviceDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.DeviceUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.DeviceUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DevicePayload>
          }
          aggregate: {
            args: Prisma.DeviceAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateDevice>
          }
          groupBy: {
            args: Prisma.DeviceGroupByArgs<ExtArgs>
            result: $Utils.Optional<DeviceGroupByOutputType>[]
          }
          count: {
            args: Prisma.DeviceCountArgs<ExtArgs>
            result: $Utils.Optional<DeviceCountAggregateOutputType> | number
          }
        }
      }
      DeviceSecret: {
        payload: Prisma.$DeviceSecretPayload<ExtArgs>
        fields: Prisma.DeviceSecretFieldRefs
        operations: {
          findUnique: {
            args: Prisma.DeviceSecretFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeviceSecretPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.DeviceSecretFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeviceSecretPayload>
          }
          findFirst: {
            args: Prisma.DeviceSecretFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeviceSecretPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.DeviceSecretFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeviceSecretPayload>
          }
          findMany: {
            args: Prisma.DeviceSecretFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeviceSecretPayload>[]
          }
          create: {
            args: Prisma.DeviceSecretCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeviceSecretPayload>
          }
          createMany: {
            args: Prisma.DeviceSecretCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.DeviceSecretCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeviceSecretPayload>[]
          }
          delete: {
            args: Prisma.DeviceSecretDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeviceSecretPayload>
          }
          update: {
            args: Prisma.DeviceSecretUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeviceSecretPayload>
          }
          deleteMany: {
            args: Prisma.DeviceSecretDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.DeviceSecretUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.DeviceSecretUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeviceSecretPayload>
          }
          aggregate: {
            args: Prisma.DeviceSecretAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateDeviceSecret>
          }
          groupBy: {
            args: Prisma.DeviceSecretGroupByArgs<ExtArgs>
            result: $Utils.Optional<DeviceSecretGroupByOutputType>[]
          }
          count: {
            args: Prisma.DeviceSecretCountArgs<ExtArgs>
            result: $Utils.Optional<DeviceSecretCountAggregateOutputType> | number
          }
        }
      }
      Telemetry: {
        payload: Prisma.$TelemetryPayload<ExtArgs>
        fields: Prisma.TelemetryFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TelemetryFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TelemetryPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TelemetryFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TelemetryPayload>
          }
          findFirst: {
            args: Prisma.TelemetryFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TelemetryPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TelemetryFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TelemetryPayload>
          }
          findMany: {
            args: Prisma.TelemetryFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TelemetryPayload>[]
          }
          create: {
            args: Prisma.TelemetryCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TelemetryPayload>
          }
          createMany: {
            args: Prisma.TelemetryCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.TelemetryCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TelemetryPayload>[]
          }
          delete: {
            args: Prisma.TelemetryDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TelemetryPayload>
          }
          update: {
            args: Prisma.TelemetryUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TelemetryPayload>
          }
          deleteMany: {
            args: Prisma.TelemetryDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.TelemetryUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.TelemetryUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TelemetryPayload>
          }
          aggregate: {
            args: Prisma.TelemetryAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTelemetry>
          }
          groupBy: {
            args: Prisma.TelemetryGroupByArgs<ExtArgs>
            result: $Utils.Optional<TelemetryGroupByOutputType>[]
          }
          count: {
            args: Prisma.TelemetryCountArgs<ExtArgs>
            result: $Utils.Optional<TelemetryCountAggregateOutputType> | number
          }
        }
      }
      DeviceTwin: {
        payload: Prisma.$DeviceTwinPayload<ExtArgs>
        fields: Prisma.DeviceTwinFieldRefs
        operations: {
          findUnique: {
            args: Prisma.DeviceTwinFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeviceTwinPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.DeviceTwinFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeviceTwinPayload>
          }
          findFirst: {
            args: Prisma.DeviceTwinFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeviceTwinPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.DeviceTwinFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeviceTwinPayload>
          }
          findMany: {
            args: Prisma.DeviceTwinFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeviceTwinPayload>[]
          }
          create: {
            args: Prisma.DeviceTwinCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeviceTwinPayload>
          }
          createMany: {
            args: Prisma.DeviceTwinCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.DeviceTwinCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeviceTwinPayload>[]
          }
          delete: {
            args: Prisma.DeviceTwinDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeviceTwinPayload>
          }
          update: {
            args: Prisma.DeviceTwinUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeviceTwinPayload>
          }
          deleteMany: {
            args: Prisma.DeviceTwinDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.DeviceTwinUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.DeviceTwinUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeviceTwinPayload>
          }
          aggregate: {
            args: Prisma.DeviceTwinAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateDeviceTwin>
          }
          groupBy: {
            args: Prisma.DeviceTwinGroupByArgs<ExtArgs>
            result: $Utils.Optional<DeviceTwinGroupByOutputType>[]
          }
          count: {
            args: Prisma.DeviceTwinCountArgs<ExtArgs>
            result: $Utils.Optional<DeviceTwinCountAggregateOutputType> | number
          }
        }
      }
      Command: {
        payload: Prisma.$CommandPayload<ExtArgs>
        fields: Prisma.CommandFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CommandFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommandPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CommandFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommandPayload>
          }
          findFirst: {
            args: Prisma.CommandFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommandPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CommandFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommandPayload>
          }
          findMany: {
            args: Prisma.CommandFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommandPayload>[]
          }
          create: {
            args: Prisma.CommandCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommandPayload>
          }
          createMany: {
            args: Prisma.CommandCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CommandCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommandPayload>[]
          }
          delete: {
            args: Prisma.CommandDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommandPayload>
          }
          update: {
            args: Prisma.CommandUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommandPayload>
          }
          deleteMany: {
            args: Prisma.CommandDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CommandUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.CommandUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommandPayload>
          }
          aggregate: {
            args: Prisma.CommandAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCommand>
          }
          groupBy: {
            args: Prisma.CommandGroupByArgs<ExtArgs>
            result: $Utils.Optional<CommandGroupByOutputType>[]
          }
          count: {
            args: Prisma.CommandCountArgs<ExtArgs>
            result: $Utils.Optional<CommandCountAggregateOutputType> | number
          }
        }
      }
      FirmwarePackage: {
        payload: Prisma.$FirmwarePackagePayload<ExtArgs>
        fields: Prisma.FirmwarePackageFieldRefs
        operations: {
          findUnique: {
            args: Prisma.FirmwarePackageFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FirmwarePackagePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.FirmwarePackageFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FirmwarePackagePayload>
          }
          findFirst: {
            args: Prisma.FirmwarePackageFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FirmwarePackagePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.FirmwarePackageFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FirmwarePackagePayload>
          }
          findMany: {
            args: Prisma.FirmwarePackageFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FirmwarePackagePayload>[]
          }
          create: {
            args: Prisma.FirmwarePackageCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FirmwarePackagePayload>
          }
          createMany: {
            args: Prisma.FirmwarePackageCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.FirmwarePackageCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FirmwarePackagePayload>[]
          }
          delete: {
            args: Prisma.FirmwarePackageDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FirmwarePackagePayload>
          }
          update: {
            args: Prisma.FirmwarePackageUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FirmwarePackagePayload>
          }
          deleteMany: {
            args: Prisma.FirmwarePackageDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.FirmwarePackageUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.FirmwarePackageUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FirmwarePackagePayload>
          }
          aggregate: {
            args: Prisma.FirmwarePackageAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateFirmwarePackage>
          }
          groupBy: {
            args: Prisma.FirmwarePackageGroupByArgs<ExtArgs>
            result: $Utils.Optional<FirmwarePackageGroupByOutputType>[]
          }
          count: {
            args: Prisma.FirmwarePackageCountArgs<ExtArgs>
            result: $Utils.Optional<FirmwarePackageCountAggregateOutputType> | number
          }
        }
      }
      OtaJob: {
        payload: Prisma.$OtaJobPayload<ExtArgs>
        fields: Prisma.OtaJobFieldRefs
        operations: {
          findUnique: {
            args: Prisma.OtaJobFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OtaJobPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.OtaJobFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OtaJobPayload>
          }
          findFirst: {
            args: Prisma.OtaJobFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OtaJobPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.OtaJobFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OtaJobPayload>
          }
          findMany: {
            args: Prisma.OtaJobFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OtaJobPayload>[]
          }
          create: {
            args: Prisma.OtaJobCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OtaJobPayload>
          }
          createMany: {
            args: Prisma.OtaJobCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.OtaJobCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OtaJobPayload>[]
          }
          delete: {
            args: Prisma.OtaJobDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OtaJobPayload>
          }
          update: {
            args: Prisma.OtaJobUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OtaJobPayload>
          }
          deleteMany: {
            args: Prisma.OtaJobDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.OtaJobUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.OtaJobUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OtaJobPayload>
          }
          aggregate: {
            args: Prisma.OtaJobAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateOtaJob>
          }
          groupBy: {
            args: Prisma.OtaJobGroupByArgs<ExtArgs>
            result: $Utils.Optional<OtaJobGroupByOutputType>[]
          }
          count: {
            args: Prisma.OtaJobCountArgs<ExtArgs>
            result: $Utils.Optional<OtaJobCountAggregateOutputType> | number
          }
        }
      }
      SimInfo: {
        payload: Prisma.$SimInfoPayload<ExtArgs>
        fields: Prisma.SimInfoFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SimInfoFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SimInfoPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SimInfoFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SimInfoPayload>
          }
          findFirst: {
            args: Prisma.SimInfoFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SimInfoPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SimInfoFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SimInfoPayload>
          }
          findMany: {
            args: Prisma.SimInfoFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SimInfoPayload>[]
          }
          create: {
            args: Prisma.SimInfoCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SimInfoPayload>
          }
          createMany: {
            args: Prisma.SimInfoCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.SimInfoCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SimInfoPayload>[]
          }
          delete: {
            args: Prisma.SimInfoDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SimInfoPayload>
          }
          update: {
            args: Prisma.SimInfoUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SimInfoPayload>
          }
          deleteMany: {
            args: Prisma.SimInfoDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SimInfoUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.SimInfoUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SimInfoPayload>
          }
          aggregate: {
            args: Prisma.SimInfoAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSimInfo>
          }
          groupBy: {
            args: Prisma.SimInfoGroupByArgs<ExtArgs>
            result: $Utils.Optional<SimInfoGroupByOutputType>[]
          }
          count: {
            args: Prisma.SimInfoCountArgs<ExtArgs>
            result: $Utils.Optional<SimInfoCountAggregateOutputType> | number
          }
        }
      }
      SimAction: {
        payload: Prisma.$SimActionPayload<ExtArgs>
        fields: Prisma.SimActionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SimActionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SimActionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SimActionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SimActionPayload>
          }
          findFirst: {
            args: Prisma.SimActionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SimActionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SimActionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SimActionPayload>
          }
          findMany: {
            args: Prisma.SimActionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SimActionPayload>[]
          }
          create: {
            args: Prisma.SimActionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SimActionPayload>
          }
          createMany: {
            args: Prisma.SimActionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.SimActionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SimActionPayload>[]
          }
          delete: {
            args: Prisma.SimActionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SimActionPayload>
          }
          update: {
            args: Prisma.SimActionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SimActionPayload>
          }
          deleteMany: {
            args: Prisma.SimActionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SimActionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.SimActionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SimActionPayload>
          }
          aggregate: {
            args: Prisma.SimActionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSimAction>
          }
          groupBy: {
            args: Prisma.SimActionGroupByArgs<ExtArgs>
            result: $Utils.Optional<SimActionGroupByOutputType>[]
          }
          count: {
            args: Prisma.SimActionCountArgs<ExtArgs>
            result: $Utils.Optional<SimActionCountAggregateOutputType> | number
          }
        }
      }
      AlertRule: {
        payload: Prisma.$AlertRulePayload<ExtArgs>
        fields: Prisma.AlertRuleFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AlertRuleFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AlertRulePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AlertRuleFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AlertRulePayload>
          }
          findFirst: {
            args: Prisma.AlertRuleFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AlertRulePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AlertRuleFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AlertRulePayload>
          }
          findMany: {
            args: Prisma.AlertRuleFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AlertRulePayload>[]
          }
          create: {
            args: Prisma.AlertRuleCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AlertRulePayload>
          }
          createMany: {
            args: Prisma.AlertRuleCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AlertRuleCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AlertRulePayload>[]
          }
          delete: {
            args: Prisma.AlertRuleDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AlertRulePayload>
          }
          update: {
            args: Prisma.AlertRuleUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AlertRulePayload>
          }
          deleteMany: {
            args: Prisma.AlertRuleDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AlertRuleUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.AlertRuleUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AlertRulePayload>
          }
          aggregate: {
            args: Prisma.AlertRuleAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAlertRule>
          }
          groupBy: {
            args: Prisma.AlertRuleGroupByArgs<ExtArgs>
            result: $Utils.Optional<AlertRuleGroupByOutputType>[]
          }
          count: {
            args: Prisma.AlertRuleCountArgs<ExtArgs>
            result: $Utils.Optional<AlertRuleCountAggregateOutputType> | number
          }
        }
      }
      AlertEvent: {
        payload: Prisma.$AlertEventPayload<ExtArgs>
        fields: Prisma.AlertEventFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AlertEventFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AlertEventPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AlertEventFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AlertEventPayload>
          }
          findFirst: {
            args: Prisma.AlertEventFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AlertEventPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AlertEventFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AlertEventPayload>
          }
          findMany: {
            args: Prisma.AlertEventFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AlertEventPayload>[]
          }
          create: {
            args: Prisma.AlertEventCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AlertEventPayload>
          }
          createMany: {
            args: Prisma.AlertEventCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AlertEventCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AlertEventPayload>[]
          }
          delete: {
            args: Prisma.AlertEventDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AlertEventPayload>
          }
          update: {
            args: Prisma.AlertEventUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AlertEventPayload>
          }
          deleteMany: {
            args: Prisma.AlertEventDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AlertEventUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.AlertEventUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AlertEventPayload>
          }
          aggregate: {
            args: Prisma.AlertEventAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAlertEvent>
          }
          groupBy: {
            args: Prisma.AlertEventGroupByArgs<ExtArgs>
            result: $Utils.Optional<AlertEventGroupByOutputType>[]
          }
          count: {
            args: Prisma.AlertEventCountArgs<ExtArgs>
            result: $Utils.Optional<AlertEventCountAggregateOutputType> | number
          }
        }
      }
      NotificationChannel: {
        payload: Prisma.$NotificationChannelPayload<ExtArgs>
        fields: Prisma.NotificationChannelFieldRefs
        operations: {
          findUnique: {
            args: Prisma.NotificationChannelFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationChannelPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.NotificationChannelFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationChannelPayload>
          }
          findFirst: {
            args: Prisma.NotificationChannelFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationChannelPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.NotificationChannelFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationChannelPayload>
          }
          findMany: {
            args: Prisma.NotificationChannelFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationChannelPayload>[]
          }
          create: {
            args: Prisma.NotificationChannelCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationChannelPayload>
          }
          createMany: {
            args: Prisma.NotificationChannelCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.NotificationChannelCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationChannelPayload>[]
          }
          delete: {
            args: Prisma.NotificationChannelDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationChannelPayload>
          }
          update: {
            args: Prisma.NotificationChannelUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationChannelPayload>
          }
          deleteMany: {
            args: Prisma.NotificationChannelDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.NotificationChannelUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.NotificationChannelUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationChannelPayload>
          }
          aggregate: {
            args: Prisma.NotificationChannelAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateNotificationChannel>
          }
          groupBy: {
            args: Prisma.NotificationChannelGroupByArgs<ExtArgs>
            result: $Utils.Optional<NotificationChannelGroupByOutputType>[]
          }
          count: {
            args: Prisma.NotificationChannelCountArgs<ExtArgs>
            result: $Utils.Optional<NotificationChannelCountAggregateOutputType> | number
          }
        }
      }
      NotificationEvent: {
        payload: Prisma.$NotificationEventPayload<ExtArgs>
        fields: Prisma.NotificationEventFieldRefs
        operations: {
          findUnique: {
            args: Prisma.NotificationEventFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationEventPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.NotificationEventFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationEventPayload>
          }
          findFirst: {
            args: Prisma.NotificationEventFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationEventPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.NotificationEventFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationEventPayload>
          }
          findMany: {
            args: Prisma.NotificationEventFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationEventPayload>[]
          }
          create: {
            args: Prisma.NotificationEventCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationEventPayload>
          }
          createMany: {
            args: Prisma.NotificationEventCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.NotificationEventCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationEventPayload>[]
          }
          delete: {
            args: Prisma.NotificationEventDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationEventPayload>
          }
          update: {
            args: Prisma.NotificationEventUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationEventPayload>
          }
          deleteMany: {
            args: Prisma.NotificationEventDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.NotificationEventUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.NotificationEventUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationEventPayload>
          }
          aggregate: {
            args: Prisma.NotificationEventAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateNotificationEvent>
          }
          groupBy: {
            args: Prisma.NotificationEventGroupByArgs<ExtArgs>
            result: $Utils.Optional<NotificationEventGroupByOutputType>[]
          }
          count: {
            args: Prisma.NotificationEventCountArgs<ExtArgs>
            result: $Utils.Optional<NotificationEventCountAggregateOutputType> | number
          }
        }
      }
      DailyRollup: {
        payload: Prisma.$DailyRollupPayload<ExtArgs>
        fields: Prisma.DailyRollupFieldRefs
        operations: {
          findUnique: {
            args: Prisma.DailyRollupFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DailyRollupPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.DailyRollupFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DailyRollupPayload>
          }
          findFirst: {
            args: Prisma.DailyRollupFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DailyRollupPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.DailyRollupFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DailyRollupPayload>
          }
          findMany: {
            args: Prisma.DailyRollupFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DailyRollupPayload>[]
          }
          create: {
            args: Prisma.DailyRollupCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DailyRollupPayload>
          }
          createMany: {
            args: Prisma.DailyRollupCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.DailyRollupCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DailyRollupPayload>[]
          }
          delete: {
            args: Prisma.DailyRollupDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DailyRollupPayload>
          }
          update: {
            args: Prisma.DailyRollupUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DailyRollupPayload>
          }
          deleteMany: {
            args: Prisma.DailyRollupDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.DailyRollupUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.DailyRollupUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DailyRollupPayload>
          }
          aggregate: {
            args: Prisma.DailyRollupAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateDailyRollup>
          }
          groupBy: {
            args: Prisma.DailyRollupGroupByArgs<ExtArgs>
            result: $Utils.Optional<DailyRollupGroupByOutputType>[]
          }
          count: {
            args: Prisma.DailyRollupCountArgs<ExtArgs>
            result: $Utils.Optional<DailyRollupCountAggregateOutputType> | number
          }
        }
      }
      Entitlement: {
        payload: Prisma.$EntitlementPayload<ExtArgs>
        fields: Prisma.EntitlementFieldRefs
        operations: {
          findUnique: {
            args: Prisma.EntitlementFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EntitlementPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.EntitlementFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EntitlementPayload>
          }
          findFirst: {
            args: Prisma.EntitlementFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EntitlementPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.EntitlementFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EntitlementPayload>
          }
          findMany: {
            args: Prisma.EntitlementFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EntitlementPayload>[]
          }
          create: {
            args: Prisma.EntitlementCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EntitlementPayload>
          }
          createMany: {
            args: Prisma.EntitlementCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.EntitlementCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EntitlementPayload>[]
          }
          delete: {
            args: Prisma.EntitlementDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EntitlementPayload>
          }
          update: {
            args: Prisma.EntitlementUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EntitlementPayload>
          }
          deleteMany: {
            args: Prisma.EntitlementDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.EntitlementUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.EntitlementUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EntitlementPayload>
          }
          aggregate: {
            args: Prisma.EntitlementAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateEntitlement>
          }
          groupBy: {
            args: Prisma.EntitlementGroupByArgs<ExtArgs>
            result: $Utils.Optional<EntitlementGroupByOutputType>[]
          }
          count: {
            args: Prisma.EntitlementCountArgs<ExtArgs>
            result: $Utils.Optional<EntitlementCountAggregateOutputType> | number
          }
        }
      }
      AuditLog: {
        payload: Prisma.$AuditLogPayload<ExtArgs>
        fields: Prisma.AuditLogFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AuditLogFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AuditLogFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>
          }
          findFirst: {
            args: Prisma.AuditLogFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AuditLogFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>
          }
          findMany: {
            args: Prisma.AuditLogFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>[]
          }
          create: {
            args: Prisma.AuditLogCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>
          }
          createMany: {
            args: Prisma.AuditLogCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AuditLogCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>[]
          }
          delete: {
            args: Prisma.AuditLogDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>
          }
          update: {
            args: Prisma.AuditLogUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>
          }
          deleteMany: {
            args: Prisma.AuditLogDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AuditLogUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.AuditLogUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>
          }
          aggregate: {
            args: Prisma.AuditLogAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAuditLog>
          }
          groupBy: {
            args: Prisma.AuditLogGroupByArgs<ExtArgs>
            result: $Utils.Optional<AuditLogGroupByOutputType>[]
          }
          count: {
            args: Prisma.AuditLogCountArgs<ExtArgs>
            result: $Utils.Optional<AuditLogCountAggregateOutputType> | number
          }
        }
      }
      WeatherData: {
        payload: Prisma.$WeatherDataPayload<ExtArgs>
        fields: Prisma.WeatherDataFieldRefs
        operations: {
          findUnique: {
            args: Prisma.WeatherDataFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WeatherDataPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.WeatherDataFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WeatherDataPayload>
          }
          findFirst: {
            args: Prisma.WeatherDataFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WeatherDataPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.WeatherDataFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WeatherDataPayload>
          }
          findMany: {
            args: Prisma.WeatherDataFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WeatherDataPayload>[]
          }
          create: {
            args: Prisma.WeatherDataCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WeatherDataPayload>
          }
          createMany: {
            args: Prisma.WeatherDataCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.WeatherDataCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WeatherDataPayload>[]
          }
          delete: {
            args: Prisma.WeatherDataDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WeatherDataPayload>
          }
          update: {
            args: Prisma.WeatherDataUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WeatherDataPayload>
          }
          deleteMany: {
            args: Prisma.WeatherDataDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.WeatherDataUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.WeatherDataUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WeatherDataPayload>
          }
          aggregate: {
            args: Prisma.WeatherDataAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateWeatherData>
          }
          groupBy: {
            args: Prisma.WeatherDataGroupByArgs<ExtArgs>
            result: $Utils.Optional<WeatherDataGroupByOutputType>[]
          }
          count: {
            args: Prisma.WeatherDataCountArgs<ExtArgs>
            result: $Utils.Optional<WeatherDataCountAggregateOutputType> | number
          }
        }
      }
    }
  } & {
    other: {
      payload: any
      operations: {
        $executeRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $executeRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $queryRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $queryRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
      }
    }
  }
  export const defineExtension: $Extensions.ExtendsHook<"define", Prisma.TypeMapCb, $Extensions.DefaultArgs>
  export type DefaultPrismaClient = PrismaClient
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'
  export interface PrismaClientOptions {
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasourceUrl?: string
    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat
    /**
     * @example
     * ```
     * // Defaults to stdout
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events
     * log: [
     *   { emit: 'stdout', level: 'query' },
     *   { emit: 'stdout', level: 'info' },
     *   { emit: 'stdout', level: 'warn' }
     *   { emit: 'stdout', level: 'error' }
     * ]
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: (LogLevel | LogDefinition)[]
    /**
     * The default values for transactionOptions
     * maxWait ?= 2000
     * timeout ?= 5000
     */
    transactionOptions?: {
      maxWait?: number
      timeout?: number
      isolationLevel?: Prisma.TransactionIsolationLevel
    }
  }


  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type GetLogType<T extends LogLevel | LogDefinition> = T extends LogDefinition ? T['emit'] extends 'event' ? T['level'] : never : never
  export type GetEvents<T extends any> = T extends Array<LogLevel | LogDefinition> ?
    GetLogType<T[0]> | GetLogType<T[1]> | GetLogType<T[2]> | GetLogType<T[3]>
    : never

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findUniqueOrThrow'
    | 'findMany'
    | 'findFirst'
    | 'findFirstOrThrow'
    | 'create'
    | 'createMany'
    | 'createManyAndReturn'
    | 'update'
    | 'updateMany'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'
    | 'groupBy'

  /**
   * These options are being passed into the middleware as "params"
   */
  export type MiddlewareParams = {
    model?: ModelName
    action: PrismaAction
    args: any
    dataPath: string[]
    runInTransaction: boolean
  }

  /**
   * The `T` type makes sure, that the `return proceed` is not forgotten in the middleware implementation
   */
  export type Middleware<T = any> = (
    params: MiddlewareParams,
    next: (params: MiddlewareParams) => $Utils.JsPromise<T>,
  ) => $Utils.JsPromise<T>

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type TenantCountOutputType
   */

  export type TenantCountOutputType = {
    memberships: number
    sites: number
    devices: number
    alertRules: number
    alertEvents: number
    notificationChannels: number
    notificationEvents: number
    dailyRollups: number
    entitlements: number
    auditLogs: number
    otaJobs: number
    weatherData: number
  }

  export type TenantCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    memberships?: boolean | TenantCountOutputTypeCountMembershipsArgs
    sites?: boolean | TenantCountOutputTypeCountSitesArgs
    devices?: boolean | TenantCountOutputTypeCountDevicesArgs
    alertRules?: boolean | TenantCountOutputTypeCountAlertRulesArgs
    alertEvents?: boolean | TenantCountOutputTypeCountAlertEventsArgs
    notificationChannels?: boolean | TenantCountOutputTypeCountNotificationChannelsArgs
    notificationEvents?: boolean | TenantCountOutputTypeCountNotificationEventsArgs
    dailyRollups?: boolean | TenantCountOutputTypeCountDailyRollupsArgs
    entitlements?: boolean | TenantCountOutputTypeCountEntitlementsArgs
    auditLogs?: boolean | TenantCountOutputTypeCountAuditLogsArgs
    otaJobs?: boolean | TenantCountOutputTypeCountOtaJobsArgs
    weatherData?: boolean | TenantCountOutputTypeCountWeatherDataArgs
  }

  // Custom InputTypes
  /**
   * TenantCountOutputType without action
   */
  export type TenantCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TenantCountOutputType
     */
    select?: TenantCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * TenantCountOutputType without action
   */
  export type TenantCountOutputTypeCountMembershipsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MembershipWhereInput
  }

  /**
   * TenantCountOutputType without action
   */
  export type TenantCountOutputTypeCountSitesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SiteWhereInput
  }

  /**
   * TenantCountOutputType without action
   */
  export type TenantCountOutputTypeCountDevicesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DeviceWhereInput
  }

  /**
   * TenantCountOutputType without action
   */
  export type TenantCountOutputTypeCountAlertRulesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AlertRuleWhereInput
  }

  /**
   * TenantCountOutputType without action
   */
  export type TenantCountOutputTypeCountAlertEventsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AlertEventWhereInput
  }

  /**
   * TenantCountOutputType without action
   */
  export type TenantCountOutputTypeCountNotificationChannelsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: NotificationChannelWhereInput
  }

  /**
   * TenantCountOutputType without action
   */
  export type TenantCountOutputTypeCountNotificationEventsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: NotificationEventWhereInput
  }

  /**
   * TenantCountOutputType without action
   */
  export type TenantCountOutputTypeCountDailyRollupsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DailyRollupWhereInput
  }

  /**
   * TenantCountOutputType without action
   */
  export type TenantCountOutputTypeCountEntitlementsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EntitlementWhereInput
  }

  /**
   * TenantCountOutputType without action
   */
  export type TenantCountOutputTypeCountAuditLogsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AuditLogWhereInput
  }

  /**
   * TenantCountOutputType without action
   */
  export type TenantCountOutputTypeCountOtaJobsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: OtaJobWhereInput
  }

  /**
   * TenantCountOutputType without action
   */
  export type TenantCountOutputTypeCountWeatherDataArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: WeatherDataWhereInput
  }


  /**
   * Count Type UserCountOutputType
   */

  export type UserCountOutputType = {
    memberships: number
    commands: number
    otaJobs: number
    simActions: number
    siteLocUpdates: number
  }

  export type UserCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    memberships?: boolean | UserCountOutputTypeCountMembershipsArgs
    commands?: boolean | UserCountOutputTypeCountCommandsArgs
    otaJobs?: boolean | UserCountOutputTypeCountOtaJobsArgs
    simActions?: boolean | UserCountOutputTypeCountSimActionsArgs
    siteLocUpdates?: boolean | UserCountOutputTypeCountSiteLocUpdatesArgs
  }

  // Custom InputTypes
  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserCountOutputType
     */
    select?: UserCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountMembershipsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MembershipWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountCommandsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CommandWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountOtaJobsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: OtaJobWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountSimActionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SimActionWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountSiteLocUpdatesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SiteWhereInput
  }


  /**
   * Count Type SiteCountOutputType
   */

  export type SiteCountOutputType = {
    devices: number
    weatherData: number
  }

  export type SiteCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    devices?: boolean | SiteCountOutputTypeCountDevicesArgs
    weatherData?: boolean | SiteCountOutputTypeCountWeatherDataArgs
  }

  // Custom InputTypes
  /**
   * SiteCountOutputType without action
   */
  export type SiteCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SiteCountOutputType
     */
    select?: SiteCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * SiteCountOutputType without action
   */
  export type SiteCountOutputTypeCountDevicesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DeviceWhereInput
  }

  /**
   * SiteCountOutputType without action
   */
  export type SiteCountOutputTypeCountWeatherDataArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: WeatherDataWhereInput
  }


  /**
   * Count Type DeviceCountOutputType
   */

  export type DeviceCountOutputType = {
    telemetry: number
    commands: number
    alertEvents: number
    dailyRollups: number
    entitlements: number
  }

  export type DeviceCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    telemetry?: boolean | DeviceCountOutputTypeCountTelemetryArgs
    commands?: boolean | DeviceCountOutputTypeCountCommandsArgs
    alertEvents?: boolean | DeviceCountOutputTypeCountAlertEventsArgs
    dailyRollups?: boolean | DeviceCountOutputTypeCountDailyRollupsArgs
    entitlements?: boolean | DeviceCountOutputTypeCountEntitlementsArgs
  }

  // Custom InputTypes
  /**
   * DeviceCountOutputType without action
   */
  export type DeviceCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeviceCountOutputType
     */
    select?: DeviceCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * DeviceCountOutputType without action
   */
  export type DeviceCountOutputTypeCountTelemetryArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TelemetryWhereInput
  }

  /**
   * DeviceCountOutputType without action
   */
  export type DeviceCountOutputTypeCountCommandsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CommandWhereInput
  }

  /**
   * DeviceCountOutputType without action
   */
  export type DeviceCountOutputTypeCountAlertEventsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AlertEventWhereInput
  }

  /**
   * DeviceCountOutputType without action
   */
  export type DeviceCountOutputTypeCountDailyRollupsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DailyRollupWhereInput
  }

  /**
   * DeviceCountOutputType without action
   */
  export type DeviceCountOutputTypeCountEntitlementsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EntitlementWhereInput
  }


  /**
   * Count Type FirmwarePackageCountOutputType
   */

  export type FirmwarePackageCountOutputType = {
    otaJobs: number
  }

  export type FirmwarePackageCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    otaJobs?: boolean | FirmwarePackageCountOutputTypeCountOtaJobsArgs
  }

  // Custom InputTypes
  /**
   * FirmwarePackageCountOutputType without action
   */
  export type FirmwarePackageCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FirmwarePackageCountOutputType
     */
    select?: FirmwarePackageCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * FirmwarePackageCountOutputType without action
   */
  export type FirmwarePackageCountOutputTypeCountOtaJobsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: OtaJobWhereInput
  }


  /**
   * Count Type SimInfoCountOutputType
   */

  export type SimInfoCountOutputType = {
    devices: number
    simActions: number
  }

  export type SimInfoCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    devices?: boolean | SimInfoCountOutputTypeCountDevicesArgs
    simActions?: boolean | SimInfoCountOutputTypeCountSimActionsArgs
  }

  // Custom InputTypes
  /**
   * SimInfoCountOutputType without action
   */
  export type SimInfoCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SimInfoCountOutputType
     */
    select?: SimInfoCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * SimInfoCountOutputType without action
   */
  export type SimInfoCountOutputTypeCountDevicesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DeviceWhereInput
  }

  /**
   * SimInfoCountOutputType without action
   */
  export type SimInfoCountOutputTypeCountSimActionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SimActionWhereInput
  }


  /**
   * Count Type AlertRuleCountOutputType
   */

  export type AlertRuleCountOutputType = {
    alertEvents: number
  }

  export type AlertRuleCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    alertEvents?: boolean | AlertRuleCountOutputTypeCountAlertEventsArgs
  }

  // Custom InputTypes
  /**
   * AlertRuleCountOutputType without action
   */
  export type AlertRuleCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AlertRuleCountOutputType
     */
    select?: AlertRuleCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * AlertRuleCountOutputType without action
   */
  export type AlertRuleCountOutputTypeCountAlertEventsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AlertEventWhereInput
  }


  /**
   * Count Type AlertEventCountOutputType
   */

  export type AlertEventCountOutputType = {
    notificationEvents: number
  }

  export type AlertEventCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    notificationEvents?: boolean | AlertEventCountOutputTypeCountNotificationEventsArgs
  }

  // Custom InputTypes
  /**
   * AlertEventCountOutputType without action
   */
  export type AlertEventCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AlertEventCountOutputType
     */
    select?: AlertEventCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * AlertEventCountOutputType without action
   */
  export type AlertEventCountOutputTypeCountNotificationEventsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: NotificationEventWhereInput
  }


  /**
   * Count Type NotificationChannelCountOutputType
   */

  export type NotificationChannelCountOutputType = {
    notificationEvents: number
  }

  export type NotificationChannelCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    notificationEvents?: boolean | NotificationChannelCountOutputTypeCountNotificationEventsArgs
  }

  // Custom InputTypes
  /**
   * NotificationChannelCountOutputType without action
   */
  export type NotificationChannelCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NotificationChannelCountOutputType
     */
    select?: NotificationChannelCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * NotificationChannelCountOutputType without action
   */
  export type NotificationChannelCountOutputTypeCountNotificationEventsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: NotificationEventWhereInput
  }


  /**
   * Models
   */

  /**
   * Model Tenant
   */

  export type AggregateTenant = {
    _count: TenantCountAggregateOutputType | null
    _min: TenantMinAggregateOutputType | null
    _max: TenantMaxAggregateOutputType | null
  }

  export type TenantMinAggregateOutputType = {
    id: string | null
    name: string | null
    type: $Enums.TenantType | null
    status: $Enums.TenantStatus | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type TenantMaxAggregateOutputType = {
    id: string | null
    name: string | null
    type: $Enums.TenantType | null
    status: $Enums.TenantStatus | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type TenantCountAggregateOutputType = {
    id: number
    name: number
    type: number
    status: number
    settings: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type TenantMinAggregateInputType = {
    id?: true
    name?: true
    type?: true
    status?: true
    createdAt?: true
    updatedAt?: true
  }

  export type TenantMaxAggregateInputType = {
    id?: true
    name?: true
    type?: true
    status?: true
    createdAt?: true
    updatedAt?: true
  }

  export type TenantCountAggregateInputType = {
    id?: true
    name?: true
    type?: true
    status?: true
    settings?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type TenantAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Tenant to aggregate.
     */
    where?: TenantWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Tenants to fetch.
     */
    orderBy?: TenantOrderByWithRelationInput | TenantOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TenantWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Tenants from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Tenants.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Tenants
    **/
    _count?: true | TenantCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TenantMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TenantMaxAggregateInputType
  }

  export type GetTenantAggregateType<T extends TenantAggregateArgs> = {
        [P in keyof T & keyof AggregateTenant]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTenant[P]>
      : GetScalarType<T[P], AggregateTenant[P]>
  }




  export type TenantGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TenantWhereInput
    orderBy?: TenantOrderByWithAggregationInput | TenantOrderByWithAggregationInput[]
    by: TenantScalarFieldEnum[] | TenantScalarFieldEnum
    having?: TenantScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TenantCountAggregateInputType | true
    _min?: TenantMinAggregateInputType
    _max?: TenantMaxAggregateInputType
  }

  export type TenantGroupByOutputType = {
    id: string
    name: string
    type: $Enums.TenantType
    status: $Enums.TenantStatus
    settings: JsonValue | null
    createdAt: Date
    updatedAt: Date
    _count: TenantCountAggregateOutputType | null
    _min: TenantMinAggregateOutputType | null
    _max: TenantMaxAggregateOutputType | null
  }

  type GetTenantGroupByPayload<T extends TenantGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TenantGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TenantGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TenantGroupByOutputType[P]>
            : GetScalarType<T[P], TenantGroupByOutputType[P]>
        }
      >
    >


  export type TenantSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    type?: boolean
    status?: boolean
    settings?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    memberships?: boolean | Tenant$membershipsArgs<ExtArgs>
    sites?: boolean | Tenant$sitesArgs<ExtArgs>
    devices?: boolean | Tenant$devicesArgs<ExtArgs>
    alertRules?: boolean | Tenant$alertRulesArgs<ExtArgs>
    alertEvents?: boolean | Tenant$alertEventsArgs<ExtArgs>
    notificationChannels?: boolean | Tenant$notificationChannelsArgs<ExtArgs>
    notificationEvents?: boolean | Tenant$notificationEventsArgs<ExtArgs>
    dailyRollups?: boolean | Tenant$dailyRollupsArgs<ExtArgs>
    entitlements?: boolean | Tenant$entitlementsArgs<ExtArgs>
    auditLogs?: boolean | Tenant$auditLogsArgs<ExtArgs>
    otaJobs?: boolean | Tenant$otaJobsArgs<ExtArgs>
    weatherData?: boolean | Tenant$weatherDataArgs<ExtArgs>
    _count?: boolean | TenantCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["tenant"]>

  export type TenantSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    type?: boolean
    status?: boolean
    settings?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["tenant"]>

  export type TenantSelectScalar = {
    id?: boolean
    name?: boolean
    type?: boolean
    status?: boolean
    settings?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type TenantInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    memberships?: boolean | Tenant$membershipsArgs<ExtArgs>
    sites?: boolean | Tenant$sitesArgs<ExtArgs>
    devices?: boolean | Tenant$devicesArgs<ExtArgs>
    alertRules?: boolean | Tenant$alertRulesArgs<ExtArgs>
    alertEvents?: boolean | Tenant$alertEventsArgs<ExtArgs>
    notificationChannels?: boolean | Tenant$notificationChannelsArgs<ExtArgs>
    notificationEvents?: boolean | Tenant$notificationEventsArgs<ExtArgs>
    dailyRollups?: boolean | Tenant$dailyRollupsArgs<ExtArgs>
    entitlements?: boolean | Tenant$entitlementsArgs<ExtArgs>
    auditLogs?: boolean | Tenant$auditLogsArgs<ExtArgs>
    otaJobs?: boolean | Tenant$otaJobsArgs<ExtArgs>
    weatherData?: boolean | Tenant$weatherDataArgs<ExtArgs>
    _count?: boolean | TenantCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type TenantIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $TenantPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Tenant"
    objects: {
      memberships: Prisma.$MembershipPayload<ExtArgs>[]
      sites: Prisma.$SitePayload<ExtArgs>[]
      devices: Prisma.$DevicePayload<ExtArgs>[]
      alertRules: Prisma.$AlertRulePayload<ExtArgs>[]
      alertEvents: Prisma.$AlertEventPayload<ExtArgs>[]
      notificationChannels: Prisma.$NotificationChannelPayload<ExtArgs>[]
      notificationEvents: Prisma.$NotificationEventPayload<ExtArgs>[]
      dailyRollups: Prisma.$DailyRollupPayload<ExtArgs>[]
      entitlements: Prisma.$EntitlementPayload<ExtArgs>[]
      auditLogs: Prisma.$AuditLogPayload<ExtArgs>[]
      otaJobs: Prisma.$OtaJobPayload<ExtArgs>[]
      weatherData: Prisma.$WeatherDataPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      type: $Enums.TenantType
      status: $Enums.TenantStatus
      settings: Prisma.JsonValue | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["tenant"]>
    composites: {}
  }

  type TenantGetPayload<S extends boolean | null | undefined | TenantDefaultArgs> = $Result.GetResult<Prisma.$TenantPayload, S>

  type TenantCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<TenantFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: TenantCountAggregateInputType | true
    }

  export interface TenantDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Tenant'], meta: { name: 'Tenant' } }
    /**
     * Find zero or one Tenant that matches the filter.
     * @param {TenantFindUniqueArgs} args - Arguments to find a Tenant
     * @example
     * // Get one Tenant
     * const tenant = await prisma.tenant.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TenantFindUniqueArgs>(args: SelectSubset<T, TenantFindUniqueArgs<ExtArgs>>): Prisma__TenantClient<$Result.GetResult<Prisma.$TenantPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Tenant that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {TenantFindUniqueOrThrowArgs} args - Arguments to find a Tenant
     * @example
     * // Get one Tenant
     * const tenant = await prisma.tenant.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TenantFindUniqueOrThrowArgs>(args: SelectSubset<T, TenantFindUniqueOrThrowArgs<ExtArgs>>): Prisma__TenantClient<$Result.GetResult<Prisma.$TenantPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Tenant that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TenantFindFirstArgs} args - Arguments to find a Tenant
     * @example
     * // Get one Tenant
     * const tenant = await prisma.tenant.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TenantFindFirstArgs>(args?: SelectSubset<T, TenantFindFirstArgs<ExtArgs>>): Prisma__TenantClient<$Result.GetResult<Prisma.$TenantPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Tenant that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TenantFindFirstOrThrowArgs} args - Arguments to find a Tenant
     * @example
     * // Get one Tenant
     * const tenant = await prisma.tenant.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TenantFindFirstOrThrowArgs>(args?: SelectSubset<T, TenantFindFirstOrThrowArgs<ExtArgs>>): Prisma__TenantClient<$Result.GetResult<Prisma.$TenantPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Tenants that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TenantFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Tenants
     * const tenants = await prisma.tenant.findMany()
     * 
     * // Get first 10 Tenants
     * const tenants = await prisma.tenant.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const tenantWithIdOnly = await prisma.tenant.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends TenantFindManyArgs>(args?: SelectSubset<T, TenantFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TenantPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Tenant.
     * @param {TenantCreateArgs} args - Arguments to create a Tenant.
     * @example
     * // Create one Tenant
     * const Tenant = await prisma.tenant.create({
     *   data: {
     *     // ... data to create a Tenant
     *   }
     * })
     * 
     */
    create<T extends TenantCreateArgs>(args: SelectSubset<T, TenantCreateArgs<ExtArgs>>): Prisma__TenantClient<$Result.GetResult<Prisma.$TenantPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Tenants.
     * @param {TenantCreateManyArgs} args - Arguments to create many Tenants.
     * @example
     * // Create many Tenants
     * const tenant = await prisma.tenant.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends TenantCreateManyArgs>(args?: SelectSubset<T, TenantCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Tenants and returns the data saved in the database.
     * @param {TenantCreateManyAndReturnArgs} args - Arguments to create many Tenants.
     * @example
     * // Create many Tenants
     * const tenant = await prisma.tenant.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Tenants and only return the `id`
     * const tenantWithIdOnly = await prisma.tenant.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends TenantCreateManyAndReturnArgs>(args?: SelectSubset<T, TenantCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TenantPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Tenant.
     * @param {TenantDeleteArgs} args - Arguments to delete one Tenant.
     * @example
     * // Delete one Tenant
     * const Tenant = await prisma.tenant.delete({
     *   where: {
     *     // ... filter to delete one Tenant
     *   }
     * })
     * 
     */
    delete<T extends TenantDeleteArgs>(args: SelectSubset<T, TenantDeleteArgs<ExtArgs>>): Prisma__TenantClient<$Result.GetResult<Prisma.$TenantPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Tenant.
     * @param {TenantUpdateArgs} args - Arguments to update one Tenant.
     * @example
     * // Update one Tenant
     * const tenant = await prisma.tenant.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends TenantUpdateArgs>(args: SelectSubset<T, TenantUpdateArgs<ExtArgs>>): Prisma__TenantClient<$Result.GetResult<Prisma.$TenantPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Tenants.
     * @param {TenantDeleteManyArgs} args - Arguments to filter Tenants to delete.
     * @example
     * // Delete a few Tenants
     * const { count } = await prisma.tenant.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends TenantDeleteManyArgs>(args?: SelectSubset<T, TenantDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Tenants.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TenantUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Tenants
     * const tenant = await prisma.tenant.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends TenantUpdateManyArgs>(args: SelectSubset<T, TenantUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Tenant.
     * @param {TenantUpsertArgs} args - Arguments to update or create a Tenant.
     * @example
     * // Update or create a Tenant
     * const tenant = await prisma.tenant.upsert({
     *   create: {
     *     // ... data to create a Tenant
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Tenant we want to update
     *   }
     * })
     */
    upsert<T extends TenantUpsertArgs>(args: SelectSubset<T, TenantUpsertArgs<ExtArgs>>): Prisma__TenantClient<$Result.GetResult<Prisma.$TenantPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Tenants.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TenantCountArgs} args - Arguments to filter Tenants to count.
     * @example
     * // Count the number of Tenants
     * const count = await prisma.tenant.count({
     *   where: {
     *     // ... the filter for the Tenants we want to count
     *   }
     * })
    **/
    count<T extends TenantCountArgs>(
      args?: Subset<T, TenantCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TenantCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Tenant.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TenantAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TenantAggregateArgs>(args: Subset<T, TenantAggregateArgs>): Prisma.PrismaPromise<GetTenantAggregateType<T>>

    /**
     * Group by Tenant.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TenantGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TenantGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TenantGroupByArgs['orderBy'] }
        : { orderBy?: TenantGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TenantGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTenantGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Tenant model
   */
  readonly fields: TenantFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Tenant.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TenantClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    memberships<T extends Tenant$membershipsArgs<ExtArgs> = {}>(args?: Subset<T, Tenant$membershipsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MembershipPayload<ExtArgs>, T, "findMany"> | Null>
    sites<T extends Tenant$sitesArgs<ExtArgs> = {}>(args?: Subset<T, Tenant$sitesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SitePayload<ExtArgs>, T, "findMany"> | Null>
    devices<T extends Tenant$devicesArgs<ExtArgs> = {}>(args?: Subset<T, Tenant$devicesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DevicePayload<ExtArgs>, T, "findMany"> | Null>
    alertRules<T extends Tenant$alertRulesArgs<ExtArgs> = {}>(args?: Subset<T, Tenant$alertRulesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AlertRulePayload<ExtArgs>, T, "findMany"> | Null>
    alertEvents<T extends Tenant$alertEventsArgs<ExtArgs> = {}>(args?: Subset<T, Tenant$alertEventsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AlertEventPayload<ExtArgs>, T, "findMany"> | Null>
    notificationChannels<T extends Tenant$notificationChannelsArgs<ExtArgs> = {}>(args?: Subset<T, Tenant$notificationChannelsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NotificationChannelPayload<ExtArgs>, T, "findMany"> | Null>
    notificationEvents<T extends Tenant$notificationEventsArgs<ExtArgs> = {}>(args?: Subset<T, Tenant$notificationEventsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NotificationEventPayload<ExtArgs>, T, "findMany"> | Null>
    dailyRollups<T extends Tenant$dailyRollupsArgs<ExtArgs> = {}>(args?: Subset<T, Tenant$dailyRollupsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DailyRollupPayload<ExtArgs>, T, "findMany"> | Null>
    entitlements<T extends Tenant$entitlementsArgs<ExtArgs> = {}>(args?: Subset<T, Tenant$entitlementsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EntitlementPayload<ExtArgs>, T, "findMany"> | Null>
    auditLogs<T extends Tenant$auditLogsArgs<ExtArgs> = {}>(args?: Subset<T, Tenant$auditLogsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "findMany"> | Null>
    otaJobs<T extends Tenant$otaJobsArgs<ExtArgs> = {}>(args?: Subset<T, Tenant$otaJobsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OtaJobPayload<ExtArgs>, T, "findMany"> | Null>
    weatherData<T extends Tenant$weatherDataArgs<ExtArgs> = {}>(args?: Subset<T, Tenant$weatherDataArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WeatherDataPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Tenant model
   */ 
  interface TenantFieldRefs {
    readonly id: FieldRef<"Tenant", 'String'>
    readonly name: FieldRef<"Tenant", 'String'>
    readonly type: FieldRef<"Tenant", 'TenantType'>
    readonly status: FieldRef<"Tenant", 'TenantStatus'>
    readonly settings: FieldRef<"Tenant", 'Json'>
    readonly createdAt: FieldRef<"Tenant", 'DateTime'>
    readonly updatedAt: FieldRef<"Tenant", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Tenant findUnique
   */
  export type TenantFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tenant
     */
    select?: TenantSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TenantInclude<ExtArgs> | null
    /**
     * Filter, which Tenant to fetch.
     */
    where: TenantWhereUniqueInput
  }

  /**
   * Tenant findUniqueOrThrow
   */
  export type TenantFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tenant
     */
    select?: TenantSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TenantInclude<ExtArgs> | null
    /**
     * Filter, which Tenant to fetch.
     */
    where: TenantWhereUniqueInput
  }

  /**
   * Tenant findFirst
   */
  export type TenantFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tenant
     */
    select?: TenantSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TenantInclude<ExtArgs> | null
    /**
     * Filter, which Tenant to fetch.
     */
    where?: TenantWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Tenants to fetch.
     */
    orderBy?: TenantOrderByWithRelationInput | TenantOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Tenants.
     */
    cursor?: TenantWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Tenants from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Tenants.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Tenants.
     */
    distinct?: TenantScalarFieldEnum | TenantScalarFieldEnum[]
  }

  /**
   * Tenant findFirstOrThrow
   */
  export type TenantFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tenant
     */
    select?: TenantSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TenantInclude<ExtArgs> | null
    /**
     * Filter, which Tenant to fetch.
     */
    where?: TenantWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Tenants to fetch.
     */
    orderBy?: TenantOrderByWithRelationInput | TenantOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Tenants.
     */
    cursor?: TenantWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Tenants from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Tenants.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Tenants.
     */
    distinct?: TenantScalarFieldEnum | TenantScalarFieldEnum[]
  }

  /**
   * Tenant findMany
   */
  export type TenantFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tenant
     */
    select?: TenantSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TenantInclude<ExtArgs> | null
    /**
     * Filter, which Tenants to fetch.
     */
    where?: TenantWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Tenants to fetch.
     */
    orderBy?: TenantOrderByWithRelationInput | TenantOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Tenants.
     */
    cursor?: TenantWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Tenants from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Tenants.
     */
    skip?: number
    distinct?: TenantScalarFieldEnum | TenantScalarFieldEnum[]
  }

  /**
   * Tenant create
   */
  export type TenantCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tenant
     */
    select?: TenantSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TenantInclude<ExtArgs> | null
    /**
     * The data needed to create a Tenant.
     */
    data: XOR<TenantCreateInput, TenantUncheckedCreateInput>
  }

  /**
   * Tenant createMany
   */
  export type TenantCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Tenants.
     */
    data: TenantCreateManyInput | TenantCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Tenant createManyAndReturn
   */
  export type TenantCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tenant
     */
    select?: TenantSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Tenants.
     */
    data: TenantCreateManyInput | TenantCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Tenant update
   */
  export type TenantUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tenant
     */
    select?: TenantSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TenantInclude<ExtArgs> | null
    /**
     * The data needed to update a Tenant.
     */
    data: XOR<TenantUpdateInput, TenantUncheckedUpdateInput>
    /**
     * Choose, which Tenant to update.
     */
    where: TenantWhereUniqueInput
  }

  /**
   * Tenant updateMany
   */
  export type TenantUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Tenants.
     */
    data: XOR<TenantUpdateManyMutationInput, TenantUncheckedUpdateManyInput>
    /**
     * Filter which Tenants to update
     */
    where?: TenantWhereInput
  }

  /**
   * Tenant upsert
   */
  export type TenantUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tenant
     */
    select?: TenantSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TenantInclude<ExtArgs> | null
    /**
     * The filter to search for the Tenant to update in case it exists.
     */
    where: TenantWhereUniqueInput
    /**
     * In case the Tenant found by the `where` argument doesn't exist, create a new Tenant with this data.
     */
    create: XOR<TenantCreateInput, TenantUncheckedCreateInput>
    /**
     * In case the Tenant was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TenantUpdateInput, TenantUncheckedUpdateInput>
  }

  /**
   * Tenant delete
   */
  export type TenantDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tenant
     */
    select?: TenantSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TenantInclude<ExtArgs> | null
    /**
     * Filter which Tenant to delete.
     */
    where: TenantWhereUniqueInput
  }

  /**
   * Tenant deleteMany
   */
  export type TenantDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Tenants to delete
     */
    where?: TenantWhereInput
  }

  /**
   * Tenant.memberships
   */
  export type Tenant$membershipsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Membership
     */
    select?: MembershipSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MembershipInclude<ExtArgs> | null
    where?: MembershipWhereInput
    orderBy?: MembershipOrderByWithRelationInput | MembershipOrderByWithRelationInput[]
    cursor?: MembershipWhereUniqueInput
    take?: number
    skip?: number
    distinct?: MembershipScalarFieldEnum | MembershipScalarFieldEnum[]
  }

  /**
   * Tenant.sites
   */
  export type Tenant$sitesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Site
     */
    select?: SiteSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SiteInclude<ExtArgs> | null
    where?: SiteWhereInput
    orderBy?: SiteOrderByWithRelationInput | SiteOrderByWithRelationInput[]
    cursor?: SiteWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SiteScalarFieldEnum | SiteScalarFieldEnum[]
  }

  /**
   * Tenant.devices
   */
  export type Tenant$devicesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Device
     */
    select?: DeviceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeviceInclude<ExtArgs> | null
    where?: DeviceWhereInput
    orderBy?: DeviceOrderByWithRelationInput | DeviceOrderByWithRelationInput[]
    cursor?: DeviceWhereUniqueInput
    take?: number
    skip?: number
    distinct?: DeviceScalarFieldEnum | DeviceScalarFieldEnum[]
  }

  /**
   * Tenant.alertRules
   */
  export type Tenant$alertRulesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AlertRule
     */
    select?: AlertRuleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AlertRuleInclude<ExtArgs> | null
    where?: AlertRuleWhereInput
    orderBy?: AlertRuleOrderByWithRelationInput | AlertRuleOrderByWithRelationInput[]
    cursor?: AlertRuleWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AlertRuleScalarFieldEnum | AlertRuleScalarFieldEnum[]
  }

  /**
   * Tenant.alertEvents
   */
  export type Tenant$alertEventsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AlertEvent
     */
    select?: AlertEventSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AlertEventInclude<ExtArgs> | null
    where?: AlertEventWhereInput
    orderBy?: AlertEventOrderByWithRelationInput | AlertEventOrderByWithRelationInput[]
    cursor?: AlertEventWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AlertEventScalarFieldEnum | AlertEventScalarFieldEnum[]
  }

  /**
   * Tenant.notificationChannels
   */
  export type Tenant$notificationChannelsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NotificationChannel
     */
    select?: NotificationChannelSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationChannelInclude<ExtArgs> | null
    where?: NotificationChannelWhereInput
    orderBy?: NotificationChannelOrderByWithRelationInput | NotificationChannelOrderByWithRelationInput[]
    cursor?: NotificationChannelWhereUniqueInput
    take?: number
    skip?: number
    distinct?: NotificationChannelScalarFieldEnum | NotificationChannelScalarFieldEnum[]
  }

  /**
   * Tenant.notificationEvents
   */
  export type Tenant$notificationEventsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NotificationEvent
     */
    select?: NotificationEventSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationEventInclude<ExtArgs> | null
    where?: NotificationEventWhereInput
    orderBy?: NotificationEventOrderByWithRelationInput | NotificationEventOrderByWithRelationInput[]
    cursor?: NotificationEventWhereUniqueInput
    take?: number
    skip?: number
    distinct?: NotificationEventScalarFieldEnum | NotificationEventScalarFieldEnum[]
  }

  /**
   * Tenant.dailyRollups
   */
  export type Tenant$dailyRollupsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DailyRollup
     */
    select?: DailyRollupSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DailyRollupInclude<ExtArgs> | null
    where?: DailyRollupWhereInput
    orderBy?: DailyRollupOrderByWithRelationInput | DailyRollupOrderByWithRelationInput[]
    cursor?: DailyRollupWhereUniqueInput
    take?: number
    skip?: number
    distinct?: DailyRollupScalarFieldEnum | DailyRollupScalarFieldEnum[]
  }

  /**
   * Tenant.entitlements
   */
  export type Tenant$entitlementsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Entitlement
     */
    select?: EntitlementSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EntitlementInclude<ExtArgs> | null
    where?: EntitlementWhereInput
    orderBy?: EntitlementOrderByWithRelationInput | EntitlementOrderByWithRelationInput[]
    cursor?: EntitlementWhereUniqueInput
    take?: number
    skip?: number
    distinct?: EntitlementScalarFieldEnum | EntitlementScalarFieldEnum[]
  }

  /**
   * Tenant.auditLogs
   */
  export type Tenant$auditLogsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    where?: AuditLogWhereInput
    orderBy?: AuditLogOrderByWithRelationInput | AuditLogOrderByWithRelationInput[]
    cursor?: AuditLogWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AuditLogScalarFieldEnum | AuditLogScalarFieldEnum[]
  }

  /**
   * Tenant.otaJobs
   */
  export type Tenant$otaJobsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OtaJob
     */
    select?: OtaJobSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OtaJobInclude<ExtArgs> | null
    where?: OtaJobWhereInput
    orderBy?: OtaJobOrderByWithRelationInput | OtaJobOrderByWithRelationInput[]
    cursor?: OtaJobWhereUniqueInput
    take?: number
    skip?: number
    distinct?: OtaJobScalarFieldEnum | OtaJobScalarFieldEnum[]
  }

  /**
   * Tenant.weatherData
   */
  export type Tenant$weatherDataArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WeatherData
     */
    select?: WeatherDataSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WeatherDataInclude<ExtArgs> | null
    where?: WeatherDataWhereInput
    orderBy?: WeatherDataOrderByWithRelationInput | WeatherDataOrderByWithRelationInput[]
    cursor?: WeatherDataWhereUniqueInput
    take?: number
    skip?: number
    distinct?: WeatherDataScalarFieldEnum | WeatherDataScalarFieldEnum[]
  }

  /**
   * Tenant without action
   */
  export type TenantDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tenant
     */
    select?: TenantSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TenantInclude<ExtArgs> | null
  }


  /**
   * Model User
   */

  export type AggregateUser = {
    _count: UserCountAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  export type UserMinAggregateOutputType = {
    id: string | null
    email: string | null
    passwordHash: string | null
    name: string | null
    status: $Enums.UserStatus | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UserMaxAggregateOutputType = {
    id: string | null
    email: string | null
    passwordHash: string | null
    name: string | null
    status: $Enums.UserStatus | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UserCountAggregateOutputType = {
    id: number
    email: number
    passwordHash: number
    name: number
    status: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type UserMinAggregateInputType = {
    id?: true
    email?: true
    passwordHash?: true
    name?: true
    status?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UserMaxAggregateInputType = {
    id?: true
    email?: true
    passwordHash?: true
    name?: true
    status?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UserCountAggregateInputType = {
    id?: true
    email?: true
    passwordHash?: true
    name?: true
    status?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type UserAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which User to aggregate.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Users
    **/
    _count?: true | UserCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserMaxAggregateInputType
  }

  export type GetUserAggregateType<T extends UserAggregateArgs> = {
        [P in keyof T & keyof AggregateUser]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUser[P]>
      : GetScalarType<T[P], AggregateUser[P]>
  }




  export type UserGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserWhereInput
    orderBy?: UserOrderByWithAggregationInput | UserOrderByWithAggregationInput[]
    by: UserScalarFieldEnum[] | UserScalarFieldEnum
    having?: UserScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserCountAggregateInputType | true
    _min?: UserMinAggregateInputType
    _max?: UserMaxAggregateInputType
  }

  export type UserGroupByOutputType = {
    id: string
    email: string
    passwordHash: string
    name: string
    status: $Enums.UserStatus
    createdAt: Date
    updatedAt: Date
    _count: UserCountAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  type GetUserGroupByPayload<T extends UserGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserGroupByOutputType[P]>
            : GetScalarType<T[P], UserGroupByOutputType[P]>
        }
      >
    >


  export type UserSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    email?: boolean
    passwordHash?: boolean
    name?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    memberships?: boolean | User$membershipsArgs<ExtArgs>
    commands?: boolean | User$commandsArgs<ExtArgs>
    otaJobs?: boolean | User$otaJobsArgs<ExtArgs>
    simActions?: boolean | User$simActionsArgs<ExtArgs>
    siteLocUpdates?: boolean | User$siteLocUpdatesArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["user"]>

  export type UserSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    email?: boolean
    passwordHash?: boolean
    name?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["user"]>

  export type UserSelectScalar = {
    id?: boolean
    email?: boolean
    passwordHash?: boolean
    name?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type UserInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    memberships?: boolean | User$membershipsArgs<ExtArgs>
    commands?: boolean | User$commandsArgs<ExtArgs>
    otaJobs?: boolean | User$otaJobsArgs<ExtArgs>
    simActions?: boolean | User$simActionsArgs<ExtArgs>
    siteLocUpdates?: boolean | User$siteLocUpdatesArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type UserIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $UserPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "User"
    objects: {
      memberships: Prisma.$MembershipPayload<ExtArgs>[]
      commands: Prisma.$CommandPayload<ExtArgs>[]
      otaJobs: Prisma.$OtaJobPayload<ExtArgs>[]
      simActions: Prisma.$SimActionPayload<ExtArgs>[]
      siteLocUpdates: Prisma.$SitePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      email: string
      passwordHash: string
      name: string
      status: $Enums.UserStatus
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["user"]>
    composites: {}
  }

  type UserGetPayload<S extends boolean | null | undefined | UserDefaultArgs> = $Result.GetResult<Prisma.$UserPayload, S>

  type UserCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<UserFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: UserCountAggregateInputType | true
    }

  export interface UserDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['User'], meta: { name: 'User' } }
    /**
     * Find zero or one User that matches the filter.
     * @param {UserFindUniqueArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserFindUniqueArgs>(args: SelectSubset<T, UserFindUniqueArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one User that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {UserFindUniqueOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserFindUniqueOrThrowArgs>(args: SelectSubset<T, UserFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first User that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserFindFirstArgs>(args?: SelectSubset<T, UserFindFirstArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first User that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserFindFirstOrThrowArgs>(args?: SelectSubset<T, UserFindFirstOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Users that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Users
     * const users = await prisma.user.findMany()
     * 
     * // Get first 10 Users
     * const users = await prisma.user.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userWithIdOnly = await prisma.user.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UserFindManyArgs>(args?: SelectSubset<T, UserFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a User.
     * @param {UserCreateArgs} args - Arguments to create a User.
     * @example
     * // Create one User
     * const User = await prisma.user.create({
     *   data: {
     *     // ... data to create a User
     *   }
     * })
     * 
     */
    create<T extends UserCreateArgs>(args: SelectSubset<T, UserCreateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Users.
     * @param {UserCreateManyArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UserCreateManyArgs>(args?: SelectSubset<T, UserCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Users and returns the data saved in the database.
     * @param {UserCreateManyAndReturnArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Users and only return the `id`
     * const userWithIdOnly = await prisma.user.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends UserCreateManyAndReturnArgs>(args?: SelectSubset<T, UserCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a User.
     * @param {UserDeleteArgs} args - Arguments to delete one User.
     * @example
     * // Delete one User
     * const User = await prisma.user.delete({
     *   where: {
     *     // ... filter to delete one User
     *   }
     * })
     * 
     */
    delete<T extends UserDeleteArgs>(args: SelectSubset<T, UserDeleteArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one User.
     * @param {UserUpdateArgs} args - Arguments to update one User.
     * @example
     * // Update one User
     * const user = await prisma.user.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UserUpdateArgs>(args: SelectSubset<T, UserUpdateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Users.
     * @param {UserDeleteManyArgs} args - Arguments to filter Users to delete.
     * @example
     * // Delete a few Users
     * const { count } = await prisma.user.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UserDeleteManyArgs>(args?: SelectSubset<T, UserDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UserUpdateManyArgs>(args: SelectSubset<T, UserUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one User.
     * @param {UserUpsertArgs} args - Arguments to update or create a User.
     * @example
     * // Update or create a User
     * const user = await prisma.user.upsert({
     *   create: {
     *     // ... data to create a User
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the User we want to update
     *   }
     * })
     */
    upsert<T extends UserUpsertArgs>(args: SelectSubset<T, UserUpsertArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserCountArgs} args - Arguments to filter Users to count.
     * @example
     * // Count the number of Users
     * const count = await prisma.user.count({
     *   where: {
     *     // ... the filter for the Users we want to count
     *   }
     * })
    **/
    count<T extends UserCountArgs>(
      args?: Subset<T, UserCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserAggregateArgs>(args: Subset<T, UserAggregateArgs>): Prisma.PrismaPromise<GetUserAggregateType<T>>

    /**
     * Group by User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserGroupByArgs['orderBy'] }
        : { orderBy?: UserGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the User model
   */
  readonly fields: UserFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for User.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    memberships<T extends User$membershipsArgs<ExtArgs> = {}>(args?: Subset<T, User$membershipsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MembershipPayload<ExtArgs>, T, "findMany"> | Null>
    commands<T extends User$commandsArgs<ExtArgs> = {}>(args?: Subset<T, User$commandsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CommandPayload<ExtArgs>, T, "findMany"> | Null>
    otaJobs<T extends User$otaJobsArgs<ExtArgs> = {}>(args?: Subset<T, User$otaJobsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OtaJobPayload<ExtArgs>, T, "findMany"> | Null>
    simActions<T extends User$simActionsArgs<ExtArgs> = {}>(args?: Subset<T, User$simActionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SimActionPayload<ExtArgs>, T, "findMany"> | Null>
    siteLocUpdates<T extends User$siteLocUpdatesArgs<ExtArgs> = {}>(args?: Subset<T, User$siteLocUpdatesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SitePayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the User model
   */ 
  interface UserFieldRefs {
    readonly id: FieldRef<"User", 'String'>
    readonly email: FieldRef<"User", 'String'>
    readonly passwordHash: FieldRef<"User", 'String'>
    readonly name: FieldRef<"User", 'String'>
    readonly status: FieldRef<"User", 'UserStatus'>
    readonly createdAt: FieldRef<"User", 'DateTime'>
    readonly updatedAt: FieldRef<"User", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * User findUnique
   */
  export type UserFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findUniqueOrThrow
   */
  export type UserFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findFirst
   */
  export type UserFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findFirstOrThrow
   */
  export type UserFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findMany
   */
  export type UserFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which Users to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User create
   */
  export type UserCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to create a User.
     */
    data: XOR<UserCreateInput, UserUncheckedCreateInput>
  }

  /**
   * User createMany
   */
  export type UserCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * User createManyAndReturn
   */
  export type UserCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * User update
   */
  export type UserUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to update a User.
     */
    data: XOR<UserUpdateInput, UserUncheckedUpdateInput>
    /**
     * Choose, which User to update.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User updateMany
   */
  export type UserUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Users.
     */
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>
    /**
     * Filter which Users to update
     */
    where?: UserWhereInput
  }

  /**
   * User upsert
   */
  export type UserUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The filter to search for the User to update in case it exists.
     */
    where: UserWhereUniqueInput
    /**
     * In case the User found by the `where` argument doesn't exist, create a new User with this data.
     */
    create: XOR<UserCreateInput, UserUncheckedCreateInput>
    /**
     * In case the User was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserUpdateInput, UserUncheckedUpdateInput>
  }

  /**
   * User delete
   */
  export type UserDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter which User to delete.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User deleteMany
   */
  export type UserDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Users to delete
     */
    where?: UserWhereInput
  }

  /**
   * User.memberships
   */
  export type User$membershipsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Membership
     */
    select?: MembershipSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MembershipInclude<ExtArgs> | null
    where?: MembershipWhereInput
    orderBy?: MembershipOrderByWithRelationInput | MembershipOrderByWithRelationInput[]
    cursor?: MembershipWhereUniqueInput
    take?: number
    skip?: number
    distinct?: MembershipScalarFieldEnum | MembershipScalarFieldEnum[]
  }

  /**
   * User.commands
   */
  export type User$commandsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Command
     */
    select?: CommandSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommandInclude<ExtArgs> | null
    where?: CommandWhereInput
    orderBy?: CommandOrderByWithRelationInput | CommandOrderByWithRelationInput[]
    cursor?: CommandWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CommandScalarFieldEnum | CommandScalarFieldEnum[]
  }

  /**
   * User.otaJobs
   */
  export type User$otaJobsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OtaJob
     */
    select?: OtaJobSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OtaJobInclude<ExtArgs> | null
    where?: OtaJobWhereInput
    orderBy?: OtaJobOrderByWithRelationInput | OtaJobOrderByWithRelationInput[]
    cursor?: OtaJobWhereUniqueInput
    take?: number
    skip?: number
    distinct?: OtaJobScalarFieldEnum | OtaJobScalarFieldEnum[]
  }

  /**
   * User.simActions
   */
  export type User$simActionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SimAction
     */
    select?: SimActionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SimActionInclude<ExtArgs> | null
    where?: SimActionWhereInput
    orderBy?: SimActionOrderByWithRelationInput | SimActionOrderByWithRelationInput[]
    cursor?: SimActionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SimActionScalarFieldEnum | SimActionScalarFieldEnum[]
  }

  /**
   * User.siteLocUpdates
   */
  export type User$siteLocUpdatesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Site
     */
    select?: SiteSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SiteInclude<ExtArgs> | null
    where?: SiteWhereInput
    orderBy?: SiteOrderByWithRelationInput | SiteOrderByWithRelationInput[]
    cursor?: SiteWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SiteScalarFieldEnum | SiteScalarFieldEnum[]
  }

  /**
   * User without action
   */
  export type UserDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
  }


  /**
   * Model Membership
   */

  export type AggregateMembership = {
    _count: MembershipCountAggregateOutputType | null
    _min: MembershipMinAggregateOutputType | null
    _max: MembershipMaxAggregateOutputType | null
  }

  export type MembershipMinAggregateOutputType = {
    id: string | null
    userId: string | null
    tenantId: string | null
    role: $Enums.MembershipRole | null
    createdAt: Date | null
  }

  export type MembershipMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    tenantId: string | null
    role: $Enums.MembershipRole | null
    createdAt: Date | null
  }

  export type MembershipCountAggregateOutputType = {
    id: number
    userId: number
    tenantId: number
    role: number
    createdAt: number
    _all: number
  }


  export type MembershipMinAggregateInputType = {
    id?: true
    userId?: true
    tenantId?: true
    role?: true
    createdAt?: true
  }

  export type MembershipMaxAggregateInputType = {
    id?: true
    userId?: true
    tenantId?: true
    role?: true
    createdAt?: true
  }

  export type MembershipCountAggregateInputType = {
    id?: true
    userId?: true
    tenantId?: true
    role?: true
    createdAt?: true
    _all?: true
  }

  export type MembershipAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Membership to aggregate.
     */
    where?: MembershipWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Memberships to fetch.
     */
    orderBy?: MembershipOrderByWithRelationInput | MembershipOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: MembershipWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Memberships from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Memberships.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Memberships
    **/
    _count?: true | MembershipCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: MembershipMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: MembershipMaxAggregateInputType
  }

  export type GetMembershipAggregateType<T extends MembershipAggregateArgs> = {
        [P in keyof T & keyof AggregateMembership]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMembership[P]>
      : GetScalarType<T[P], AggregateMembership[P]>
  }




  export type MembershipGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MembershipWhereInput
    orderBy?: MembershipOrderByWithAggregationInput | MembershipOrderByWithAggregationInput[]
    by: MembershipScalarFieldEnum[] | MembershipScalarFieldEnum
    having?: MembershipScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: MembershipCountAggregateInputType | true
    _min?: MembershipMinAggregateInputType
    _max?: MembershipMaxAggregateInputType
  }

  export type MembershipGroupByOutputType = {
    id: string
    userId: string
    tenantId: string
    role: $Enums.MembershipRole
    createdAt: Date
    _count: MembershipCountAggregateOutputType | null
    _min: MembershipMinAggregateOutputType | null
    _max: MembershipMaxAggregateOutputType | null
  }

  type GetMembershipGroupByPayload<T extends MembershipGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<MembershipGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof MembershipGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], MembershipGroupByOutputType[P]>
            : GetScalarType<T[P], MembershipGroupByOutputType[P]>
        }
      >
    >


  export type MembershipSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    tenantId?: boolean
    role?: boolean
    createdAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["membership"]>

  export type MembershipSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    tenantId?: boolean
    role?: boolean
    createdAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["membership"]>

  export type MembershipSelectScalar = {
    id?: boolean
    userId?: boolean
    tenantId?: boolean
    role?: boolean
    createdAt?: boolean
  }

  export type MembershipInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
  }
  export type MembershipIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
  }

  export type $MembershipPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Membership"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
      tenant: Prisma.$TenantPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      tenantId: string
      role: $Enums.MembershipRole
      createdAt: Date
    }, ExtArgs["result"]["membership"]>
    composites: {}
  }

  type MembershipGetPayload<S extends boolean | null | undefined | MembershipDefaultArgs> = $Result.GetResult<Prisma.$MembershipPayload, S>

  type MembershipCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<MembershipFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: MembershipCountAggregateInputType | true
    }

  export interface MembershipDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Membership'], meta: { name: 'Membership' } }
    /**
     * Find zero or one Membership that matches the filter.
     * @param {MembershipFindUniqueArgs} args - Arguments to find a Membership
     * @example
     * // Get one Membership
     * const membership = await prisma.membership.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends MembershipFindUniqueArgs>(args: SelectSubset<T, MembershipFindUniqueArgs<ExtArgs>>): Prisma__MembershipClient<$Result.GetResult<Prisma.$MembershipPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Membership that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {MembershipFindUniqueOrThrowArgs} args - Arguments to find a Membership
     * @example
     * // Get one Membership
     * const membership = await prisma.membership.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends MembershipFindUniqueOrThrowArgs>(args: SelectSubset<T, MembershipFindUniqueOrThrowArgs<ExtArgs>>): Prisma__MembershipClient<$Result.GetResult<Prisma.$MembershipPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Membership that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MembershipFindFirstArgs} args - Arguments to find a Membership
     * @example
     * // Get one Membership
     * const membership = await prisma.membership.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends MembershipFindFirstArgs>(args?: SelectSubset<T, MembershipFindFirstArgs<ExtArgs>>): Prisma__MembershipClient<$Result.GetResult<Prisma.$MembershipPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Membership that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MembershipFindFirstOrThrowArgs} args - Arguments to find a Membership
     * @example
     * // Get one Membership
     * const membership = await prisma.membership.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends MembershipFindFirstOrThrowArgs>(args?: SelectSubset<T, MembershipFindFirstOrThrowArgs<ExtArgs>>): Prisma__MembershipClient<$Result.GetResult<Prisma.$MembershipPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Memberships that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MembershipFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Memberships
     * const memberships = await prisma.membership.findMany()
     * 
     * // Get first 10 Memberships
     * const memberships = await prisma.membership.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const membershipWithIdOnly = await prisma.membership.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends MembershipFindManyArgs>(args?: SelectSubset<T, MembershipFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MembershipPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Membership.
     * @param {MembershipCreateArgs} args - Arguments to create a Membership.
     * @example
     * // Create one Membership
     * const Membership = await prisma.membership.create({
     *   data: {
     *     // ... data to create a Membership
     *   }
     * })
     * 
     */
    create<T extends MembershipCreateArgs>(args: SelectSubset<T, MembershipCreateArgs<ExtArgs>>): Prisma__MembershipClient<$Result.GetResult<Prisma.$MembershipPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Memberships.
     * @param {MembershipCreateManyArgs} args - Arguments to create many Memberships.
     * @example
     * // Create many Memberships
     * const membership = await prisma.membership.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends MembershipCreateManyArgs>(args?: SelectSubset<T, MembershipCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Memberships and returns the data saved in the database.
     * @param {MembershipCreateManyAndReturnArgs} args - Arguments to create many Memberships.
     * @example
     * // Create many Memberships
     * const membership = await prisma.membership.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Memberships and only return the `id`
     * const membershipWithIdOnly = await prisma.membership.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends MembershipCreateManyAndReturnArgs>(args?: SelectSubset<T, MembershipCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MembershipPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Membership.
     * @param {MembershipDeleteArgs} args - Arguments to delete one Membership.
     * @example
     * // Delete one Membership
     * const Membership = await prisma.membership.delete({
     *   where: {
     *     // ... filter to delete one Membership
     *   }
     * })
     * 
     */
    delete<T extends MembershipDeleteArgs>(args: SelectSubset<T, MembershipDeleteArgs<ExtArgs>>): Prisma__MembershipClient<$Result.GetResult<Prisma.$MembershipPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Membership.
     * @param {MembershipUpdateArgs} args - Arguments to update one Membership.
     * @example
     * // Update one Membership
     * const membership = await prisma.membership.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends MembershipUpdateArgs>(args: SelectSubset<T, MembershipUpdateArgs<ExtArgs>>): Prisma__MembershipClient<$Result.GetResult<Prisma.$MembershipPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Memberships.
     * @param {MembershipDeleteManyArgs} args - Arguments to filter Memberships to delete.
     * @example
     * // Delete a few Memberships
     * const { count } = await prisma.membership.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends MembershipDeleteManyArgs>(args?: SelectSubset<T, MembershipDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Memberships.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MembershipUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Memberships
     * const membership = await prisma.membership.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends MembershipUpdateManyArgs>(args: SelectSubset<T, MembershipUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Membership.
     * @param {MembershipUpsertArgs} args - Arguments to update or create a Membership.
     * @example
     * // Update or create a Membership
     * const membership = await prisma.membership.upsert({
     *   create: {
     *     // ... data to create a Membership
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Membership we want to update
     *   }
     * })
     */
    upsert<T extends MembershipUpsertArgs>(args: SelectSubset<T, MembershipUpsertArgs<ExtArgs>>): Prisma__MembershipClient<$Result.GetResult<Prisma.$MembershipPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Memberships.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MembershipCountArgs} args - Arguments to filter Memberships to count.
     * @example
     * // Count the number of Memberships
     * const count = await prisma.membership.count({
     *   where: {
     *     // ... the filter for the Memberships we want to count
     *   }
     * })
    **/
    count<T extends MembershipCountArgs>(
      args?: Subset<T, MembershipCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], MembershipCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Membership.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MembershipAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends MembershipAggregateArgs>(args: Subset<T, MembershipAggregateArgs>): Prisma.PrismaPromise<GetMembershipAggregateType<T>>

    /**
     * Group by Membership.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MembershipGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends MembershipGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: MembershipGroupByArgs['orderBy'] }
        : { orderBy?: MembershipGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, MembershipGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMembershipGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Membership model
   */
  readonly fields: MembershipFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Membership.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__MembershipClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    tenant<T extends TenantDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TenantDefaultArgs<ExtArgs>>): Prisma__TenantClient<$Result.GetResult<Prisma.$TenantPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Membership model
   */ 
  interface MembershipFieldRefs {
    readonly id: FieldRef<"Membership", 'String'>
    readonly userId: FieldRef<"Membership", 'String'>
    readonly tenantId: FieldRef<"Membership", 'String'>
    readonly role: FieldRef<"Membership", 'MembershipRole'>
    readonly createdAt: FieldRef<"Membership", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Membership findUnique
   */
  export type MembershipFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Membership
     */
    select?: MembershipSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MembershipInclude<ExtArgs> | null
    /**
     * Filter, which Membership to fetch.
     */
    where: MembershipWhereUniqueInput
  }

  /**
   * Membership findUniqueOrThrow
   */
  export type MembershipFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Membership
     */
    select?: MembershipSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MembershipInclude<ExtArgs> | null
    /**
     * Filter, which Membership to fetch.
     */
    where: MembershipWhereUniqueInput
  }

  /**
   * Membership findFirst
   */
  export type MembershipFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Membership
     */
    select?: MembershipSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MembershipInclude<ExtArgs> | null
    /**
     * Filter, which Membership to fetch.
     */
    where?: MembershipWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Memberships to fetch.
     */
    orderBy?: MembershipOrderByWithRelationInput | MembershipOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Memberships.
     */
    cursor?: MembershipWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Memberships from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Memberships.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Memberships.
     */
    distinct?: MembershipScalarFieldEnum | MembershipScalarFieldEnum[]
  }

  /**
   * Membership findFirstOrThrow
   */
  export type MembershipFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Membership
     */
    select?: MembershipSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MembershipInclude<ExtArgs> | null
    /**
     * Filter, which Membership to fetch.
     */
    where?: MembershipWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Memberships to fetch.
     */
    orderBy?: MembershipOrderByWithRelationInput | MembershipOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Memberships.
     */
    cursor?: MembershipWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Memberships from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Memberships.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Memberships.
     */
    distinct?: MembershipScalarFieldEnum | MembershipScalarFieldEnum[]
  }

  /**
   * Membership findMany
   */
  export type MembershipFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Membership
     */
    select?: MembershipSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MembershipInclude<ExtArgs> | null
    /**
     * Filter, which Memberships to fetch.
     */
    where?: MembershipWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Memberships to fetch.
     */
    orderBy?: MembershipOrderByWithRelationInput | MembershipOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Memberships.
     */
    cursor?: MembershipWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Memberships from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Memberships.
     */
    skip?: number
    distinct?: MembershipScalarFieldEnum | MembershipScalarFieldEnum[]
  }

  /**
   * Membership create
   */
  export type MembershipCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Membership
     */
    select?: MembershipSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MembershipInclude<ExtArgs> | null
    /**
     * The data needed to create a Membership.
     */
    data: XOR<MembershipCreateInput, MembershipUncheckedCreateInput>
  }

  /**
   * Membership createMany
   */
  export type MembershipCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Memberships.
     */
    data: MembershipCreateManyInput | MembershipCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Membership createManyAndReturn
   */
  export type MembershipCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Membership
     */
    select?: MembershipSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Memberships.
     */
    data: MembershipCreateManyInput | MembershipCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MembershipIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Membership update
   */
  export type MembershipUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Membership
     */
    select?: MembershipSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MembershipInclude<ExtArgs> | null
    /**
     * The data needed to update a Membership.
     */
    data: XOR<MembershipUpdateInput, MembershipUncheckedUpdateInput>
    /**
     * Choose, which Membership to update.
     */
    where: MembershipWhereUniqueInput
  }

  /**
   * Membership updateMany
   */
  export type MembershipUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Memberships.
     */
    data: XOR<MembershipUpdateManyMutationInput, MembershipUncheckedUpdateManyInput>
    /**
     * Filter which Memberships to update
     */
    where?: MembershipWhereInput
  }

  /**
   * Membership upsert
   */
  export type MembershipUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Membership
     */
    select?: MembershipSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MembershipInclude<ExtArgs> | null
    /**
     * The filter to search for the Membership to update in case it exists.
     */
    where: MembershipWhereUniqueInput
    /**
     * In case the Membership found by the `where` argument doesn't exist, create a new Membership with this data.
     */
    create: XOR<MembershipCreateInput, MembershipUncheckedCreateInput>
    /**
     * In case the Membership was found with the provided `where` argument, update it with this data.
     */
    update: XOR<MembershipUpdateInput, MembershipUncheckedUpdateInput>
  }

  /**
   * Membership delete
   */
  export type MembershipDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Membership
     */
    select?: MembershipSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MembershipInclude<ExtArgs> | null
    /**
     * Filter which Membership to delete.
     */
    where: MembershipWhereUniqueInput
  }

  /**
   * Membership deleteMany
   */
  export type MembershipDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Memberships to delete
     */
    where?: MembershipWhereInput
  }

  /**
   * Membership without action
   */
  export type MembershipDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Membership
     */
    select?: MembershipSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MembershipInclude<ExtArgs> | null
  }


  /**
   * Model Site
   */

  export type AggregateSite = {
    _count: SiteCountAggregateOutputType | null
    _avg: SiteAvgAggregateOutputType | null
    _sum: SiteSumAggregateOutputType | null
    _min: SiteMinAggregateOutputType | null
    _max: SiteMaxAggregateOutputType | null
  }

  export type SiteAvgAggregateOutputType = {
    lat: number | null
    lon: number | null
    locationAccuracyM: number | null
    locationConfidence: number | null
  }

  export type SiteSumAggregateOutputType = {
    lat: number | null
    lon: number | null
    locationAccuracyM: number | null
    locationConfidence: number | null
  }

  export type SiteMinAggregateOutputType = {
    id: string | null
    tenantId: string | null
    name: string | null
    addressLine1: string | null
    addressLine2: string | null
    city: string | null
    region: string | null
    postalCode: string | null
    country: string | null
    lat: number | null
    lon: number | null
    locationSource: $Enums.LocationSource | null
    locationAccuracyM: number | null
    locationConfidence: number | null
    locationUpdatedAt: Date | null
    locationUpdatedByUserId: string | null
    locationLock: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type SiteMaxAggregateOutputType = {
    id: string | null
    tenantId: string | null
    name: string | null
    addressLine1: string | null
    addressLine2: string | null
    city: string | null
    region: string | null
    postalCode: string | null
    country: string | null
    lat: number | null
    lon: number | null
    locationSource: $Enums.LocationSource | null
    locationAccuracyM: number | null
    locationConfidence: number | null
    locationUpdatedAt: Date | null
    locationUpdatedByUserId: string | null
    locationLock: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type SiteCountAggregateOutputType = {
    id: number
    tenantId: number
    name: number
    addressLine1: number
    addressLine2: number
    city: number
    region: number
    postalCode: number
    country: number
    lat: number
    lon: number
    locationSource: number
    locationAccuracyM: number
    locationConfidence: number
    locationUpdatedAt: number
    locationUpdatedByUserId: number
    locationLock: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type SiteAvgAggregateInputType = {
    lat?: true
    lon?: true
    locationAccuracyM?: true
    locationConfidence?: true
  }

  export type SiteSumAggregateInputType = {
    lat?: true
    lon?: true
    locationAccuracyM?: true
    locationConfidence?: true
  }

  export type SiteMinAggregateInputType = {
    id?: true
    tenantId?: true
    name?: true
    addressLine1?: true
    addressLine2?: true
    city?: true
    region?: true
    postalCode?: true
    country?: true
    lat?: true
    lon?: true
    locationSource?: true
    locationAccuracyM?: true
    locationConfidence?: true
    locationUpdatedAt?: true
    locationUpdatedByUserId?: true
    locationLock?: true
    createdAt?: true
    updatedAt?: true
  }

  export type SiteMaxAggregateInputType = {
    id?: true
    tenantId?: true
    name?: true
    addressLine1?: true
    addressLine2?: true
    city?: true
    region?: true
    postalCode?: true
    country?: true
    lat?: true
    lon?: true
    locationSource?: true
    locationAccuracyM?: true
    locationConfidence?: true
    locationUpdatedAt?: true
    locationUpdatedByUserId?: true
    locationLock?: true
    createdAt?: true
    updatedAt?: true
  }

  export type SiteCountAggregateInputType = {
    id?: true
    tenantId?: true
    name?: true
    addressLine1?: true
    addressLine2?: true
    city?: true
    region?: true
    postalCode?: true
    country?: true
    lat?: true
    lon?: true
    locationSource?: true
    locationAccuracyM?: true
    locationConfidence?: true
    locationUpdatedAt?: true
    locationUpdatedByUserId?: true
    locationLock?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type SiteAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Site to aggregate.
     */
    where?: SiteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Sites to fetch.
     */
    orderBy?: SiteOrderByWithRelationInput | SiteOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SiteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Sites from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Sites.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Sites
    **/
    _count?: true | SiteCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: SiteAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: SiteSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SiteMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SiteMaxAggregateInputType
  }

  export type GetSiteAggregateType<T extends SiteAggregateArgs> = {
        [P in keyof T & keyof AggregateSite]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSite[P]>
      : GetScalarType<T[P], AggregateSite[P]>
  }




  export type SiteGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SiteWhereInput
    orderBy?: SiteOrderByWithAggregationInput | SiteOrderByWithAggregationInput[]
    by: SiteScalarFieldEnum[] | SiteScalarFieldEnum
    having?: SiteScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SiteCountAggregateInputType | true
    _avg?: SiteAvgAggregateInputType
    _sum?: SiteSumAggregateInputType
    _min?: SiteMinAggregateInputType
    _max?: SiteMaxAggregateInputType
  }

  export type SiteGroupByOutputType = {
    id: string
    tenantId: string
    name: string
    addressLine1: string | null
    addressLine2: string | null
    city: string | null
    region: string | null
    postalCode: string | null
    country: string | null
    lat: number | null
    lon: number | null
    locationSource: $Enums.LocationSource | null
    locationAccuracyM: number | null
    locationConfidence: number | null
    locationUpdatedAt: Date | null
    locationUpdatedByUserId: string | null
    locationLock: boolean
    createdAt: Date
    updatedAt: Date
    _count: SiteCountAggregateOutputType | null
    _avg: SiteAvgAggregateOutputType | null
    _sum: SiteSumAggregateOutputType | null
    _min: SiteMinAggregateOutputType | null
    _max: SiteMaxAggregateOutputType | null
  }

  type GetSiteGroupByPayload<T extends SiteGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SiteGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SiteGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SiteGroupByOutputType[P]>
            : GetScalarType<T[P], SiteGroupByOutputType[P]>
        }
      >
    >


  export type SiteSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tenantId?: boolean
    name?: boolean
    addressLine1?: boolean
    addressLine2?: boolean
    city?: boolean
    region?: boolean
    postalCode?: boolean
    country?: boolean
    lat?: boolean
    lon?: boolean
    locationSource?: boolean
    locationAccuracyM?: boolean
    locationConfidence?: boolean
    locationUpdatedAt?: boolean
    locationUpdatedByUserId?: boolean
    locationLock?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
    locationUpdatedBy?: boolean | Site$locationUpdatedByArgs<ExtArgs>
    devices?: boolean | Site$devicesArgs<ExtArgs>
    weatherData?: boolean | Site$weatherDataArgs<ExtArgs>
    _count?: boolean | SiteCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["site"]>

  export type SiteSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tenantId?: boolean
    name?: boolean
    addressLine1?: boolean
    addressLine2?: boolean
    city?: boolean
    region?: boolean
    postalCode?: boolean
    country?: boolean
    lat?: boolean
    lon?: boolean
    locationSource?: boolean
    locationAccuracyM?: boolean
    locationConfidence?: boolean
    locationUpdatedAt?: boolean
    locationUpdatedByUserId?: boolean
    locationLock?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
    locationUpdatedBy?: boolean | Site$locationUpdatedByArgs<ExtArgs>
  }, ExtArgs["result"]["site"]>

  export type SiteSelectScalar = {
    id?: boolean
    tenantId?: boolean
    name?: boolean
    addressLine1?: boolean
    addressLine2?: boolean
    city?: boolean
    region?: boolean
    postalCode?: boolean
    country?: boolean
    lat?: boolean
    lon?: boolean
    locationSource?: boolean
    locationAccuracyM?: boolean
    locationConfidence?: boolean
    locationUpdatedAt?: boolean
    locationUpdatedByUserId?: boolean
    locationLock?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type SiteInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
    locationUpdatedBy?: boolean | Site$locationUpdatedByArgs<ExtArgs>
    devices?: boolean | Site$devicesArgs<ExtArgs>
    weatherData?: boolean | Site$weatherDataArgs<ExtArgs>
    _count?: boolean | SiteCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type SiteIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
    locationUpdatedBy?: boolean | Site$locationUpdatedByArgs<ExtArgs>
  }

  export type $SitePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Site"
    objects: {
      tenant: Prisma.$TenantPayload<ExtArgs>
      locationUpdatedBy: Prisma.$UserPayload<ExtArgs> | null
      devices: Prisma.$DevicePayload<ExtArgs>[]
      weatherData: Prisma.$WeatherDataPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      tenantId: string
      name: string
      addressLine1: string | null
      addressLine2: string | null
      city: string | null
      region: string | null
      postalCode: string | null
      country: string | null
      lat: number | null
      lon: number | null
      locationSource: $Enums.LocationSource | null
      locationAccuracyM: number | null
      locationConfidence: number | null
      locationUpdatedAt: Date | null
      locationUpdatedByUserId: string | null
      locationLock: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["site"]>
    composites: {}
  }

  type SiteGetPayload<S extends boolean | null | undefined | SiteDefaultArgs> = $Result.GetResult<Prisma.$SitePayload, S>

  type SiteCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<SiteFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: SiteCountAggregateInputType | true
    }

  export interface SiteDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Site'], meta: { name: 'Site' } }
    /**
     * Find zero or one Site that matches the filter.
     * @param {SiteFindUniqueArgs} args - Arguments to find a Site
     * @example
     * // Get one Site
     * const site = await prisma.site.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SiteFindUniqueArgs>(args: SelectSubset<T, SiteFindUniqueArgs<ExtArgs>>): Prisma__SiteClient<$Result.GetResult<Prisma.$SitePayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Site that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {SiteFindUniqueOrThrowArgs} args - Arguments to find a Site
     * @example
     * // Get one Site
     * const site = await prisma.site.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SiteFindUniqueOrThrowArgs>(args: SelectSubset<T, SiteFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SiteClient<$Result.GetResult<Prisma.$SitePayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Site that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SiteFindFirstArgs} args - Arguments to find a Site
     * @example
     * // Get one Site
     * const site = await prisma.site.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SiteFindFirstArgs>(args?: SelectSubset<T, SiteFindFirstArgs<ExtArgs>>): Prisma__SiteClient<$Result.GetResult<Prisma.$SitePayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Site that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SiteFindFirstOrThrowArgs} args - Arguments to find a Site
     * @example
     * // Get one Site
     * const site = await prisma.site.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SiteFindFirstOrThrowArgs>(args?: SelectSubset<T, SiteFindFirstOrThrowArgs<ExtArgs>>): Prisma__SiteClient<$Result.GetResult<Prisma.$SitePayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Sites that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SiteFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Sites
     * const sites = await prisma.site.findMany()
     * 
     * // Get first 10 Sites
     * const sites = await prisma.site.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const siteWithIdOnly = await prisma.site.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SiteFindManyArgs>(args?: SelectSubset<T, SiteFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SitePayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Site.
     * @param {SiteCreateArgs} args - Arguments to create a Site.
     * @example
     * // Create one Site
     * const Site = await prisma.site.create({
     *   data: {
     *     // ... data to create a Site
     *   }
     * })
     * 
     */
    create<T extends SiteCreateArgs>(args: SelectSubset<T, SiteCreateArgs<ExtArgs>>): Prisma__SiteClient<$Result.GetResult<Prisma.$SitePayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Sites.
     * @param {SiteCreateManyArgs} args - Arguments to create many Sites.
     * @example
     * // Create many Sites
     * const site = await prisma.site.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SiteCreateManyArgs>(args?: SelectSubset<T, SiteCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Sites and returns the data saved in the database.
     * @param {SiteCreateManyAndReturnArgs} args - Arguments to create many Sites.
     * @example
     * // Create many Sites
     * const site = await prisma.site.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Sites and only return the `id`
     * const siteWithIdOnly = await prisma.site.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends SiteCreateManyAndReturnArgs>(args?: SelectSubset<T, SiteCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SitePayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Site.
     * @param {SiteDeleteArgs} args - Arguments to delete one Site.
     * @example
     * // Delete one Site
     * const Site = await prisma.site.delete({
     *   where: {
     *     // ... filter to delete one Site
     *   }
     * })
     * 
     */
    delete<T extends SiteDeleteArgs>(args: SelectSubset<T, SiteDeleteArgs<ExtArgs>>): Prisma__SiteClient<$Result.GetResult<Prisma.$SitePayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Site.
     * @param {SiteUpdateArgs} args - Arguments to update one Site.
     * @example
     * // Update one Site
     * const site = await prisma.site.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SiteUpdateArgs>(args: SelectSubset<T, SiteUpdateArgs<ExtArgs>>): Prisma__SiteClient<$Result.GetResult<Prisma.$SitePayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Sites.
     * @param {SiteDeleteManyArgs} args - Arguments to filter Sites to delete.
     * @example
     * // Delete a few Sites
     * const { count } = await prisma.site.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SiteDeleteManyArgs>(args?: SelectSubset<T, SiteDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Sites.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SiteUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Sites
     * const site = await prisma.site.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SiteUpdateManyArgs>(args: SelectSubset<T, SiteUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Site.
     * @param {SiteUpsertArgs} args - Arguments to update or create a Site.
     * @example
     * // Update or create a Site
     * const site = await prisma.site.upsert({
     *   create: {
     *     // ... data to create a Site
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Site we want to update
     *   }
     * })
     */
    upsert<T extends SiteUpsertArgs>(args: SelectSubset<T, SiteUpsertArgs<ExtArgs>>): Prisma__SiteClient<$Result.GetResult<Prisma.$SitePayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Sites.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SiteCountArgs} args - Arguments to filter Sites to count.
     * @example
     * // Count the number of Sites
     * const count = await prisma.site.count({
     *   where: {
     *     // ... the filter for the Sites we want to count
     *   }
     * })
    **/
    count<T extends SiteCountArgs>(
      args?: Subset<T, SiteCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SiteCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Site.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SiteAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SiteAggregateArgs>(args: Subset<T, SiteAggregateArgs>): Prisma.PrismaPromise<GetSiteAggregateType<T>>

    /**
     * Group by Site.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SiteGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SiteGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SiteGroupByArgs['orderBy'] }
        : { orderBy?: SiteGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SiteGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSiteGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Site model
   */
  readonly fields: SiteFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Site.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SiteClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    tenant<T extends TenantDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TenantDefaultArgs<ExtArgs>>): Prisma__TenantClient<$Result.GetResult<Prisma.$TenantPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    locationUpdatedBy<T extends Site$locationUpdatedByArgs<ExtArgs> = {}>(args?: Subset<T, Site$locationUpdatedByArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    devices<T extends Site$devicesArgs<ExtArgs> = {}>(args?: Subset<T, Site$devicesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DevicePayload<ExtArgs>, T, "findMany"> | Null>
    weatherData<T extends Site$weatherDataArgs<ExtArgs> = {}>(args?: Subset<T, Site$weatherDataArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WeatherDataPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Site model
   */ 
  interface SiteFieldRefs {
    readonly id: FieldRef<"Site", 'String'>
    readonly tenantId: FieldRef<"Site", 'String'>
    readonly name: FieldRef<"Site", 'String'>
    readonly addressLine1: FieldRef<"Site", 'String'>
    readonly addressLine2: FieldRef<"Site", 'String'>
    readonly city: FieldRef<"Site", 'String'>
    readonly region: FieldRef<"Site", 'String'>
    readonly postalCode: FieldRef<"Site", 'String'>
    readonly country: FieldRef<"Site", 'String'>
    readonly lat: FieldRef<"Site", 'Float'>
    readonly lon: FieldRef<"Site", 'Float'>
    readonly locationSource: FieldRef<"Site", 'LocationSource'>
    readonly locationAccuracyM: FieldRef<"Site", 'Float'>
    readonly locationConfidence: FieldRef<"Site", 'Float'>
    readonly locationUpdatedAt: FieldRef<"Site", 'DateTime'>
    readonly locationUpdatedByUserId: FieldRef<"Site", 'String'>
    readonly locationLock: FieldRef<"Site", 'Boolean'>
    readonly createdAt: FieldRef<"Site", 'DateTime'>
    readonly updatedAt: FieldRef<"Site", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Site findUnique
   */
  export type SiteFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Site
     */
    select?: SiteSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SiteInclude<ExtArgs> | null
    /**
     * Filter, which Site to fetch.
     */
    where: SiteWhereUniqueInput
  }

  /**
   * Site findUniqueOrThrow
   */
  export type SiteFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Site
     */
    select?: SiteSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SiteInclude<ExtArgs> | null
    /**
     * Filter, which Site to fetch.
     */
    where: SiteWhereUniqueInput
  }

  /**
   * Site findFirst
   */
  export type SiteFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Site
     */
    select?: SiteSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SiteInclude<ExtArgs> | null
    /**
     * Filter, which Site to fetch.
     */
    where?: SiteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Sites to fetch.
     */
    orderBy?: SiteOrderByWithRelationInput | SiteOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Sites.
     */
    cursor?: SiteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Sites from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Sites.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Sites.
     */
    distinct?: SiteScalarFieldEnum | SiteScalarFieldEnum[]
  }

  /**
   * Site findFirstOrThrow
   */
  export type SiteFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Site
     */
    select?: SiteSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SiteInclude<ExtArgs> | null
    /**
     * Filter, which Site to fetch.
     */
    where?: SiteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Sites to fetch.
     */
    orderBy?: SiteOrderByWithRelationInput | SiteOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Sites.
     */
    cursor?: SiteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Sites from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Sites.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Sites.
     */
    distinct?: SiteScalarFieldEnum | SiteScalarFieldEnum[]
  }

  /**
   * Site findMany
   */
  export type SiteFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Site
     */
    select?: SiteSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SiteInclude<ExtArgs> | null
    /**
     * Filter, which Sites to fetch.
     */
    where?: SiteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Sites to fetch.
     */
    orderBy?: SiteOrderByWithRelationInput | SiteOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Sites.
     */
    cursor?: SiteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Sites from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Sites.
     */
    skip?: number
    distinct?: SiteScalarFieldEnum | SiteScalarFieldEnum[]
  }

  /**
   * Site create
   */
  export type SiteCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Site
     */
    select?: SiteSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SiteInclude<ExtArgs> | null
    /**
     * The data needed to create a Site.
     */
    data: XOR<SiteCreateInput, SiteUncheckedCreateInput>
  }

  /**
   * Site createMany
   */
  export type SiteCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Sites.
     */
    data: SiteCreateManyInput | SiteCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Site createManyAndReturn
   */
  export type SiteCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Site
     */
    select?: SiteSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Sites.
     */
    data: SiteCreateManyInput | SiteCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SiteIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Site update
   */
  export type SiteUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Site
     */
    select?: SiteSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SiteInclude<ExtArgs> | null
    /**
     * The data needed to update a Site.
     */
    data: XOR<SiteUpdateInput, SiteUncheckedUpdateInput>
    /**
     * Choose, which Site to update.
     */
    where: SiteWhereUniqueInput
  }

  /**
   * Site updateMany
   */
  export type SiteUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Sites.
     */
    data: XOR<SiteUpdateManyMutationInput, SiteUncheckedUpdateManyInput>
    /**
     * Filter which Sites to update
     */
    where?: SiteWhereInput
  }

  /**
   * Site upsert
   */
  export type SiteUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Site
     */
    select?: SiteSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SiteInclude<ExtArgs> | null
    /**
     * The filter to search for the Site to update in case it exists.
     */
    where: SiteWhereUniqueInput
    /**
     * In case the Site found by the `where` argument doesn't exist, create a new Site with this data.
     */
    create: XOR<SiteCreateInput, SiteUncheckedCreateInput>
    /**
     * In case the Site was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SiteUpdateInput, SiteUncheckedUpdateInput>
  }

  /**
   * Site delete
   */
  export type SiteDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Site
     */
    select?: SiteSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SiteInclude<ExtArgs> | null
    /**
     * Filter which Site to delete.
     */
    where: SiteWhereUniqueInput
  }

  /**
   * Site deleteMany
   */
  export type SiteDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Sites to delete
     */
    where?: SiteWhereInput
  }

  /**
   * Site.locationUpdatedBy
   */
  export type Site$locationUpdatedByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * Site.devices
   */
  export type Site$devicesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Device
     */
    select?: DeviceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeviceInclude<ExtArgs> | null
    where?: DeviceWhereInput
    orderBy?: DeviceOrderByWithRelationInput | DeviceOrderByWithRelationInput[]
    cursor?: DeviceWhereUniqueInput
    take?: number
    skip?: number
    distinct?: DeviceScalarFieldEnum | DeviceScalarFieldEnum[]
  }

  /**
   * Site.weatherData
   */
  export type Site$weatherDataArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WeatherData
     */
    select?: WeatherDataSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WeatherDataInclude<ExtArgs> | null
    where?: WeatherDataWhereInput
    orderBy?: WeatherDataOrderByWithRelationInput | WeatherDataOrderByWithRelationInput[]
    cursor?: WeatherDataWhereUniqueInput
    take?: number
    skip?: number
    distinct?: WeatherDataScalarFieldEnum | WeatherDataScalarFieldEnum[]
  }

  /**
   * Site without action
   */
  export type SiteDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Site
     */
    select?: SiteSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SiteInclude<ExtArgs> | null
  }


  /**
   * Model Device
   */

  export type AggregateDevice = {
    _count: DeviceCountAggregateOutputType | null
    _avg: DeviceAvgAggregateOutputType | null
    _sum: DeviceSumAggregateOutputType | null
    _min: DeviceMinAggregateOutputType | null
    _max: DeviceMaxAggregateOutputType | null
  }

  export type DeviceAvgAggregateOutputType = {
    deviceLat: number | null
    deviceLon: number | null
    deviceLocationAccuracyM: number | null
  }

  export type DeviceSumAggregateOutputType = {
    deviceLat: number | null
    deviceLon: number | null
    deviceLocationAccuracyM: number | null
  }

  export type DeviceMinAggregateOutputType = {
    id: string | null
    tenantId: string | null
    siteId: string | null
    ownerUserId: string | null
    model: string | null
    serialNumber: string | null
    name: string | null
    notes: string | null
    status: $Enums.DeviceStatus | null
    lastSeenAt: Date | null
    firmwareVersion: string | null
    simIccid: string | null
    deviceLat: number | null
    deviceLon: number | null
    deviceLocationTs: Date | null
    deviceLocationSource: $Enums.DeviceLocationSource | null
    deviceLocationAccuracyM: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type DeviceMaxAggregateOutputType = {
    id: string | null
    tenantId: string | null
    siteId: string | null
    ownerUserId: string | null
    model: string | null
    serialNumber: string | null
    name: string | null
    notes: string | null
    status: $Enums.DeviceStatus | null
    lastSeenAt: Date | null
    firmwareVersion: string | null
    simIccid: string | null
    deviceLat: number | null
    deviceLon: number | null
    deviceLocationTs: Date | null
    deviceLocationSource: $Enums.DeviceLocationSource | null
    deviceLocationAccuracyM: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type DeviceCountAggregateOutputType = {
    id: number
    tenantId: number
    siteId: number
    ownerUserId: number
    model: number
    serialNumber: number
    name: number
    notes: number
    tags: number
    status: number
    lastSeenAt: number
    firmwareVersion: number
    simIccid: number
    deviceLat: number
    deviceLon: number
    deviceLocationTs: number
    deviceLocationSource: number
    deviceLocationAccuracyM: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type DeviceAvgAggregateInputType = {
    deviceLat?: true
    deviceLon?: true
    deviceLocationAccuracyM?: true
  }

  export type DeviceSumAggregateInputType = {
    deviceLat?: true
    deviceLon?: true
    deviceLocationAccuracyM?: true
  }

  export type DeviceMinAggregateInputType = {
    id?: true
    tenantId?: true
    siteId?: true
    ownerUserId?: true
    model?: true
    serialNumber?: true
    name?: true
    notes?: true
    status?: true
    lastSeenAt?: true
    firmwareVersion?: true
    simIccid?: true
    deviceLat?: true
    deviceLon?: true
    deviceLocationTs?: true
    deviceLocationSource?: true
    deviceLocationAccuracyM?: true
    createdAt?: true
    updatedAt?: true
  }

  export type DeviceMaxAggregateInputType = {
    id?: true
    tenantId?: true
    siteId?: true
    ownerUserId?: true
    model?: true
    serialNumber?: true
    name?: true
    notes?: true
    status?: true
    lastSeenAt?: true
    firmwareVersion?: true
    simIccid?: true
    deviceLat?: true
    deviceLon?: true
    deviceLocationTs?: true
    deviceLocationSource?: true
    deviceLocationAccuracyM?: true
    createdAt?: true
    updatedAt?: true
  }

  export type DeviceCountAggregateInputType = {
    id?: true
    tenantId?: true
    siteId?: true
    ownerUserId?: true
    model?: true
    serialNumber?: true
    name?: true
    notes?: true
    tags?: true
    status?: true
    lastSeenAt?: true
    firmwareVersion?: true
    simIccid?: true
    deviceLat?: true
    deviceLon?: true
    deviceLocationTs?: true
    deviceLocationSource?: true
    deviceLocationAccuracyM?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type DeviceAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Device to aggregate.
     */
    where?: DeviceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Devices to fetch.
     */
    orderBy?: DeviceOrderByWithRelationInput | DeviceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: DeviceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Devices from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Devices.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Devices
    **/
    _count?: true | DeviceCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: DeviceAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: DeviceSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: DeviceMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: DeviceMaxAggregateInputType
  }

  export type GetDeviceAggregateType<T extends DeviceAggregateArgs> = {
        [P in keyof T & keyof AggregateDevice]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateDevice[P]>
      : GetScalarType<T[P], AggregateDevice[P]>
  }




  export type DeviceGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DeviceWhereInput
    orderBy?: DeviceOrderByWithAggregationInput | DeviceOrderByWithAggregationInput[]
    by: DeviceScalarFieldEnum[] | DeviceScalarFieldEnum
    having?: DeviceScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: DeviceCountAggregateInputType | true
    _avg?: DeviceAvgAggregateInputType
    _sum?: DeviceSumAggregateInputType
    _min?: DeviceMinAggregateInputType
    _max?: DeviceMaxAggregateInputType
  }

  export type DeviceGroupByOutputType = {
    id: string
    tenantId: string
    siteId: string | null
    ownerUserId: string | null
    model: string
    serialNumber: string
    name: string | null
    notes: string | null
    tags: JsonValue | null
    status: $Enums.DeviceStatus
    lastSeenAt: Date | null
    firmwareVersion: string | null
    simIccid: string | null
    deviceLat: number | null
    deviceLon: number | null
    deviceLocationTs: Date | null
    deviceLocationSource: $Enums.DeviceLocationSource | null
    deviceLocationAccuracyM: number | null
    createdAt: Date
    updatedAt: Date
    _count: DeviceCountAggregateOutputType | null
    _avg: DeviceAvgAggregateOutputType | null
    _sum: DeviceSumAggregateOutputType | null
    _min: DeviceMinAggregateOutputType | null
    _max: DeviceMaxAggregateOutputType | null
  }

  type GetDeviceGroupByPayload<T extends DeviceGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<DeviceGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof DeviceGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], DeviceGroupByOutputType[P]>
            : GetScalarType<T[P], DeviceGroupByOutputType[P]>
        }
      >
    >


  export type DeviceSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tenantId?: boolean
    siteId?: boolean
    ownerUserId?: boolean
    model?: boolean
    serialNumber?: boolean
    name?: boolean
    notes?: boolean
    tags?: boolean
    status?: boolean
    lastSeenAt?: boolean
    firmwareVersion?: boolean
    simIccid?: boolean
    deviceLat?: boolean
    deviceLon?: boolean
    deviceLocationTs?: boolean
    deviceLocationSource?: boolean
    deviceLocationAccuracyM?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
    site?: boolean | Device$siteArgs<ExtArgs>
    sim?: boolean | Device$simArgs<ExtArgs>
    secret?: boolean | Device$secretArgs<ExtArgs>
    twin?: boolean | Device$twinArgs<ExtArgs>
    telemetry?: boolean | Device$telemetryArgs<ExtArgs>
    commands?: boolean | Device$commandsArgs<ExtArgs>
    alertEvents?: boolean | Device$alertEventsArgs<ExtArgs>
    dailyRollups?: boolean | Device$dailyRollupsArgs<ExtArgs>
    entitlements?: boolean | Device$entitlementsArgs<ExtArgs>
    _count?: boolean | DeviceCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["device"]>

  export type DeviceSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tenantId?: boolean
    siteId?: boolean
    ownerUserId?: boolean
    model?: boolean
    serialNumber?: boolean
    name?: boolean
    notes?: boolean
    tags?: boolean
    status?: boolean
    lastSeenAt?: boolean
    firmwareVersion?: boolean
    simIccid?: boolean
    deviceLat?: boolean
    deviceLon?: boolean
    deviceLocationTs?: boolean
    deviceLocationSource?: boolean
    deviceLocationAccuracyM?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
    site?: boolean | Device$siteArgs<ExtArgs>
    sim?: boolean | Device$simArgs<ExtArgs>
  }, ExtArgs["result"]["device"]>

  export type DeviceSelectScalar = {
    id?: boolean
    tenantId?: boolean
    siteId?: boolean
    ownerUserId?: boolean
    model?: boolean
    serialNumber?: boolean
    name?: boolean
    notes?: boolean
    tags?: boolean
    status?: boolean
    lastSeenAt?: boolean
    firmwareVersion?: boolean
    simIccid?: boolean
    deviceLat?: boolean
    deviceLon?: boolean
    deviceLocationTs?: boolean
    deviceLocationSource?: boolean
    deviceLocationAccuracyM?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type DeviceInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
    site?: boolean | Device$siteArgs<ExtArgs>
    sim?: boolean | Device$simArgs<ExtArgs>
    secret?: boolean | Device$secretArgs<ExtArgs>
    twin?: boolean | Device$twinArgs<ExtArgs>
    telemetry?: boolean | Device$telemetryArgs<ExtArgs>
    commands?: boolean | Device$commandsArgs<ExtArgs>
    alertEvents?: boolean | Device$alertEventsArgs<ExtArgs>
    dailyRollups?: boolean | Device$dailyRollupsArgs<ExtArgs>
    entitlements?: boolean | Device$entitlementsArgs<ExtArgs>
    _count?: boolean | DeviceCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type DeviceIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
    site?: boolean | Device$siteArgs<ExtArgs>
    sim?: boolean | Device$simArgs<ExtArgs>
  }

  export type $DevicePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Device"
    objects: {
      tenant: Prisma.$TenantPayload<ExtArgs>
      site: Prisma.$SitePayload<ExtArgs> | null
      sim: Prisma.$SimInfoPayload<ExtArgs> | null
      secret: Prisma.$DeviceSecretPayload<ExtArgs> | null
      twin: Prisma.$DeviceTwinPayload<ExtArgs> | null
      telemetry: Prisma.$TelemetryPayload<ExtArgs>[]
      commands: Prisma.$CommandPayload<ExtArgs>[]
      alertEvents: Prisma.$AlertEventPayload<ExtArgs>[]
      dailyRollups: Prisma.$DailyRollupPayload<ExtArgs>[]
      entitlements: Prisma.$EntitlementPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      tenantId: string
      siteId: string | null
      ownerUserId: string | null
      model: string
      serialNumber: string
      name: string | null
      notes: string | null
      tags: Prisma.JsonValue | null
      status: $Enums.DeviceStatus
      lastSeenAt: Date | null
      firmwareVersion: string | null
      simIccid: string | null
      deviceLat: number | null
      deviceLon: number | null
      deviceLocationTs: Date | null
      deviceLocationSource: $Enums.DeviceLocationSource | null
      deviceLocationAccuracyM: number | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["device"]>
    composites: {}
  }

  type DeviceGetPayload<S extends boolean | null | undefined | DeviceDefaultArgs> = $Result.GetResult<Prisma.$DevicePayload, S>

  type DeviceCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<DeviceFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: DeviceCountAggregateInputType | true
    }

  export interface DeviceDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Device'], meta: { name: 'Device' } }
    /**
     * Find zero or one Device that matches the filter.
     * @param {DeviceFindUniqueArgs} args - Arguments to find a Device
     * @example
     * // Get one Device
     * const device = await prisma.device.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends DeviceFindUniqueArgs>(args: SelectSubset<T, DeviceFindUniqueArgs<ExtArgs>>): Prisma__DeviceClient<$Result.GetResult<Prisma.$DevicePayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Device that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {DeviceFindUniqueOrThrowArgs} args - Arguments to find a Device
     * @example
     * // Get one Device
     * const device = await prisma.device.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends DeviceFindUniqueOrThrowArgs>(args: SelectSubset<T, DeviceFindUniqueOrThrowArgs<ExtArgs>>): Prisma__DeviceClient<$Result.GetResult<Prisma.$DevicePayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Device that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DeviceFindFirstArgs} args - Arguments to find a Device
     * @example
     * // Get one Device
     * const device = await prisma.device.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends DeviceFindFirstArgs>(args?: SelectSubset<T, DeviceFindFirstArgs<ExtArgs>>): Prisma__DeviceClient<$Result.GetResult<Prisma.$DevicePayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Device that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DeviceFindFirstOrThrowArgs} args - Arguments to find a Device
     * @example
     * // Get one Device
     * const device = await prisma.device.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends DeviceFindFirstOrThrowArgs>(args?: SelectSubset<T, DeviceFindFirstOrThrowArgs<ExtArgs>>): Prisma__DeviceClient<$Result.GetResult<Prisma.$DevicePayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Devices that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DeviceFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Devices
     * const devices = await prisma.device.findMany()
     * 
     * // Get first 10 Devices
     * const devices = await prisma.device.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const deviceWithIdOnly = await prisma.device.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends DeviceFindManyArgs>(args?: SelectSubset<T, DeviceFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DevicePayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Device.
     * @param {DeviceCreateArgs} args - Arguments to create a Device.
     * @example
     * // Create one Device
     * const Device = await prisma.device.create({
     *   data: {
     *     // ... data to create a Device
     *   }
     * })
     * 
     */
    create<T extends DeviceCreateArgs>(args: SelectSubset<T, DeviceCreateArgs<ExtArgs>>): Prisma__DeviceClient<$Result.GetResult<Prisma.$DevicePayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Devices.
     * @param {DeviceCreateManyArgs} args - Arguments to create many Devices.
     * @example
     * // Create many Devices
     * const device = await prisma.device.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends DeviceCreateManyArgs>(args?: SelectSubset<T, DeviceCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Devices and returns the data saved in the database.
     * @param {DeviceCreateManyAndReturnArgs} args - Arguments to create many Devices.
     * @example
     * // Create many Devices
     * const device = await prisma.device.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Devices and only return the `id`
     * const deviceWithIdOnly = await prisma.device.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends DeviceCreateManyAndReturnArgs>(args?: SelectSubset<T, DeviceCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DevicePayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Device.
     * @param {DeviceDeleteArgs} args - Arguments to delete one Device.
     * @example
     * // Delete one Device
     * const Device = await prisma.device.delete({
     *   where: {
     *     // ... filter to delete one Device
     *   }
     * })
     * 
     */
    delete<T extends DeviceDeleteArgs>(args: SelectSubset<T, DeviceDeleteArgs<ExtArgs>>): Prisma__DeviceClient<$Result.GetResult<Prisma.$DevicePayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Device.
     * @param {DeviceUpdateArgs} args - Arguments to update one Device.
     * @example
     * // Update one Device
     * const device = await prisma.device.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends DeviceUpdateArgs>(args: SelectSubset<T, DeviceUpdateArgs<ExtArgs>>): Prisma__DeviceClient<$Result.GetResult<Prisma.$DevicePayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Devices.
     * @param {DeviceDeleteManyArgs} args - Arguments to filter Devices to delete.
     * @example
     * // Delete a few Devices
     * const { count } = await prisma.device.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends DeviceDeleteManyArgs>(args?: SelectSubset<T, DeviceDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Devices.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DeviceUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Devices
     * const device = await prisma.device.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends DeviceUpdateManyArgs>(args: SelectSubset<T, DeviceUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Device.
     * @param {DeviceUpsertArgs} args - Arguments to update or create a Device.
     * @example
     * // Update or create a Device
     * const device = await prisma.device.upsert({
     *   create: {
     *     // ... data to create a Device
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Device we want to update
     *   }
     * })
     */
    upsert<T extends DeviceUpsertArgs>(args: SelectSubset<T, DeviceUpsertArgs<ExtArgs>>): Prisma__DeviceClient<$Result.GetResult<Prisma.$DevicePayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Devices.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DeviceCountArgs} args - Arguments to filter Devices to count.
     * @example
     * // Count the number of Devices
     * const count = await prisma.device.count({
     *   where: {
     *     // ... the filter for the Devices we want to count
     *   }
     * })
    **/
    count<T extends DeviceCountArgs>(
      args?: Subset<T, DeviceCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], DeviceCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Device.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DeviceAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends DeviceAggregateArgs>(args: Subset<T, DeviceAggregateArgs>): Prisma.PrismaPromise<GetDeviceAggregateType<T>>

    /**
     * Group by Device.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DeviceGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends DeviceGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: DeviceGroupByArgs['orderBy'] }
        : { orderBy?: DeviceGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, DeviceGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetDeviceGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Device model
   */
  readonly fields: DeviceFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Device.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__DeviceClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    tenant<T extends TenantDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TenantDefaultArgs<ExtArgs>>): Prisma__TenantClient<$Result.GetResult<Prisma.$TenantPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    site<T extends Device$siteArgs<ExtArgs> = {}>(args?: Subset<T, Device$siteArgs<ExtArgs>>): Prisma__SiteClient<$Result.GetResult<Prisma.$SitePayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    sim<T extends Device$simArgs<ExtArgs> = {}>(args?: Subset<T, Device$simArgs<ExtArgs>>): Prisma__SimInfoClient<$Result.GetResult<Prisma.$SimInfoPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    secret<T extends Device$secretArgs<ExtArgs> = {}>(args?: Subset<T, Device$secretArgs<ExtArgs>>): Prisma__DeviceSecretClient<$Result.GetResult<Prisma.$DeviceSecretPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    twin<T extends Device$twinArgs<ExtArgs> = {}>(args?: Subset<T, Device$twinArgs<ExtArgs>>): Prisma__DeviceTwinClient<$Result.GetResult<Prisma.$DeviceTwinPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    telemetry<T extends Device$telemetryArgs<ExtArgs> = {}>(args?: Subset<T, Device$telemetryArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TelemetryPayload<ExtArgs>, T, "findMany"> | Null>
    commands<T extends Device$commandsArgs<ExtArgs> = {}>(args?: Subset<T, Device$commandsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CommandPayload<ExtArgs>, T, "findMany"> | Null>
    alertEvents<T extends Device$alertEventsArgs<ExtArgs> = {}>(args?: Subset<T, Device$alertEventsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AlertEventPayload<ExtArgs>, T, "findMany"> | Null>
    dailyRollups<T extends Device$dailyRollupsArgs<ExtArgs> = {}>(args?: Subset<T, Device$dailyRollupsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DailyRollupPayload<ExtArgs>, T, "findMany"> | Null>
    entitlements<T extends Device$entitlementsArgs<ExtArgs> = {}>(args?: Subset<T, Device$entitlementsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EntitlementPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Device model
   */ 
  interface DeviceFieldRefs {
    readonly id: FieldRef<"Device", 'String'>
    readonly tenantId: FieldRef<"Device", 'String'>
    readonly siteId: FieldRef<"Device", 'String'>
    readonly ownerUserId: FieldRef<"Device", 'String'>
    readonly model: FieldRef<"Device", 'String'>
    readonly serialNumber: FieldRef<"Device", 'String'>
    readonly name: FieldRef<"Device", 'String'>
    readonly notes: FieldRef<"Device", 'String'>
    readonly tags: FieldRef<"Device", 'Json'>
    readonly status: FieldRef<"Device", 'DeviceStatus'>
    readonly lastSeenAt: FieldRef<"Device", 'DateTime'>
    readonly firmwareVersion: FieldRef<"Device", 'String'>
    readonly simIccid: FieldRef<"Device", 'String'>
    readonly deviceLat: FieldRef<"Device", 'Float'>
    readonly deviceLon: FieldRef<"Device", 'Float'>
    readonly deviceLocationTs: FieldRef<"Device", 'DateTime'>
    readonly deviceLocationSource: FieldRef<"Device", 'DeviceLocationSource'>
    readonly deviceLocationAccuracyM: FieldRef<"Device", 'Float'>
    readonly createdAt: FieldRef<"Device", 'DateTime'>
    readonly updatedAt: FieldRef<"Device", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Device findUnique
   */
  export type DeviceFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Device
     */
    select?: DeviceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeviceInclude<ExtArgs> | null
    /**
     * Filter, which Device to fetch.
     */
    where: DeviceWhereUniqueInput
  }

  /**
   * Device findUniqueOrThrow
   */
  export type DeviceFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Device
     */
    select?: DeviceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeviceInclude<ExtArgs> | null
    /**
     * Filter, which Device to fetch.
     */
    where: DeviceWhereUniqueInput
  }

  /**
   * Device findFirst
   */
  export type DeviceFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Device
     */
    select?: DeviceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeviceInclude<ExtArgs> | null
    /**
     * Filter, which Device to fetch.
     */
    where?: DeviceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Devices to fetch.
     */
    orderBy?: DeviceOrderByWithRelationInput | DeviceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Devices.
     */
    cursor?: DeviceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Devices from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Devices.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Devices.
     */
    distinct?: DeviceScalarFieldEnum | DeviceScalarFieldEnum[]
  }

  /**
   * Device findFirstOrThrow
   */
  export type DeviceFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Device
     */
    select?: DeviceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeviceInclude<ExtArgs> | null
    /**
     * Filter, which Device to fetch.
     */
    where?: DeviceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Devices to fetch.
     */
    orderBy?: DeviceOrderByWithRelationInput | DeviceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Devices.
     */
    cursor?: DeviceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Devices from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Devices.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Devices.
     */
    distinct?: DeviceScalarFieldEnum | DeviceScalarFieldEnum[]
  }

  /**
   * Device findMany
   */
  export type DeviceFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Device
     */
    select?: DeviceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeviceInclude<ExtArgs> | null
    /**
     * Filter, which Devices to fetch.
     */
    where?: DeviceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Devices to fetch.
     */
    orderBy?: DeviceOrderByWithRelationInput | DeviceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Devices.
     */
    cursor?: DeviceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Devices from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Devices.
     */
    skip?: number
    distinct?: DeviceScalarFieldEnum | DeviceScalarFieldEnum[]
  }

  /**
   * Device create
   */
  export type DeviceCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Device
     */
    select?: DeviceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeviceInclude<ExtArgs> | null
    /**
     * The data needed to create a Device.
     */
    data: XOR<DeviceCreateInput, DeviceUncheckedCreateInput>
  }

  /**
   * Device createMany
   */
  export type DeviceCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Devices.
     */
    data: DeviceCreateManyInput | DeviceCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Device createManyAndReturn
   */
  export type DeviceCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Device
     */
    select?: DeviceSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Devices.
     */
    data: DeviceCreateManyInput | DeviceCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeviceIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Device update
   */
  export type DeviceUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Device
     */
    select?: DeviceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeviceInclude<ExtArgs> | null
    /**
     * The data needed to update a Device.
     */
    data: XOR<DeviceUpdateInput, DeviceUncheckedUpdateInput>
    /**
     * Choose, which Device to update.
     */
    where: DeviceWhereUniqueInput
  }

  /**
   * Device updateMany
   */
  export type DeviceUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Devices.
     */
    data: XOR<DeviceUpdateManyMutationInput, DeviceUncheckedUpdateManyInput>
    /**
     * Filter which Devices to update
     */
    where?: DeviceWhereInput
  }

  /**
   * Device upsert
   */
  export type DeviceUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Device
     */
    select?: DeviceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeviceInclude<ExtArgs> | null
    /**
     * The filter to search for the Device to update in case it exists.
     */
    where: DeviceWhereUniqueInput
    /**
     * In case the Device found by the `where` argument doesn't exist, create a new Device with this data.
     */
    create: XOR<DeviceCreateInput, DeviceUncheckedCreateInput>
    /**
     * In case the Device was found with the provided `where` argument, update it with this data.
     */
    update: XOR<DeviceUpdateInput, DeviceUncheckedUpdateInput>
  }

  /**
   * Device delete
   */
  export type DeviceDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Device
     */
    select?: DeviceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeviceInclude<ExtArgs> | null
    /**
     * Filter which Device to delete.
     */
    where: DeviceWhereUniqueInput
  }

  /**
   * Device deleteMany
   */
  export type DeviceDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Devices to delete
     */
    where?: DeviceWhereInput
  }

  /**
   * Device.site
   */
  export type Device$siteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Site
     */
    select?: SiteSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SiteInclude<ExtArgs> | null
    where?: SiteWhereInput
  }

  /**
   * Device.sim
   */
  export type Device$simArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SimInfo
     */
    select?: SimInfoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SimInfoInclude<ExtArgs> | null
    where?: SimInfoWhereInput
  }

  /**
   * Device.secret
   */
  export type Device$secretArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeviceSecret
     */
    select?: DeviceSecretSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeviceSecretInclude<ExtArgs> | null
    where?: DeviceSecretWhereInput
  }

  /**
   * Device.twin
   */
  export type Device$twinArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeviceTwin
     */
    select?: DeviceTwinSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeviceTwinInclude<ExtArgs> | null
    where?: DeviceTwinWhereInput
  }

  /**
   * Device.telemetry
   */
  export type Device$telemetryArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Telemetry
     */
    select?: TelemetrySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TelemetryInclude<ExtArgs> | null
    where?: TelemetryWhereInput
    orderBy?: TelemetryOrderByWithRelationInput | TelemetryOrderByWithRelationInput[]
    cursor?: TelemetryWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TelemetryScalarFieldEnum | TelemetryScalarFieldEnum[]
  }

  /**
   * Device.commands
   */
  export type Device$commandsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Command
     */
    select?: CommandSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommandInclude<ExtArgs> | null
    where?: CommandWhereInput
    orderBy?: CommandOrderByWithRelationInput | CommandOrderByWithRelationInput[]
    cursor?: CommandWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CommandScalarFieldEnum | CommandScalarFieldEnum[]
  }

  /**
   * Device.alertEvents
   */
  export type Device$alertEventsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AlertEvent
     */
    select?: AlertEventSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AlertEventInclude<ExtArgs> | null
    where?: AlertEventWhereInput
    orderBy?: AlertEventOrderByWithRelationInput | AlertEventOrderByWithRelationInput[]
    cursor?: AlertEventWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AlertEventScalarFieldEnum | AlertEventScalarFieldEnum[]
  }

  /**
   * Device.dailyRollups
   */
  export type Device$dailyRollupsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DailyRollup
     */
    select?: DailyRollupSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DailyRollupInclude<ExtArgs> | null
    where?: DailyRollupWhereInput
    orderBy?: DailyRollupOrderByWithRelationInput | DailyRollupOrderByWithRelationInput[]
    cursor?: DailyRollupWhereUniqueInput
    take?: number
    skip?: number
    distinct?: DailyRollupScalarFieldEnum | DailyRollupScalarFieldEnum[]
  }

  /**
   * Device.entitlements
   */
  export type Device$entitlementsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Entitlement
     */
    select?: EntitlementSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EntitlementInclude<ExtArgs> | null
    where?: EntitlementWhereInput
    orderBy?: EntitlementOrderByWithRelationInput | EntitlementOrderByWithRelationInput[]
    cursor?: EntitlementWhereUniqueInput
    take?: number
    skip?: number
    distinct?: EntitlementScalarFieldEnum | EntitlementScalarFieldEnum[]
  }

  /**
   * Device without action
   */
  export type DeviceDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Device
     */
    select?: DeviceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeviceInclude<ExtArgs> | null
  }


  /**
   * Model DeviceSecret
   */

  export type AggregateDeviceSecret = {
    _count: DeviceSecretCountAggregateOutputType | null
    _min: DeviceSecretMinAggregateOutputType | null
    _max: DeviceSecretMaxAggregateOutputType | null
  }

  export type DeviceSecretMinAggregateOutputType = {
    id: string | null
    deviceId: string | null
    secretHash: string | null
    publicKey: string | null
    rotatedAt: Date | null
  }

  export type DeviceSecretMaxAggregateOutputType = {
    id: string | null
    deviceId: string | null
    secretHash: string | null
    publicKey: string | null
    rotatedAt: Date | null
  }

  export type DeviceSecretCountAggregateOutputType = {
    id: number
    deviceId: number
    secretHash: number
    publicKey: number
    rotatedAt: number
    _all: number
  }


  export type DeviceSecretMinAggregateInputType = {
    id?: true
    deviceId?: true
    secretHash?: true
    publicKey?: true
    rotatedAt?: true
  }

  export type DeviceSecretMaxAggregateInputType = {
    id?: true
    deviceId?: true
    secretHash?: true
    publicKey?: true
    rotatedAt?: true
  }

  export type DeviceSecretCountAggregateInputType = {
    id?: true
    deviceId?: true
    secretHash?: true
    publicKey?: true
    rotatedAt?: true
    _all?: true
  }

  export type DeviceSecretAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which DeviceSecret to aggregate.
     */
    where?: DeviceSecretWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DeviceSecrets to fetch.
     */
    orderBy?: DeviceSecretOrderByWithRelationInput | DeviceSecretOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: DeviceSecretWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DeviceSecrets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DeviceSecrets.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned DeviceSecrets
    **/
    _count?: true | DeviceSecretCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: DeviceSecretMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: DeviceSecretMaxAggregateInputType
  }

  export type GetDeviceSecretAggregateType<T extends DeviceSecretAggregateArgs> = {
        [P in keyof T & keyof AggregateDeviceSecret]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateDeviceSecret[P]>
      : GetScalarType<T[P], AggregateDeviceSecret[P]>
  }




  export type DeviceSecretGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DeviceSecretWhereInput
    orderBy?: DeviceSecretOrderByWithAggregationInput | DeviceSecretOrderByWithAggregationInput[]
    by: DeviceSecretScalarFieldEnum[] | DeviceSecretScalarFieldEnum
    having?: DeviceSecretScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: DeviceSecretCountAggregateInputType | true
    _min?: DeviceSecretMinAggregateInputType
    _max?: DeviceSecretMaxAggregateInputType
  }

  export type DeviceSecretGroupByOutputType = {
    id: string
    deviceId: string
    secretHash: string
    publicKey: string | null
    rotatedAt: Date
    _count: DeviceSecretCountAggregateOutputType | null
    _min: DeviceSecretMinAggregateOutputType | null
    _max: DeviceSecretMaxAggregateOutputType | null
  }

  type GetDeviceSecretGroupByPayload<T extends DeviceSecretGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<DeviceSecretGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof DeviceSecretGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], DeviceSecretGroupByOutputType[P]>
            : GetScalarType<T[P], DeviceSecretGroupByOutputType[P]>
        }
      >
    >


  export type DeviceSecretSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    deviceId?: boolean
    secretHash?: boolean
    publicKey?: boolean
    rotatedAt?: boolean
    device?: boolean | DeviceDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["deviceSecret"]>

  export type DeviceSecretSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    deviceId?: boolean
    secretHash?: boolean
    publicKey?: boolean
    rotatedAt?: boolean
    device?: boolean | DeviceDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["deviceSecret"]>

  export type DeviceSecretSelectScalar = {
    id?: boolean
    deviceId?: boolean
    secretHash?: boolean
    publicKey?: boolean
    rotatedAt?: boolean
  }

  export type DeviceSecretInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    device?: boolean | DeviceDefaultArgs<ExtArgs>
  }
  export type DeviceSecretIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    device?: boolean | DeviceDefaultArgs<ExtArgs>
  }

  export type $DeviceSecretPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "DeviceSecret"
    objects: {
      device: Prisma.$DevicePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      deviceId: string
      secretHash: string
      publicKey: string | null
      rotatedAt: Date
    }, ExtArgs["result"]["deviceSecret"]>
    composites: {}
  }

  type DeviceSecretGetPayload<S extends boolean | null | undefined | DeviceSecretDefaultArgs> = $Result.GetResult<Prisma.$DeviceSecretPayload, S>

  type DeviceSecretCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<DeviceSecretFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: DeviceSecretCountAggregateInputType | true
    }

  export interface DeviceSecretDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['DeviceSecret'], meta: { name: 'DeviceSecret' } }
    /**
     * Find zero or one DeviceSecret that matches the filter.
     * @param {DeviceSecretFindUniqueArgs} args - Arguments to find a DeviceSecret
     * @example
     * // Get one DeviceSecret
     * const deviceSecret = await prisma.deviceSecret.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends DeviceSecretFindUniqueArgs>(args: SelectSubset<T, DeviceSecretFindUniqueArgs<ExtArgs>>): Prisma__DeviceSecretClient<$Result.GetResult<Prisma.$DeviceSecretPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one DeviceSecret that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {DeviceSecretFindUniqueOrThrowArgs} args - Arguments to find a DeviceSecret
     * @example
     * // Get one DeviceSecret
     * const deviceSecret = await prisma.deviceSecret.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends DeviceSecretFindUniqueOrThrowArgs>(args: SelectSubset<T, DeviceSecretFindUniqueOrThrowArgs<ExtArgs>>): Prisma__DeviceSecretClient<$Result.GetResult<Prisma.$DeviceSecretPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first DeviceSecret that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DeviceSecretFindFirstArgs} args - Arguments to find a DeviceSecret
     * @example
     * // Get one DeviceSecret
     * const deviceSecret = await prisma.deviceSecret.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends DeviceSecretFindFirstArgs>(args?: SelectSubset<T, DeviceSecretFindFirstArgs<ExtArgs>>): Prisma__DeviceSecretClient<$Result.GetResult<Prisma.$DeviceSecretPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first DeviceSecret that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DeviceSecretFindFirstOrThrowArgs} args - Arguments to find a DeviceSecret
     * @example
     * // Get one DeviceSecret
     * const deviceSecret = await prisma.deviceSecret.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends DeviceSecretFindFirstOrThrowArgs>(args?: SelectSubset<T, DeviceSecretFindFirstOrThrowArgs<ExtArgs>>): Prisma__DeviceSecretClient<$Result.GetResult<Prisma.$DeviceSecretPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more DeviceSecrets that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DeviceSecretFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all DeviceSecrets
     * const deviceSecrets = await prisma.deviceSecret.findMany()
     * 
     * // Get first 10 DeviceSecrets
     * const deviceSecrets = await prisma.deviceSecret.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const deviceSecretWithIdOnly = await prisma.deviceSecret.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends DeviceSecretFindManyArgs>(args?: SelectSubset<T, DeviceSecretFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DeviceSecretPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a DeviceSecret.
     * @param {DeviceSecretCreateArgs} args - Arguments to create a DeviceSecret.
     * @example
     * // Create one DeviceSecret
     * const DeviceSecret = await prisma.deviceSecret.create({
     *   data: {
     *     // ... data to create a DeviceSecret
     *   }
     * })
     * 
     */
    create<T extends DeviceSecretCreateArgs>(args: SelectSubset<T, DeviceSecretCreateArgs<ExtArgs>>): Prisma__DeviceSecretClient<$Result.GetResult<Prisma.$DeviceSecretPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many DeviceSecrets.
     * @param {DeviceSecretCreateManyArgs} args - Arguments to create many DeviceSecrets.
     * @example
     * // Create many DeviceSecrets
     * const deviceSecret = await prisma.deviceSecret.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends DeviceSecretCreateManyArgs>(args?: SelectSubset<T, DeviceSecretCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many DeviceSecrets and returns the data saved in the database.
     * @param {DeviceSecretCreateManyAndReturnArgs} args - Arguments to create many DeviceSecrets.
     * @example
     * // Create many DeviceSecrets
     * const deviceSecret = await prisma.deviceSecret.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many DeviceSecrets and only return the `id`
     * const deviceSecretWithIdOnly = await prisma.deviceSecret.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends DeviceSecretCreateManyAndReturnArgs>(args?: SelectSubset<T, DeviceSecretCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DeviceSecretPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a DeviceSecret.
     * @param {DeviceSecretDeleteArgs} args - Arguments to delete one DeviceSecret.
     * @example
     * // Delete one DeviceSecret
     * const DeviceSecret = await prisma.deviceSecret.delete({
     *   where: {
     *     // ... filter to delete one DeviceSecret
     *   }
     * })
     * 
     */
    delete<T extends DeviceSecretDeleteArgs>(args: SelectSubset<T, DeviceSecretDeleteArgs<ExtArgs>>): Prisma__DeviceSecretClient<$Result.GetResult<Prisma.$DeviceSecretPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one DeviceSecret.
     * @param {DeviceSecretUpdateArgs} args - Arguments to update one DeviceSecret.
     * @example
     * // Update one DeviceSecret
     * const deviceSecret = await prisma.deviceSecret.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends DeviceSecretUpdateArgs>(args: SelectSubset<T, DeviceSecretUpdateArgs<ExtArgs>>): Prisma__DeviceSecretClient<$Result.GetResult<Prisma.$DeviceSecretPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more DeviceSecrets.
     * @param {DeviceSecretDeleteManyArgs} args - Arguments to filter DeviceSecrets to delete.
     * @example
     * // Delete a few DeviceSecrets
     * const { count } = await prisma.deviceSecret.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends DeviceSecretDeleteManyArgs>(args?: SelectSubset<T, DeviceSecretDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more DeviceSecrets.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DeviceSecretUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many DeviceSecrets
     * const deviceSecret = await prisma.deviceSecret.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends DeviceSecretUpdateManyArgs>(args: SelectSubset<T, DeviceSecretUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one DeviceSecret.
     * @param {DeviceSecretUpsertArgs} args - Arguments to update or create a DeviceSecret.
     * @example
     * // Update or create a DeviceSecret
     * const deviceSecret = await prisma.deviceSecret.upsert({
     *   create: {
     *     // ... data to create a DeviceSecret
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the DeviceSecret we want to update
     *   }
     * })
     */
    upsert<T extends DeviceSecretUpsertArgs>(args: SelectSubset<T, DeviceSecretUpsertArgs<ExtArgs>>): Prisma__DeviceSecretClient<$Result.GetResult<Prisma.$DeviceSecretPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of DeviceSecrets.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DeviceSecretCountArgs} args - Arguments to filter DeviceSecrets to count.
     * @example
     * // Count the number of DeviceSecrets
     * const count = await prisma.deviceSecret.count({
     *   where: {
     *     // ... the filter for the DeviceSecrets we want to count
     *   }
     * })
    **/
    count<T extends DeviceSecretCountArgs>(
      args?: Subset<T, DeviceSecretCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], DeviceSecretCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a DeviceSecret.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DeviceSecretAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends DeviceSecretAggregateArgs>(args: Subset<T, DeviceSecretAggregateArgs>): Prisma.PrismaPromise<GetDeviceSecretAggregateType<T>>

    /**
     * Group by DeviceSecret.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DeviceSecretGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends DeviceSecretGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: DeviceSecretGroupByArgs['orderBy'] }
        : { orderBy?: DeviceSecretGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, DeviceSecretGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetDeviceSecretGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the DeviceSecret model
   */
  readonly fields: DeviceSecretFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for DeviceSecret.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__DeviceSecretClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    device<T extends DeviceDefaultArgs<ExtArgs> = {}>(args?: Subset<T, DeviceDefaultArgs<ExtArgs>>): Prisma__DeviceClient<$Result.GetResult<Prisma.$DevicePayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the DeviceSecret model
   */ 
  interface DeviceSecretFieldRefs {
    readonly id: FieldRef<"DeviceSecret", 'String'>
    readonly deviceId: FieldRef<"DeviceSecret", 'String'>
    readonly secretHash: FieldRef<"DeviceSecret", 'String'>
    readonly publicKey: FieldRef<"DeviceSecret", 'String'>
    readonly rotatedAt: FieldRef<"DeviceSecret", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * DeviceSecret findUnique
   */
  export type DeviceSecretFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeviceSecret
     */
    select?: DeviceSecretSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeviceSecretInclude<ExtArgs> | null
    /**
     * Filter, which DeviceSecret to fetch.
     */
    where: DeviceSecretWhereUniqueInput
  }

  /**
   * DeviceSecret findUniqueOrThrow
   */
  export type DeviceSecretFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeviceSecret
     */
    select?: DeviceSecretSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeviceSecretInclude<ExtArgs> | null
    /**
     * Filter, which DeviceSecret to fetch.
     */
    where: DeviceSecretWhereUniqueInput
  }

  /**
   * DeviceSecret findFirst
   */
  export type DeviceSecretFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeviceSecret
     */
    select?: DeviceSecretSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeviceSecretInclude<ExtArgs> | null
    /**
     * Filter, which DeviceSecret to fetch.
     */
    where?: DeviceSecretWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DeviceSecrets to fetch.
     */
    orderBy?: DeviceSecretOrderByWithRelationInput | DeviceSecretOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for DeviceSecrets.
     */
    cursor?: DeviceSecretWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DeviceSecrets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DeviceSecrets.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of DeviceSecrets.
     */
    distinct?: DeviceSecretScalarFieldEnum | DeviceSecretScalarFieldEnum[]
  }

  /**
   * DeviceSecret findFirstOrThrow
   */
  export type DeviceSecretFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeviceSecret
     */
    select?: DeviceSecretSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeviceSecretInclude<ExtArgs> | null
    /**
     * Filter, which DeviceSecret to fetch.
     */
    where?: DeviceSecretWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DeviceSecrets to fetch.
     */
    orderBy?: DeviceSecretOrderByWithRelationInput | DeviceSecretOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for DeviceSecrets.
     */
    cursor?: DeviceSecretWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DeviceSecrets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DeviceSecrets.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of DeviceSecrets.
     */
    distinct?: DeviceSecretScalarFieldEnum | DeviceSecretScalarFieldEnum[]
  }

  /**
   * DeviceSecret findMany
   */
  export type DeviceSecretFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeviceSecret
     */
    select?: DeviceSecretSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeviceSecretInclude<ExtArgs> | null
    /**
     * Filter, which DeviceSecrets to fetch.
     */
    where?: DeviceSecretWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DeviceSecrets to fetch.
     */
    orderBy?: DeviceSecretOrderByWithRelationInput | DeviceSecretOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing DeviceSecrets.
     */
    cursor?: DeviceSecretWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DeviceSecrets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DeviceSecrets.
     */
    skip?: number
    distinct?: DeviceSecretScalarFieldEnum | DeviceSecretScalarFieldEnum[]
  }

  /**
   * DeviceSecret create
   */
  export type DeviceSecretCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeviceSecret
     */
    select?: DeviceSecretSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeviceSecretInclude<ExtArgs> | null
    /**
     * The data needed to create a DeviceSecret.
     */
    data: XOR<DeviceSecretCreateInput, DeviceSecretUncheckedCreateInput>
  }

  /**
   * DeviceSecret createMany
   */
  export type DeviceSecretCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many DeviceSecrets.
     */
    data: DeviceSecretCreateManyInput | DeviceSecretCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * DeviceSecret createManyAndReturn
   */
  export type DeviceSecretCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeviceSecret
     */
    select?: DeviceSecretSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many DeviceSecrets.
     */
    data: DeviceSecretCreateManyInput | DeviceSecretCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeviceSecretIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * DeviceSecret update
   */
  export type DeviceSecretUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeviceSecret
     */
    select?: DeviceSecretSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeviceSecretInclude<ExtArgs> | null
    /**
     * The data needed to update a DeviceSecret.
     */
    data: XOR<DeviceSecretUpdateInput, DeviceSecretUncheckedUpdateInput>
    /**
     * Choose, which DeviceSecret to update.
     */
    where: DeviceSecretWhereUniqueInput
  }

  /**
   * DeviceSecret updateMany
   */
  export type DeviceSecretUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update DeviceSecrets.
     */
    data: XOR<DeviceSecretUpdateManyMutationInput, DeviceSecretUncheckedUpdateManyInput>
    /**
     * Filter which DeviceSecrets to update
     */
    where?: DeviceSecretWhereInput
  }

  /**
   * DeviceSecret upsert
   */
  export type DeviceSecretUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeviceSecret
     */
    select?: DeviceSecretSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeviceSecretInclude<ExtArgs> | null
    /**
     * The filter to search for the DeviceSecret to update in case it exists.
     */
    where: DeviceSecretWhereUniqueInput
    /**
     * In case the DeviceSecret found by the `where` argument doesn't exist, create a new DeviceSecret with this data.
     */
    create: XOR<DeviceSecretCreateInput, DeviceSecretUncheckedCreateInput>
    /**
     * In case the DeviceSecret was found with the provided `where` argument, update it with this data.
     */
    update: XOR<DeviceSecretUpdateInput, DeviceSecretUncheckedUpdateInput>
  }

  /**
   * DeviceSecret delete
   */
  export type DeviceSecretDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeviceSecret
     */
    select?: DeviceSecretSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeviceSecretInclude<ExtArgs> | null
    /**
     * Filter which DeviceSecret to delete.
     */
    where: DeviceSecretWhereUniqueInput
  }

  /**
   * DeviceSecret deleteMany
   */
  export type DeviceSecretDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which DeviceSecrets to delete
     */
    where?: DeviceSecretWhereInput
  }

  /**
   * DeviceSecret without action
   */
  export type DeviceSecretDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeviceSecret
     */
    select?: DeviceSecretSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeviceSecretInclude<ExtArgs> | null
  }


  /**
   * Model Telemetry
   */

  export type AggregateTelemetry = {
    _count: TelemetryCountAggregateOutputType | null
    _min: TelemetryMinAggregateOutputType | null
    _max: TelemetryMaxAggregateOutputType | null
  }

  export type TelemetryMinAggregateOutputType = {
    id: string | null
    deviceId: string | null
    ts: Date | null
    createdAt: Date | null
  }

  export type TelemetryMaxAggregateOutputType = {
    id: string | null
    deviceId: string | null
    ts: Date | null
    createdAt: Date | null
  }

  export type TelemetryCountAggregateOutputType = {
    id: number
    deviceId: number
    ts: number
    metrics: number
    geo: number
    createdAt: number
    _all: number
  }


  export type TelemetryMinAggregateInputType = {
    id?: true
    deviceId?: true
    ts?: true
    createdAt?: true
  }

  export type TelemetryMaxAggregateInputType = {
    id?: true
    deviceId?: true
    ts?: true
    createdAt?: true
  }

  export type TelemetryCountAggregateInputType = {
    id?: true
    deviceId?: true
    ts?: true
    metrics?: true
    geo?: true
    createdAt?: true
    _all?: true
  }

  export type TelemetryAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Telemetry to aggregate.
     */
    where?: TelemetryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Telemetries to fetch.
     */
    orderBy?: TelemetryOrderByWithRelationInput | TelemetryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TelemetryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Telemetries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Telemetries.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Telemetries
    **/
    _count?: true | TelemetryCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TelemetryMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TelemetryMaxAggregateInputType
  }

  export type GetTelemetryAggregateType<T extends TelemetryAggregateArgs> = {
        [P in keyof T & keyof AggregateTelemetry]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTelemetry[P]>
      : GetScalarType<T[P], AggregateTelemetry[P]>
  }




  export type TelemetryGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TelemetryWhereInput
    orderBy?: TelemetryOrderByWithAggregationInput | TelemetryOrderByWithAggregationInput[]
    by: TelemetryScalarFieldEnum[] | TelemetryScalarFieldEnum
    having?: TelemetryScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TelemetryCountAggregateInputType | true
    _min?: TelemetryMinAggregateInputType
    _max?: TelemetryMaxAggregateInputType
  }

  export type TelemetryGroupByOutputType = {
    id: string
    deviceId: string
    ts: Date
    metrics: JsonValue
    geo: JsonValue | null
    createdAt: Date
    _count: TelemetryCountAggregateOutputType | null
    _min: TelemetryMinAggregateOutputType | null
    _max: TelemetryMaxAggregateOutputType | null
  }

  type GetTelemetryGroupByPayload<T extends TelemetryGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TelemetryGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TelemetryGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TelemetryGroupByOutputType[P]>
            : GetScalarType<T[P], TelemetryGroupByOutputType[P]>
        }
      >
    >


  export type TelemetrySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    deviceId?: boolean
    ts?: boolean
    metrics?: boolean
    geo?: boolean
    createdAt?: boolean
    device?: boolean | DeviceDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["telemetry"]>

  export type TelemetrySelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    deviceId?: boolean
    ts?: boolean
    metrics?: boolean
    geo?: boolean
    createdAt?: boolean
    device?: boolean | DeviceDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["telemetry"]>

  export type TelemetrySelectScalar = {
    id?: boolean
    deviceId?: boolean
    ts?: boolean
    metrics?: boolean
    geo?: boolean
    createdAt?: boolean
  }

  export type TelemetryInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    device?: boolean | DeviceDefaultArgs<ExtArgs>
  }
  export type TelemetryIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    device?: boolean | DeviceDefaultArgs<ExtArgs>
  }

  export type $TelemetryPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Telemetry"
    objects: {
      device: Prisma.$DevicePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      deviceId: string
      ts: Date
      metrics: Prisma.JsonValue
      geo: Prisma.JsonValue | null
      createdAt: Date
    }, ExtArgs["result"]["telemetry"]>
    composites: {}
  }

  type TelemetryGetPayload<S extends boolean | null | undefined | TelemetryDefaultArgs> = $Result.GetResult<Prisma.$TelemetryPayload, S>

  type TelemetryCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<TelemetryFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: TelemetryCountAggregateInputType | true
    }

  export interface TelemetryDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Telemetry'], meta: { name: 'Telemetry' } }
    /**
     * Find zero or one Telemetry that matches the filter.
     * @param {TelemetryFindUniqueArgs} args - Arguments to find a Telemetry
     * @example
     * // Get one Telemetry
     * const telemetry = await prisma.telemetry.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TelemetryFindUniqueArgs>(args: SelectSubset<T, TelemetryFindUniqueArgs<ExtArgs>>): Prisma__TelemetryClient<$Result.GetResult<Prisma.$TelemetryPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Telemetry that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {TelemetryFindUniqueOrThrowArgs} args - Arguments to find a Telemetry
     * @example
     * // Get one Telemetry
     * const telemetry = await prisma.telemetry.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TelemetryFindUniqueOrThrowArgs>(args: SelectSubset<T, TelemetryFindUniqueOrThrowArgs<ExtArgs>>): Prisma__TelemetryClient<$Result.GetResult<Prisma.$TelemetryPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Telemetry that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TelemetryFindFirstArgs} args - Arguments to find a Telemetry
     * @example
     * // Get one Telemetry
     * const telemetry = await prisma.telemetry.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TelemetryFindFirstArgs>(args?: SelectSubset<T, TelemetryFindFirstArgs<ExtArgs>>): Prisma__TelemetryClient<$Result.GetResult<Prisma.$TelemetryPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Telemetry that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TelemetryFindFirstOrThrowArgs} args - Arguments to find a Telemetry
     * @example
     * // Get one Telemetry
     * const telemetry = await prisma.telemetry.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TelemetryFindFirstOrThrowArgs>(args?: SelectSubset<T, TelemetryFindFirstOrThrowArgs<ExtArgs>>): Prisma__TelemetryClient<$Result.GetResult<Prisma.$TelemetryPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Telemetries that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TelemetryFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Telemetries
     * const telemetries = await prisma.telemetry.findMany()
     * 
     * // Get first 10 Telemetries
     * const telemetries = await prisma.telemetry.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const telemetryWithIdOnly = await prisma.telemetry.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends TelemetryFindManyArgs>(args?: SelectSubset<T, TelemetryFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TelemetryPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Telemetry.
     * @param {TelemetryCreateArgs} args - Arguments to create a Telemetry.
     * @example
     * // Create one Telemetry
     * const Telemetry = await prisma.telemetry.create({
     *   data: {
     *     // ... data to create a Telemetry
     *   }
     * })
     * 
     */
    create<T extends TelemetryCreateArgs>(args: SelectSubset<T, TelemetryCreateArgs<ExtArgs>>): Prisma__TelemetryClient<$Result.GetResult<Prisma.$TelemetryPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Telemetries.
     * @param {TelemetryCreateManyArgs} args - Arguments to create many Telemetries.
     * @example
     * // Create many Telemetries
     * const telemetry = await prisma.telemetry.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends TelemetryCreateManyArgs>(args?: SelectSubset<T, TelemetryCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Telemetries and returns the data saved in the database.
     * @param {TelemetryCreateManyAndReturnArgs} args - Arguments to create many Telemetries.
     * @example
     * // Create many Telemetries
     * const telemetry = await prisma.telemetry.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Telemetries and only return the `id`
     * const telemetryWithIdOnly = await prisma.telemetry.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends TelemetryCreateManyAndReturnArgs>(args?: SelectSubset<T, TelemetryCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TelemetryPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Telemetry.
     * @param {TelemetryDeleteArgs} args - Arguments to delete one Telemetry.
     * @example
     * // Delete one Telemetry
     * const Telemetry = await prisma.telemetry.delete({
     *   where: {
     *     // ... filter to delete one Telemetry
     *   }
     * })
     * 
     */
    delete<T extends TelemetryDeleteArgs>(args: SelectSubset<T, TelemetryDeleteArgs<ExtArgs>>): Prisma__TelemetryClient<$Result.GetResult<Prisma.$TelemetryPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Telemetry.
     * @param {TelemetryUpdateArgs} args - Arguments to update one Telemetry.
     * @example
     * // Update one Telemetry
     * const telemetry = await prisma.telemetry.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends TelemetryUpdateArgs>(args: SelectSubset<T, TelemetryUpdateArgs<ExtArgs>>): Prisma__TelemetryClient<$Result.GetResult<Prisma.$TelemetryPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Telemetries.
     * @param {TelemetryDeleteManyArgs} args - Arguments to filter Telemetries to delete.
     * @example
     * // Delete a few Telemetries
     * const { count } = await prisma.telemetry.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends TelemetryDeleteManyArgs>(args?: SelectSubset<T, TelemetryDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Telemetries.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TelemetryUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Telemetries
     * const telemetry = await prisma.telemetry.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends TelemetryUpdateManyArgs>(args: SelectSubset<T, TelemetryUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Telemetry.
     * @param {TelemetryUpsertArgs} args - Arguments to update or create a Telemetry.
     * @example
     * // Update or create a Telemetry
     * const telemetry = await prisma.telemetry.upsert({
     *   create: {
     *     // ... data to create a Telemetry
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Telemetry we want to update
     *   }
     * })
     */
    upsert<T extends TelemetryUpsertArgs>(args: SelectSubset<T, TelemetryUpsertArgs<ExtArgs>>): Prisma__TelemetryClient<$Result.GetResult<Prisma.$TelemetryPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Telemetries.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TelemetryCountArgs} args - Arguments to filter Telemetries to count.
     * @example
     * // Count the number of Telemetries
     * const count = await prisma.telemetry.count({
     *   where: {
     *     // ... the filter for the Telemetries we want to count
     *   }
     * })
    **/
    count<T extends TelemetryCountArgs>(
      args?: Subset<T, TelemetryCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TelemetryCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Telemetry.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TelemetryAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TelemetryAggregateArgs>(args: Subset<T, TelemetryAggregateArgs>): Prisma.PrismaPromise<GetTelemetryAggregateType<T>>

    /**
     * Group by Telemetry.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TelemetryGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TelemetryGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TelemetryGroupByArgs['orderBy'] }
        : { orderBy?: TelemetryGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TelemetryGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTelemetryGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Telemetry model
   */
  readonly fields: TelemetryFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Telemetry.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TelemetryClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    device<T extends DeviceDefaultArgs<ExtArgs> = {}>(args?: Subset<T, DeviceDefaultArgs<ExtArgs>>): Prisma__DeviceClient<$Result.GetResult<Prisma.$DevicePayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Telemetry model
   */ 
  interface TelemetryFieldRefs {
    readonly id: FieldRef<"Telemetry", 'String'>
    readonly deviceId: FieldRef<"Telemetry", 'String'>
    readonly ts: FieldRef<"Telemetry", 'DateTime'>
    readonly metrics: FieldRef<"Telemetry", 'Json'>
    readonly geo: FieldRef<"Telemetry", 'Json'>
    readonly createdAt: FieldRef<"Telemetry", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Telemetry findUnique
   */
  export type TelemetryFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Telemetry
     */
    select?: TelemetrySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TelemetryInclude<ExtArgs> | null
    /**
     * Filter, which Telemetry to fetch.
     */
    where: TelemetryWhereUniqueInput
  }

  /**
   * Telemetry findUniqueOrThrow
   */
  export type TelemetryFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Telemetry
     */
    select?: TelemetrySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TelemetryInclude<ExtArgs> | null
    /**
     * Filter, which Telemetry to fetch.
     */
    where: TelemetryWhereUniqueInput
  }

  /**
   * Telemetry findFirst
   */
  export type TelemetryFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Telemetry
     */
    select?: TelemetrySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TelemetryInclude<ExtArgs> | null
    /**
     * Filter, which Telemetry to fetch.
     */
    where?: TelemetryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Telemetries to fetch.
     */
    orderBy?: TelemetryOrderByWithRelationInput | TelemetryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Telemetries.
     */
    cursor?: TelemetryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Telemetries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Telemetries.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Telemetries.
     */
    distinct?: TelemetryScalarFieldEnum | TelemetryScalarFieldEnum[]
  }

  /**
   * Telemetry findFirstOrThrow
   */
  export type TelemetryFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Telemetry
     */
    select?: TelemetrySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TelemetryInclude<ExtArgs> | null
    /**
     * Filter, which Telemetry to fetch.
     */
    where?: TelemetryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Telemetries to fetch.
     */
    orderBy?: TelemetryOrderByWithRelationInput | TelemetryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Telemetries.
     */
    cursor?: TelemetryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Telemetries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Telemetries.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Telemetries.
     */
    distinct?: TelemetryScalarFieldEnum | TelemetryScalarFieldEnum[]
  }

  /**
   * Telemetry findMany
   */
  export type TelemetryFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Telemetry
     */
    select?: TelemetrySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TelemetryInclude<ExtArgs> | null
    /**
     * Filter, which Telemetries to fetch.
     */
    where?: TelemetryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Telemetries to fetch.
     */
    orderBy?: TelemetryOrderByWithRelationInput | TelemetryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Telemetries.
     */
    cursor?: TelemetryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Telemetries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Telemetries.
     */
    skip?: number
    distinct?: TelemetryScalarFieldEnum | TelemetryScalarFieldEnum[]
  }

  /**
   * Telemetry create
   */
  export type TelemetryCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Telemetry
     */
    select?: TelemetrySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TelemetryInclude<ExtArgs> | null
    /**
     * The data needed to create a Telemetry.
     */
    data: XOR<TelemetryCreateInput, TelemetryUncheckedCreateInput>
  }

  /**
   * Telemetry createMany
   */
  export type TelemetryCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Telemetries.
     */
    data: TelemetryCreateManyInput | TelemetryCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Telemetry createManyAndReturn
   */
  export type TelemetryCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Telemetry
     */
    select?: TelemetrySelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Telemetries.
     */
    data: TelemetryCreateManyInput | TelemetryCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TelemetryIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Telemetry update
   */
  export type TelemetryUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Telemetry
     */
    select?: TelemetrySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TelemetryInclude<ExtArgs> | null
    /**
     * The data needed to update a Telemetry.
     */
    data: XOR<TelemetryUpdateInput, TelemetryUncheckedUpdateInput>
    /**
     * Choose, which Telemetry to update.
     */
    where: TelemetryWhereUniqueInput
  }

  /**
   * Telemetry updateMany
   */
  export type TelemetryUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Telemetries.
     */
    data: XOR<TelemetryUpdateManyMutationInput, TelemetryUncheckedUpdateManyInput>
    /**
     * Filter which Telemetries to update
     */
    where?: TelemetryWhereInput
  }

  /**
   * Telemetry upsert
   */
  export type TelemetryUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Telemetry
     */
    select?: TelemetrySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TelemetryInclude<ExtArgs> | null
    /**
     * The filter to search for the Telemetry to update in case it exists.
     */
    where: TelemetryWhereUniqueInput
    /**
     * In case the Telemetry found by the `where` argument doesn't exist, create a new Telemetry with this data.
     */
    create: XOR<TelemetryCreateInput, TelemetryUncheckedCreateInput>
    /**
     * In case the Telemetry was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TelemetryUpdateInput, TelemetryUncheckedUpdateInput>
  }

  /**
   * Telemetry delete
   */
  export type TelemetryDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Telemetry
     */
    select?: TelemetrySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TelemetryInclude<ExtArgs> | null
    /**
     * Filter which Telemetry to delete.
     */
    where: TelemetryWhereUniqueInput
  }

  /**
   * Telemetry deleteMany
   */
  export type TelemetryDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Telemetries to delete
     */
    where?: TelemetryWhereInput
  }

  /**
   * Telemetry without action
   */
  export type TelemetryDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Telemetry
     */
    select?: TelemetrySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TelemetryInclude<ExtArgs> | null
  }


  /**
   * Model DeviceTwin
   */

  export type AggregateDeviceTwin = {
    _count: DeviceTwinCountAggregateOutputType | null
    _min: DeviceTwinMinAggregateOutputType | null
    _max: DeviceTwinMaxAggregateOutputType | null
  }

  export type DeviceTwinMinAggregateOutputType = {
    id: string | null
    deviceId: string | null
    lastTs: Date | null
    updatedAt: Date | null
  }

  export type DeviceTwinMaxAggregateOutputType = {
    id: string | null
    deviceId: string | null
    lastTs: Date | null
    updatedAt: Date | null
  }

  export type DeviceTwinCountAggregateOutputType = {
    id: number
    deviceId: number
    lastTs: number
    derivedState: number
    updatedAt: number
    _all: number
  }


  export type DeviceTwinMinAggregateInputType = {
    id?: true
    deviceId?: true
    lastTs?: true
    updatedAt?: true
  }

  export type DeviceTwinMaxAggregateInputType = {
    id?: true
    deviceId?: true
    lastTs?: true
    updatedAt?: true
  }

  export type DeviceTwinCountAggregateInputType = {
    id?: true
    deviceId?: true
    lastTs?: true
    derivedState?: true
    updatedAt?: true
    _all?: true
  }

  export type DeviceTwinAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which DeviceTwin to aggregate.
     */
    where?: DeviceTwinWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DeviceTwins to fetch.
     */
    orderBy?: DeviceTwinOrderByWithRelationInput | DeviceTwinOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: DeviceTwinWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DeviceTwins from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DeviceTwins.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned DeviceTwins
    **/
    _count?: true | DeviceTwinCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: DeviceTwinMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: DeviceTwinMaxAggregateInputType
  }

  export type GetDeviceTwinAggregateType<T extends DeviceTwinAggregateArgs> = {
        [P in keyof T & keyof AggregateDeviceTwin]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateDeviceTwin[P]>
      : GetScalarType<T[P], AggregateDeviceTwin[P]>
  }




  export type DeviceTwinGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DeviceTwinWhereInput
    orderBy?: DeviceTwinOrderByWithAggregationInput | DeviceTwinOrderByWithAggregationInput[]
    by: DeviceTwinScalarFieldEnum[] | DeviceTwinScalarFieldEnum
    having?: DeviceTwinScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: DeviceTwinCountAggregateInputType | true
    _min?: DeviceTwinMinAggregateInputType
    _max?: DeviceTwinMaxAggregateInputType
  }

  export type DeviceTwinGroupByOutputType = {
    id: string
    deviceId: string
    lastTs: Date | null
    derivedState: JsonValue
    updatedAt: Date
    _count: DeviceTwinCountAggregateOutputType | null
    _min: DeviceTwinMinAggregateOutputType | null
    _max: DeviceTwinMaxAggregateOutputType | null
  }

  type GetDeviceTwinGroupByPayload<T extends DeviceTwinGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<DeviceTwinGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof DeviceTwinGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], DeviceTwinGroupByOutputType[P]>
            : GetScalarType<T[P], DeviceTwinGroupByOutputType[P]>
        }
      >
    >


  export type DeviceTwinSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    deviceId?: boolean
    lastTs?: boolean
    derivedState?: boolean
    updatedAt?: boolean
    device?: boolean | DeviceDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["deviceTwin"]>

  export type DeviceTwinSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    deviceId?: boolean
    lastTs?: boolean
    derivedState?: boolean
    updatedAt?: boolean
    device?: boolean | DeviceDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["deviceTwin"]>

  export type DeviceTwinSelectScalar = {
    id?: boolean
    deviceId?: boolean
    lastTs?: boolean
    derivedState?: boolean
    updatedAt?: boolean
  }

  export type DeviceTwinInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    device?: boolean | DeviceDefaultArgs<ExtArgs>
  }
  export type DeviceTwinIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    device?: boolean | DeviceDefaultArgs<ExtArgs>
  }

  export type $DeviceTwinPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "DeviceTwin"
    objects: {
      device: Prisma.$DevicePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      deviceId: string
      lastTs: Date | null
      derivedState: Prisma.JsonValue
      updatedAt: Date
    }, ExtArgs["result"]["deviceTwin"]>
    composites: {}
  }

  type DeviceTwinGetPayload<S extends boolean | null | undefined | DeviceTwinDefaultArgs> = $Result.GetResult<Prisma.$DeviceTwinPayload, S>

  type DeviceTwinCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<DeviceTwinFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: DeviceTwinCountAggregateInputType | true
    }

  export interface DeviceTwinDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['DeviceTwin'], meta: { name: 'DeviceTwin' } }
    /**
     * Find zero or one DeviceTwin that matches the filter.
     * @param {DeviceTwinFindUniqueArgs} args - Arguments to find a DeviceTwin
     * @example
     * // Get one DeviceTwin
     * const deviceTwin = await prisma.deviceTwin.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends DeviceTwinFindUniqueArgs>(args: SelectSubset<T, DeviceTwinFindUniqueArgs<ExtArgs>>): Prisma__DeviceTwinClient<$Result.GetResult<Prisma.$DeviceTwinPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one DeviceTwin that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {DeviceTwinFindUniqueOrThrowArgs} args - Arguments to find a DeviceTwin
     * @example
     * // Get one DeviceTwin
     * const deviceTwin = await prisma.deviceTwin.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends DeviceTwinFindUniqueOrThrowArgs>(args: SelectSubset<T, DeviceTwinFindUniqueOrThrowArgs<ExtArgs>>): Prisma__DeviceTwinClient<$Result.GetResult<Prisma.$DeviceTwinPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first DeviceTwin that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DeviceTwinFindFirstArgs} args - Arguments to find a DeviceTwin
     * @example
     * // Get one DeviceTwin
     * const deviceTwin = await prisma.deviceTwin.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends DeviceTwinFindFirstArgs>(args?: SelectSubset<T, DeviceTwinFindFirstArgs<ExtArgs>>): Prisma__DeviceTwinClient<$Result.GetResult<Prisma.$DeviceTwinPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first DeviceTwin that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DeviceTwinFindFirstOrThrowArgs} args - Arguments to find a DeviceTwin
     * @example
     * // Get one DeviceTwin
     * const deviceTwin = await prisma.deviceTwin.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends DeviceTwinFindFirstOrThrowArgs>(args?: SelectSubset<T, DeviceTwinFindFirstOrThrowArgs<ExtArgs>>): Prisma__DeviceTwinClient<$Result.GetResult<Prisma.$DeviceTwinPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more DeviceTwins that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DeviceTwinFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all DeviceTwins
     * const deviceTwins = await prisma.deviceTwin.findMany()
     * 
     * // Get first 10 DeviceTwins
     * const deviceTwins = await prisma.deviceTwin.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const deviceTwinWithIdOnly = await prisma.deviceTwin.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends DeviceTwinFindManyArgs>(args?: SelectSubset<T, DeviceTwinFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DeviceTwinPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a DeviceTwin.
     * @param {DeviceTwinCreateArgs} args - Arguments to create a DeviceTwin.
     * @example
     * // Create one DeviceTwin
     * const DeviceTwin = await prisma.deviceTwin.create({
     *   data: {
     *     // ... data to create a DeviceTwin
     *   }
     * })
     * 
     */
    create<T extends DeviceTwinCreateArgs>(args: SelectSubset<T, DeviceTwinCreateArgs<ExtArgs>>): Prisma__DeviceTwinClient<$Result.GetResult<Prisma.$DeviceTwinPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many DeviceTwins.
     * @param {DeviceTwinCreateManyArgs} args - Arguments to create many DeviceTwins.
     * @example
     * // Create many DeviceTwins
     * const deviceTwin = await prisma.deviceTwin.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends DeviceTwinCreateManyArgs>(args?: SelectSubset<T, DeviceTwinCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many DeviceTwins and returns the data saved in the database.
     * @param {DeviceTwinCreateManyAndReturnArgs} args - Arguments to create many DeviceTwins.
     * @example
     * // Create many DeviceTwins
     * const deviceTwin = await prisma.deviceTwin.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many DeviceTwins and only return the `id`
     * const deviceTwinWithIdOnly = await prisma.deviceTwin.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends DeviceTwinCreateManyAndReturnArgs>(args?: SelectSubset<T, DeviceTwinCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DeviceTwinPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a DeviceTwin.
     * @param {DeviceTwinDeleteArgs} args - Arguments to delete one DeviceTwin.
     * @example
     * // Delete one DeviceTwin
     * const DeviceTwin = await prisma.deviceTwin.delete({
     *   where: {
     *     // ... filter to delete one DeviceTwin
     *   }
     * })
     * 
     */
    delete<T extends DeviceTwinDeleteArgs>(args: SelectSubset<T, DeviceTwinDeleteArgs<ExtArgs>>): Prisma__DeviceTwinClient<$Result.GetResult<Prisma.$DeviceTwinPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one DeviceTwin.
     * @param {DeviceTwinUpdateArgs} args - Arguments to update one DeviceTwin.
     * @example
     * // Update one DeviceTwin
     * const deviceTwin = await prisma.deviceTwin.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends DeviceTwinUpdateArgs>(args: SelectSubset<T, DeviceTwinUpdateArgs<ExtArgs>>): Prisma__DeviceTwinClient<$Result.GetResult<Prisma.$DeviceTwinPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more DeviceTwins.
     * @param {DeviceTwinDeleteManyArgs} args - Arguments to filter DeviceTwins to delete.
     * @example
     * // Delete a few DeviceTwins
     * const { count } = await prisma.deviceTwin.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends DeviceTwinDeleteManyArgs>(args?: SelectSubset<T, DeviceTwinDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more DeviceTwins.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DeviceTwinUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many DeviceTwins
     * const deviceTwin = await prisma.deviceTwin.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends DeviceTwinUpdateManyArgs>(args: SelectSubset<T, DeviceTwinUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one DeviceTwin.
     * @param {DeviceTwinUpsertArgs} args - Arguments to update or create a DeviceTwin.
     * @example
     * // Update or create a DeviceTwin
     * const deviceTwin = await prisma.deviceTwin.upsert({
     *   create: {
     *     // ... data to create a DeviceTwin
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the DeviceTwin we want to update
     *   }
     * })
     */
    upsert<T extends DeviceTwinUpsertArgs>(args: SelectSubset<T, DeviceTwinUpsertArgs<ExtArgs>>): Prisma__DeviceTwinClient<$Result.GetResult<Prisma.$DeviceTwinPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of DeviceTwins.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DeviceTwinCountArgs} args - Arguments to filter DeviceTwins to count.
     * @example
     * // Count the number of DeviceTwins
     * const count = await prisma.deviceTwin.count({
     *   where: {
     *     // ... the filter for the DeviceTwins we want to count
     *   }
     * })
    **/
    count<T extends DeviceTwinCountArgs>(
      args?: Subset<T, DeviceTwinCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], DeviceTwinCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a DeviceTwin.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DeviceTwinAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends DeviceTwinAggregateArgs>(args: Subset<T, DeviceTwinAggregateArgs>): Prisma.PrismaPromise<GetDeviceTwinAggregateType<T>>

    /**
     * Group by DeviceTwin.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DeviceTwinGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends DeviceTwinGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: DeviceTwinGroupByArgs['orderBy'] }
        : { orderBy?: DeviceTwinGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, DeviceTwinGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetDeviceTwinGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the DeviceTwin model
   */
  readonly fields: DeviceTwinFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for DeviceTwin.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__DeviceTwinClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    device<T extends DeviceDefaultArgs<ExtArgs> = {}>(args?: Subset<T, DeviceDefaultArgs<ExtArgs>>): Prisma__DeviceClient<$Result.GetResult<Prisma.$DevicePayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the DeviceTwin model
   */ 
  interface DeviceTwinFieldRefs {
    readonly id: FieldRef<"DeviceTwin", 'String'>
    readonly deviceId: FieldRef<"DeviceTwin", 'String'>
    readonly lastTs: FieldRef<"DeviceTwin", 'DateTime'>
    readonly derivedState: FieldRef<"DeviceTwin", 'Json'>
    readonly updatedAt: FieldRef<"DeviceTwin", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * DeviceTwin findUnique
   */
  export type DeviceTwinFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeviceTwin
     */
    select?: DeviceTwinSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeviceTwinInclude<ExtArgs> | null
    /**
     * Filter, which DeviceTwin to fetch.
     */
    where: DeviceTwinWhereUniqueInput
  }

  /**
   * DeviceTwin findUniqueOrThrow
   */
  export type DeviceTwinFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeviceTwin
     */
    select?: DeviceTwinSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeviceTwinInclude<ExtArgs> | null
    /**
     * Filter, which DeviceTwin to fetch.
     */
    where: DeviceTwinWhereUniqueInput
  }

  /**
   * DeviceTwin findFirst
   */
  export type DeviceTwinFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeviceTwin
     */
    select?: DeviceTwinSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeviceTwinInclude<ExtArgs> | null
    /**
     * Filter, which DeviceTwin to fetch.
     */
    where?: DeviceTwinWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DeviceTwins to fetch.
     */
    orderBy?: DeviceTwinOrderByWithRelationInput | DeviceTwinOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for DeviceTwins.
     */
    cursor?: DeviceTwinWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DeviceTwins from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DeviceTwins.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of DeviceTwins.
     */
    distinct?: DeviceTwinScalarFieldEnum | DeviceTwinScalarFieldEnum[]
  }

  /**
   * DeviceTwin findFirstOrThrow
   */
  export type DeviceTwinFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeviceTwin
     */
    select?: DeviceTwinSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeviceTwinInclude<ExtArgs> | null
    /**
     * Filter, which DeviceTwin to fetch.
     */
    where?: DeviceTwinWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DeviceTwins to fetch.
     */
    orderBy?: DeviceTwinOrderByWithRelationInput | DeviceTwinOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for DeviceTwins.
     */
    cursor?: DeviceTwinWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DeviceTwins from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DeviceTwins.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of DeviceTwins.
     */
    distinct?: DeviceTwinScalarFieldEnum | DeviceTwinScalarFieldEnum[]
  }

  /**
   * DeviceTwin findMany
   */
  export type DeviceTwinFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeviceTwin
     */
    select?: DeviceTwinSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeviceTwinInclude<ExtArgs> | null
    /**
     * Filter, which DeviceTwins to fetch.
     */
    where?: DeviceTwinWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DeviceTwins to fetch.
     */
    orderBy?: DeviceTwinOrderByWithRelationInput | DeviceTwinOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing DeviceTwins.
     */
    cursor?: DeviceTwinWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DeviceTwins from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DeviceTwins.
     */
    skip?: number
    distinct?: DeviceTwinScalarFieldEnum | DeviceTwinScalarFieldEnum[]
  }

  /**
   * DeviceTwin create
   */
  export type DeviceTwinCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeviceTwin
     */
    select?: DeviceTwinSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeviceTwinInclude<ExtArgs> | null
    /**
     * The data needed to create a DeviceTwin.
     */
    data: XOR<DeviceTwinCreateInput, DeviceTwinUncheckedCreateInput>
  }

  /**
   * DeviceTwin createMany
   */
  export type DeviceTwinCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many DeviceTwins.
     */
    data: DeviceTwinCreateManyInput | DeviceTwinCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * DeviceTwin createManyAndReturn
   */
  export type DeviceTwinCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeviceTwin
     */
    select?: DeviceTwinSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many DeviceTwins.
     */
    data: DeviceTwinCreateManyInput | DeviceTwinCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeviceTwinIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * DeviceTwin update
   */
  export type DeviceTwinUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeviceTwin
     */
    select?: DeviceTwinSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeviceTwinInclude<ExtArgs> | null
    /**
     * The data needed to update a DeviceTwin.
     */
    data: XOR<DeviceTwinUpdateInput, DeviceTwinUncheckedUpdateInput>
    /**
     * Choose, which DeviceTwin to update.
     */
    where: DeviceTwinWhereUniqueInput
  }

  /**
   * DeviceTwin updateMany
   */
  export type DeviceTwinUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update DeviceTwins.
     */
    data: XOR<DeviceTwinUpdateManyMutationInput, DeviceTwinUncheckedUpdateManyInput>
    /**
     * Filter which DeviceTwins to update
     */
    where?: DeviceTwinWhereInput
  }

  /**
   * DeviceTwin upsert
   */
  export type DeviceTwinUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeviceTwin
     */
    select?: DeviceTwinSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeviceTwinInclude<ExtArgs> | null
    /**
     * The filter to search for the DeviceTwin to update in case it exists.
     */
    where: DeviceTwinWhereUniqueInput
    /**
     * In case the DeviceTwin found by the `where` argument doesn't exist, create a new DeviceTwin with this data.
     */
    create: XOR<DeviceTwinCreateInput, DeviceTwinUncheckedCreateInput>
    /**
     * In case the DeviceTwin was found with the provided `where` argument, update it with this data.
     */
    update: XOR<DeviceTwinUpdateInput, DeviceTwinUncheckedUpdateInput>
  }

  /**
   * DeviceTwin delete
   */
  export type DeviceTwinDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeviceTwin
     */
    select?: DeviceTwinSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeviceTwinInclude<ExtArgs> | null
    /**
     * Filter which DeviceTwin to delete.
     */
    where: DeviceTwinWhereUniqueInput
  }

  /**
   * DeviceTwin deleteMany
   */
  export type DeviceTwinDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which DeviceTwins to delete
     */
    where?: DeviceTwinWhereInput
  }

  /**
   * DeviceTwin without action
   */
  export type DeviceTwinDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeviceTwin
     */
    select?: DeviceTwinSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeviceTwinInclude<ExtArgs> | null
  }


  /**
   * Model Command
   */

  export type AggregateCommand = {
    _count: CommandCountAggregateOutputType | null
    _min: CommandMinAggregateOutputType | null
    _max: CommandMaxAggregateOutputType | null
  }

  export type CommandMinAggregateOutputType = {
    id: string | null
    deviceId: string | null
    type: $Enums.CommandType | null
    status: $Enums.CommandStatus | null
    requestedByUserId: string | null
    requestedAt: Date | null
    deliveredAt: Date | null
    ackAt: Date | null
    errorMsg: string | null
  }

  export type CommandMaxAggregateOutputType = {
    id: string | null
    deviceId: string | null
    type: $Enums.CommandType | null
    status: $Enums.CommandStatus | null
    requestedByUserId: string | null
    requestedAt: Date | null
    deliveredAt: Date | null
    ackAt: Date | null
    errorMsg: string | null
  }

  export type CommandCountAggregateOutputType = {
    id: number
    deviceId: number
    type: number
    payload: number
    status: number
    requestedByUserId: number
    requestedAt: number
    deliveredAt: number
    ackAt: number
    errorMsg: number
    _all: number
  }


  export type CommandMinAggregateInputType = {
    id?: true
    deviceId?: true
    type?: true
    status?: true
    requestedByUserId?: true
    requestedAt?: true
    deliveredAt?: true
    ackAt?: true
    errorMsg?: true
  }

  export type CommandMaxAggregateInputType = {
    id?: true
    deviceId?: true
    type?: true
    status?: true
    requestedByUserId?: true
    requestedAt?: true
    deliveredAt?: true
    ackAt?: true
    errorMsg?: true
  }

  export type CommandCountAggregateInputType = {
    id?: true
    deviceId?: true
    type?: true
    payload?: true
    status?: true
    requestedByUserId?: true
    requestedAt?: true
    deliveredAt?: true
    ackAt?: true
    errorMsg?: true
    _all?: true
  }

  export type CommandAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Command to aggregate.
     */
    where?: CommandWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Commands to fetch.
     */
    orderBy?: CommandOrderByWithRelationInput | CommandOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CommandWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Commands from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Commands.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Commands
    **/
    _count?: true | CommandCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CommandMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CommandMaxAggregateInputType
  }

  export type GetCommandAggregateType<T extends CommandAggregateArgs> = {
        [P in keyof T & keyof AggregateCommand]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCommand[P]>
      : GetScalarType<T[P], AggregateCommand[P]>
  }




  export type CommandGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CommandWhereInput
    orderBy?: CommandOrderByWithAggregationInput | CommandOrderByWithAggregationInput[]
    by: CommandScalarFieldEnum[] | CommandScalarFieldEnum
    having?: CommandScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CommandCountAggregateInputType | true
    _min?: CommandMinAggregateInputType
    _max?: CommandMaxAggregateInputType
  }

  export type CommandGroupByOutputType = {
    id: string
    deviceId: string
    type: $Enums.CommandType
    payload: JsonValue
    status: $Enums.CommandStatus
    requestedByUserId: string | null
    requestedAt: Date
    deliveredAt: Date | null
    ackAt: Date | null
    errorMsg: string | null
    _count: CommandCountAggregateOutputType | null
    _min: CommandMinAggregateOutputType | null
    _max: CommandMaxAggregateOutputType | null
  }

  type GetCommandGroupByPayload<T extends CommandGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CommandGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CommandGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CommandGroupByOutputType[P]>
            : GetScalarType<T[P], CommandGroupByOutputType[P]>
        }
      >
    >


  export type CommandSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    deviceId?: boolean
    type?: boolean
    payload?: boolean
    status?: boolean
    requestedByUserId?: boolean
    requestedAt?: boolean
    deliveredAt?: boolean
    ackAt?: boolean
    errorMsg?: boolean
    device?: boolean | DeviceDefaultArgs<ExtArgs>
    requestedBy?: boolean | Command$requestedByArgs<ExtArgs>
  }, ExtArgs["result"]["command"]>

  export type CommandSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    deviceId?: boolean
    type?: boolean
    payload?: boolean
    status?: boolean
    requestedByUserId?: boolean
    requestedAt?: boolean
    deliveredAt?: boolean
    ackAt?: boolean
    errorMsg?: boolean
    device?: boolean | DeviceDefaultArgs<ExtArgs>
    requestedBy?: boolean | Command$requestedByArgs<ExtArgs>
  }, ExtArgs["result"]["command"]>

  export type CommandSelectScalar = {
    id?: boolean
    deviceId?: boolean
    type?: boolean
    payload?: boolean
    status?: boolean
    requestedByUserId?: boolean
    requestedAt?: boolean
    deliveredAt?: boolean
    ackAt?: boolean
    errorMsg?: boolean
  }

  export type CommandInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    device?: boolean | DeviceDefaultArgs<ExtArgs>
    requestedBy?: boolean | Command$requestedByArgs<ExtArgs>
  }
  export type CommandIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    device?: boolean | DeviceDefaultArgs<ExtArgs>
    requestedBy?: boolean | Command$requestedByArgs<ExtArgs>
  }

  export type $CommandPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Command"
    objects: {
      device: Prisma.$DevicePayload<ExtArgs>
      requestedBy: Prisma.$UserPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      deviceId: string
      type: $Enums.CommandType
      payload: Prisma.JsonValue
      status: $Enums.CommandStatus
      requestedByUserId: string | null
      requestedAt: Date
      deliveredAt: Date | null
      ackAt: Date | null
      errorMsg: string | null
    }, ExtArgs["result"]["command"]>
    composites: {}
  }

  type CommandGetPayload<S extends boolean | null | undefined | CommandDefaultArgs> = $Result.GetResult<Prisma.$CommandPayload, S>

  type CommandCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<CommandFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: CommandCountAggregateInputType | true
    }

  export interface CommandDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Command'], meta: { name: 'Command' } }
    /**
     * Find zero or one Command that matches the filter.
     * @param {CommandFindUniqueArgs} args - Arguments to find a Command
     * @example
     * // Get one Command
     * const command = await prisma.command.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CommandFindUniqueArgs>(args: SelectSubset<T, CommandFindUniqueArgs<ExtArgs>>): Prisma__CommandClient<$Result.GetResult<Prisma.$CommandPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Command that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {CommandFindUniqueOrThrowArgs} args - Arguments to find a Command
     * @example
     * // Get one Command
     * const command = await prisma.command.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CommandFindUniqueOrThrowArgs>(args: SelectSubset<T, CommandFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CommandClient<$Result.GetResult<Prisma.$CommandPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Command that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommandFindFirstArgs} args - Arguments to find a Command
     * @example
     * // Get one Command
     * const command = await prisma.command.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CommandFindFirstArgs>(args?: SelectSubset<T, CommandFindFirstArgs<ExtArgs>>): Prisma__CommandClient<$Result.GetResult<Prisma.$CommandPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Command that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommandFindFirstOrThrowArgs} args - Arguments to find a Command
     * @example
     * // Get one Command
     * const command = await prisma.command.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CommandFindFirstOrThrowArgs>(args?: SelectSubset<T, CommandFindFirstOrThrowArgs<ExtArgs>>): Prisma__CommandClient<$Result.GetResult<Prisma.$CommandPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Commands that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommandFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Commands
     * const commands = await prisma.command.findMany()
     * 
     * // Get first 10 Commands
     * const commands = await prisma.command.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const commandWithIdOnly = await prisma.command.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CommandFindManyArgs>(args?: SelectSubset<T, CommandFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CommandPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Command.
     * @param {CommandCreateArgs} args - Arguments to create a Command.
     * @example
     * // Create one Command
     * const Command = await prisma.command.create({
     *   data: {
     *     // ... data to create a Command
     *   }
     * })
     * 
     */
    create<T extends CommandCreateArgs>(args: SelectSubset<T, CommandCreateArgs<ExtArgs>>): Prisma__CommandClient<$Result.GetResult<Prisma.$CommandPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Commands.
     * @param {CommandCreateManyArgs} args - Arguments to create many Commands.
     * @example
     * // Create many Commands
     * const command = await prisma.command.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CommandCreateManyArgs>(args?: SelectSubset<T, CommandCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Commands and returns the data saved in the database.
     * @param {CommandCreateManyAndReturnArgs} args - Arguments to create many Commands.
     * @example
     * // Create many Commands
     * const command = await prisma.command.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Commands and only return the `id`
     * const commandWithIdOnly = await prisma.command.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CommandCreateManyAndReturnArgs>(args?: SelectSubset<T, CommandCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CommandPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Command.
     * @param {CommandDeleteArgs} args - Arguments to delete one Command.
     * @example
     * // Delete one Command
     * const Command = await prisma.command.delete({
     *   where: {
     *     // ... filter to delete one Command
     *   }
     * })
     * 
     */
    delete<T extends CommandDeleteArgs>(args: SelectSubset<T, CommandDeleteArgs<ExtArgs>>): Prisma__CommandClient<$Result.GetResult<Prisma.$CommandPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Command.
     * @param {CommandUpdateArgs} args - Arguments to update one Command.
     * @example
     * // Update one Command
     * const command = await prisma.command.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CommandUpdateArgs>(args: SelectSubset<T, CommandUpdateArgs<ExtArgs>>): Prisma__CommandClient<$Result.GetResult<Prisma.$CommandPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Commands.
     * @param {CommandDeleteManyArgs} args - Arguments to filter Commands to delete.
     * @example
     * // Delete a few Commands
     * const { count } = await prisma.command.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CommandDeleteManyArgs>(args?: SelectSubset<T, CommandDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Commands.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommandUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Commands
     * const command = await prisma.command.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CommandUpdateManyArgs>(args: SelectSubset<T, CommandUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Command.
     * @param {CommandUpsertArgs} args - Arguments to update or create a Command.
     * @example
     * // Update or create a Command
     * const command = await prisma.command.upsert({
     *   create: {
     *     // ... data to create a Command
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Command we want to update
     *   }
     * })
     */
    upsert<T extends CommandUpsertArgs>(args: SelectSubset<T, CommandUpsertArgs<ExtArgs>>): Prisma__CommandClient<$Result.GetResult<Prisma.$CommandPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Commands.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommandCountArgs} args - Arguments to filter Commands to count.
     * @example
     * // Count the number of Commands
     * const count = await prisma.command.count({
     *   where: {
     *     // ... the filter for the Commands we want to count
     *   }
     * })
    **/
    count<T extends CommandCountArgs>(
      args?: Subset<T, CommandCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CommandCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Command.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommandAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CommandAggregateArgs>(args: Subset<T, CommandAggregateArgs>): Prisma.PrismaPromise<GetCommandAggregateType<T>>

    /**
     * Group by Command.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommandGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CommandGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CommandGroupByArgs['orderBy'] }
        : { orderBy?: CommandGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CommandGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCommandGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Command model
   */
  readonly fields: CommandFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Command.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CommandClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    device<T extends DeviceDefaultArgs<ExtArgs> = {}>(args?: Subset<T, DeviceDefaultArgs<ExtArgs>>): Prisma__DeviceClient<$Result.GetResult<Prisma.$DevicePayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    requestedBy<T extends Command$requestedByArgs<ExtArgs> = {}>(args?: Subset<T, Command$requestedByArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Command model
   */ 
  interface CommandFieldRefs {
    readonly id: FieldRef<"Command", 'String'>
    readonly deviceId: FieldRef<"Command", 'String'>
    readonly type: FieldRef<"Command", 'CommandType'>
    readonly payload: FieldRef<"Command", 'Json'>
    readonly status: FieldRef<"Command", 'CommandStatus'>
    readonly requestedByUserId: FieldRef<"Command", 'String'>
    readonly requestedAt: FieldRef<"Command", 'DateTime'>
    readonly deliveredAt: FieldRef<"Command", 'DateTime'>
    readonly ackAt: FieldRef<"Command", 'DateTime'>
    readonly errorMsg: FieldRef<"Command", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Command findUnique
   */
  export type CommandFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Command
     */
    select?: CommandSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommandInclude<ExtArgs> | null
    /**
     * Filter, which Command to fetch.
     */
    where: CommandWhereUniqueInput
  }

  /**
   * Command findUniqueOrThrow
   */
  export type CommandFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Command
     */
    select?: CommandSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommandInclude<ExtArgs> | null
    /**
     * Filter, which Command to fetch.
     */
    where: CommandWhereUniqueInput
  }

  /**
   * Command findFirst
   */
  export type CommandFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Command
     */
    select?: CommandSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommandInclude<ExtArgs> | null
    /**
     * Filter, which Command to fetch.
     */
    where?: CommandWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Commands to fetch.
     */
    orderBy?: CommandOrderByWithRelationInput | CommandOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Commands.
     */
    cursor?: CommandWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Commands from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Commands.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Commands.
     */
    distinct?: CommandScalarFieldEnum | CommandScalarFieldEnum[]
  }

  /**
   * Command findFirstOrThrow
   */
  export type CommandFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Command
     */
    select?: CommandSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommandInclude<ExtArgs> | null
    /**
     * Filter, which Command to fetch.
     */
    where?: CommandWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Commands to fetch.
     */
    orderBy?: CommandOrderByWithRelationInput | CommandOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Commands.
     */
    cursor?: CommandWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Commands from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Commands.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Commands.
     */
    distinct?: CommandScalarFieldEnum | CommandScalarFieldEnum[]
  }

  /**
   * Command findMany
   */
  export type CommandFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Command
     */
    select?: CommandSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommandInclude<ExtArgs> | null
    /**
     * Filter, which Commands to fetch.
     */
    where?: CommandWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Commands to fetch.
     */
    orderBy?: CommandOrderByWithRelationInput | CommandOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Commands.
     */
    cursor?: CommandWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Commands from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Commands.
     */
    skip?: number
    distinct?: CommandScalarFieldEnum | CommandScalarFieldEnum[]
  }

  /**
   * Command create
   */
  export type CommandCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Command
     */
    select?: CommandSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommandInclude<ExtArgs> | null
    /**
     * The data needed to create a Command.
     */
    data: XOR<CommandCreateInput, CommandUncheckedCreateInput>
  }

  /**
   * Command createMany
   */
  export type CommandCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Commands.
     */
    data: CommandCreateManyInput | CommandCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Command createManyAndReturn
   */
  export type CommandCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Command
     */
    select?: CommandSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Commands.
     */
    data: CommandCreateManyInput | CommandCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommandIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Command update
   */
  export type CommandUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Command
     */
    select?: CommandSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommandInclude<ExtArgs> | null
    /**
     * The data needed to update a Command.
     */
    data: XOR<CommandUpdateInput, CommandUncheckedUpdateInput>
    /**
     * Choose, which Command to update.
     */
    where: CommandWhereUniqueInput
  }

  /**
   * Command updateMany
   */
  export type CommandUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Commands.
     */
    data: XOR<CommandUpdateManyMutationInput, CommandUncheckedUpdateManyInput>
    /**
     * Filter which Commands to update
     */
    where?: CommandWhereInput
  }

  /**
   * Command upsert
   */
  export type CommandUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Command
     */
    select?: CommandSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommandInclude<ExtArgs> | null
    /**
     * The filter to search for the Command to update in case it exists.
     */
    where: CommandWhereUniqueInput
    /**
     * In case the Command found by the `where` argument doesn't exist, create a new Command with this data.
     */
    create: XOR<CommandCreateInput, CommandUncheckedCreateInput>
    /**
     * In case the Command was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CommandUpdateInput, CommandUncheckedUpdateInput>
  }

  /**
   * Command delete
   */
  export type CommandDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Command
     */
    select?: CommandSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommandInclude<ExtArgs> | null
    /**
     * Filter which Command to delete.
     */
    where: CommandWhereUniqueInput
  }

  /**
   * Command deleteMany
   */
  export type CommandDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Commands to delete
     */
    where?: CommandWhereInput
  }

  /**
   * Command.requestedBy
   */
  export type Command$requestedByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * Command without action
   */
  export type CommandDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Command
     */
    select?: CommandSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommandInclude<ExtArgs> | null
  }


  /**
   * Model FirmwarePackage
   */

  export type AggregateFirmwarePackage = {
    _count: FirmwarePackageCountAggregateOutputType | null
    _min: FirmwarePackageMinAggregateOutputType | null
    _max: FirmwarePackageMaxAggregateOutputType | null
  }

  export type FirmwarePackageMinAggregateOutputType = {
    id: string | null
    version: string | null
    fileUrl: string | null
    checksum: string | null
    releaseNotes: string | null
    createdAt: Date | null
  }

  export type FirmwarePackageMaxAggregateOutputType = {
    id: string | null
    version: string | null
    fileUrl: string | null
    checksum: string | null
    releaseNotes: string | null
    createdAt: Date | null
  }

  export type FirmwarePackageCountAggregateOutputType = {
    id: number
    version: number
    fileUrl: number
    checksum: number
    releaseNotes: number
    createdAt: number
    _all: number
  }


  export type FirmwarePackageMinAggregateInputType = {
    id?: true
    version?: true
    fileUrl?: true
    checksum?: true
    releaseNotes?: true
    createdAt?: true
  }

  export type FirmwarePackageMaxAggregateInputType = {
    id?: true
    version?: true
    fileUrl?: true
    checksum?: true
    releaseNotes?: true
    createdAt?: true
  }

  export type FirmwarePackageCountAggregateInputType = {
    id?: true
    version?: true
    fileUrl?: true
    checksum?: true
    releaseNotes?: true
    createdAt?: true
    _all?: true
  }

  export type FirmwarePackageAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which FirmwarePackage to aggregate.
     */
    where?: FirmwarePackageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FirmwarePackages to fetch.
     */
    orderBy?: FirmwarePackageOrderByWithRelationInput | FirmwarePackageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: FirmwarePackageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FirmwarePackages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FirmwarePackages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned FirmwarePackages
    **/
    _count?: true | FirmwarePackageCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: FirmwarePackageMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: FirmwarePackageMaxAggregateInputType
  }

  export type GetFirmwarePackageAggregateType<T extends FirmwarePackageAggregateArgs> = {
        [P in keyof T & keyof AggregateFirmwarePackage]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateFirmwarePackage[P]>
      : GetScalarType<T[P], AggregateFirmwarePackage[P]>
  }




  export type FirmwarePackageGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FirmwarePackageWhereInput
    orderBy?: FirmwarePackageOrderByWithAggregationInput | FirmwarePackageOrderByWithAggregationInput[]
    by: FirmwarePackageScalarFieldEnum[] | FirmwarePackageScalarFieldEnum
    having?: FirmwarePackageScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: FirmwarePackageCountAggregateInputType | true
    _min?: FirmwarePackageMinAggregateInputType
    _max?: FirmwarePackageMaxAggregateInputType
  }

  export type FirmwarePackageGroupByOutputType = {
    id: string
    version: string
    fileUrl: string
    checksum: string
    releaseNotes: string | null
    createdAt: Date
    _count: FirmwarePackageCountAggregateOutputType | null
    _min: FirmwarePackageMinAggregateOutputType | null
    _max: FirmwarePackageMaxAggregateOutputType | null
  }

  type GetFirmwarePackageGroupByPayload<T extends FirmwarePackageGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<FirmwarePackageGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof FirmwarePackageGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], FirmwarePackageGroupByOutputType[P]>
            : GetScalarType<T[P], FirmwarePackageGroupByOutputType[P]>
        }
      >
    >


  export type FirmwarePackageSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    version?: boolean
    fileUrl?: boolean
    checksum?: boolean
    releaseNotes?: boolean
    createdAt?: boolean
    otaJobs?: boolean | FirmwarePackage$otaJobsArgs<ExtArgs>
    _count?: boolean | FirmwarePackageCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["firmwarePackage"]>

  export type FirmwarePackageSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    version?: boolean
    fileUrl?: boolean
    checksum?: boolean
    releaseNotes?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["firmwarePackage"]>

  export type FirmwarePackageSelectScalar = {
    id?: boolean
    version?: boolean
    fileUrl?: boolean
    checksum?: boolean
    releaseNotes?: boolean
    createdAt?: boolean
  }

  export type FirmwarePackageInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    otaJobs?: boolean | FirmwarePackage$otaJobsArgs<ExtArgs>
    _count?: boolean | FirmwarePackageCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type FirmwarePackageIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $FirmwarePackagePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "FirmwarePackage"
    objects: {
      otaJobs: Prisma.$OtaJobPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      version: string
      fileUrl: string
      checksum: string
      releaseNotes: string | null
      createdAt: Date
    }, ExtArgs["result"]["firmwarePackage"]>
    composites: {}
  }

  type FirmwarePackageGetPayload<S extends boolean | null | undefined | FirmwarePackageDefaultArgs> = $Result.GetResult<Prisma.$FirmwarePackagePayload, S>

  type FirmwarePackageCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<FirmwarePackageFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: FirmwarePackageCountAggregateInputType | true
    }

  export interface FirmwarePackageDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['FirmwarePackage'], meta: { name: 'FirmwarePackage' } }
    /**
     * Find zero or one FirmwarePackage that matches the filter.
     * @param {FirmwarePackageFindUniqueArgs} args - Arguments to find a FirmwarePackage
     * @example
     * // Get one FirmwarePackage
     * const firmwarePackage = await prisma.firmwarePackage.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends FirmwarePackageFindUniqueArgs>(args: SelectSubset<T, FirmwarePackageFindUniqueArgs<ExtArgs>>): Prisma__FirmwarePackageClient<$Result.GetResult<Prisma.$FirmwarePackagePayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one FirmwarePackage that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {FirmwarePackageFindUniqueOrThrowArgs} args - Arguments to find a FirmwarePackage
     * @example
     * // Get one FirmwarePackage
     * const firmwarePackage = await prisma.firmwarePackage.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends FirmwarePackageFindUniqueOrThrowArgs>(args: SelectSubset<T, FirmwarePackageFindUniqueOrThrowArgs<ExtArgs>>): Prisma__FirmwarePackageClient<$Result.GetResult<Prisma.$FirmwarePackagePayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first FirmwarePackage that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FirmwarePackageFindFirstArgs} args - Arguments to find a FirmwarePackage
     * @example
     * // Get one FirmwarePackage
     * const firmwarePackage = await prisma.firmwarePackage.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends FirmwarePackageFindFirstArgs>(args?: SelectSubset<T, FirmwarePackageFindFirstArgs<ExtArgs>>): Prisma__FirmwarePackageClient<$Result.GetResult<Prisma.$FirmwarePackagePayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first FirmwarePackage that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FirmwarePackageFindFirstOrThrowArgs} args - Arguments to find a FirmwarePackage
     * @example
     * // Get one FirmwarePackage
     * const firmwarePackage = await prisma.firmwarePackage.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends FirmwarePackageFindFirstOrThrowArgs>(args?: SelectSubset<T, FirmwarePackageFindFirstOrThrowArgs<ExtArgs>>): Prisma__FirmwarePackageClient<$Result.GetResult<Prisma.$FirmwarePackagePayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more FirmwarePackages that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FirmwarePackageFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all FirmwarePackages
     * const firmwarePackages = await prisma.firmwarePackage.findMany()
     * 
     * // Get first 10 FirmwarePackages
     * const firmwarePackages = await prisma.firmwarePackage.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const firmwarePackageWithIdOnly = await prisma.firmwarePackage.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends FirmwarePackageFindManyArgs>(args?: SelectSubset<T, FirmwarePackageFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FirmwarePackagePayload<ExtArgs>, T, "findMany">>

    /**
     * Create a FirmwarePackage.
     * @param {FirmwarePackageCreateArgs} args - Arguments to create a FirmwarePackage.
     * @example
     * // Create one FirmwarePackage
     * const FirmwarePackage = await prisma.firmwarePackage.create({
     *   data: {
     *     // ... data to create a FirmwarePackage
     *   }
     * })
     * 
     */
    create<T extends FirmwarePackageCreateArgs>(args: SelectSubset<T, FirmwarePackageCreateArgs<ExtArgs>>): Prisma__FirmwarePackageClient<$Result.GetResult<Prisma.$FirmwarePackagePayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many FirmwarePackages.
     * @param {FirmwarePackageCreateManyArgs} args - Arguments to create many FirmwarePackages.
     * @example
     * // Create many FirmwarePackages
     * const firmwarePackage = await prisma.firmwarePackage.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends FirmwarePackageCreateManyArgs>(args?: SelectSubset<T, FirmwarePackageCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many FirmwarePackages and returns the data saved in the database.
     * @param {FirmwarePackageCreateManyAndReturnArgs} args - Arguments to create many FirmwarePackages.
     * @example
     * // Create many FirmwarePackages
     * const firmwarePackage = await prisma.firmwarePackage.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many FirmwarePackages and only return the `id`
     * const firmwarePackageWithIdOnly = await prisma.firmwarePackage.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends FirmwarePackageCreateManyAndReturnArgs>(args?: SelectSubset<T, FirmwarePackageCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FirmwarePackagePayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a FirmwarePackage.
     * @param {FirmwarePackageDeleteArgs} args - Arguments to delete one FirmwarePackage.
     * @example
     * // Delete one FirmwarePackage
     * const FirmwarePackage = await prisma.firmwarePackage.delete({
     *   where: {
     *     // ... filter to delete one FirmwarePackage
     *   }
     * })
     * 
     */
    delete<T extends FirmwarePackageDeleteArgs>(args: SelectSubset<T, FirmwarePackageDeleteArgs<ExtArgs>>): Prisma__FirmwarePackageClient<$Result.GetResult<Prisma.$FirmwarePackagePayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one FirmwarePackage.
     * @param {FirmwarePackageUpdateArgs} args - Arguments to update one FirmwarePackage.
     * @example
     * // Update one FirmwarePackage
     * const firmwarePackage = await prisma.firmwarePackage.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends FirmwarePackageUpdateArgs>(args: SelectSubset<T, FirmwarePackageUpdateArgs<ExtArgs>>): Prisma__FirmwarePackageClient<$Result.GetResult<Prisma.$FirmwarePackagePayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more FirmwarePackages.
     * @param {FirmwarePackageDeleteManyArgs} args - Arguments to filter FirmwarePackages to delete.
     * @example
     * // Delete a few FirmwarePackages
     * const { count } = await prisma.firmwarePackage.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends FirmwarePackageDeleteManyArgs>(args?: SelectSubset<T, FirmwarePackageDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more FirmwarePackages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FirmwarePackageUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many FirmwarePackages
     * const firmwarePackage = await prisma.firmwarePackage.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends FirmwarePackageUpdateManyArgs>(args: SelectSubset<T, FirmwarePackageUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one FirmwarePackage.
     * @param {FirmwarePackageUpsertArgs} args - Arguments to update or create a FirmwarePackage.
     * @example
     * // Update or create a FirmwarePackage
     * const firmwarePackage = await prisma.firmwarePackage.upsert({
     *   create: {
     *     // ... data to create a FirmwarePackage
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the FirmwarePackage we want to update
     *   }
     * })
     */
    upsert<T extends FirmwarePackageUpsertArgs>(args: SelectSubset<T, FirmwarePackageUpsertArgs<ExtArgs>>): Prisma__FirmwarePackageClient<$Result.GetResult<Prisma.$FirmwarePackagePayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of FirmwarePackages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FirmwarePackageCountArgs} args - Arguments to filter FirmwarePackages to count.
     * @example
     * // Count the number of FirmwarePackages
     * const count = await prisma.firmwarePackage.count({
     *   where: {
     *     // ... the filter for the FirmwarePackages we want to count
     *   }
     * })
    **/
    count<T extends FirmwarePackageCountArgs>(
      args?: Subset<T, FirmwarePackageCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], FirmwarePackageCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a FirmwarePackage.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FirmwarePackageAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends FirmwarePackageAggregateArgs>(args: Subset<T, FirmwarePackageAggregateArgs>): Prisma.PrismaPromise<GetFirmwarePackageAggregateType<T>>

    /**
     * Group by FirmwarePackage.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FirmwarePackageGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends FirmwarePackageGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: FirmwarePackageGroupByArgs['orderBy'] }
        : { orderBy?: FirmwarePackageGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, FirmwarePackageGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetFirmwarePackageGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the FirmwarePackage model
   */
  readonly fields: FirmwarePackageFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for FirmwarePackage.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__FirmwarePackageClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    otaJobs<T extends FirmwarePackage$otaJobsArgs<ExtArgs> = {}>(args?: Subset<T, FirmwarePackage$otaJobsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OtaJobPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the FirmwarePackage model
   */ 
  interface FirmwarePackageFieldRefs {
    readonly id: FieldRef<"FirmwarePackage", 'String'>
    readonly version: FieldRef<"FirmwarePackage", 'String'>
    readonly fileUrl: FieldRef<"FirmwarePackage", 'String'>
    readonly checksum: FieldRef<"FirmwarePackage", 'String'>
    readonly releaseNotes: FieldRef<"FirmwarePackage", 'String'>
    readonly createdAt: FieldRef<"FirmwarePackage", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * FirmwarePackage findUnique
   */
  export type FirmwarePackageFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FirmwarePackage
     */
    select?: FirmwarePackageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FirmwarePackageInclude<ExtArgs> | null
    /**
     * Filter, which FirmwarePackage to fetch.
     */
    where: FirmwarePackageWhereUniqueInput
  }

  /**
   * FirmwarePackage findUniqueOrThrow
   */
  export type FirmwarePackageFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FirmwarePackage
     */
    select?: FirmwarePackageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FirmwarePackageInclude<ExtArgs> | null
    /**
     * Filter, which FirmwarePackage to fetch.
     */
    where: FirmwarePackageWhereUniqueInput
  }

  /**
   * FirmwarePackage findFirst
   */
  export type FirmwarePackageFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FirmwarePackage
     */
    select?: FirmwarePackageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FirmwarePackageInclude<ExtArgs> | null
    /**
     * Filter, which FirmwarePackage to fetch.
     */
    where?: FirmwarePackageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FirmwarePackages to fetch.
     */
    orderBy?: FirmwarePackageOrderByWithRelationInput | FirmwarePackageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for FirmwarePackages.
     */
    cursor?: FirmwarePackageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FirmwarePackages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FirmwarePackages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of FirmwarePackages.
     */
    distinct?: FirmwarePackageScalarFieldEnum | FirmwarePackageScalarFieldEnum[]
  }

  /**
   * FirmwarePackage findFirstOrThrow
   */
  export type FirmwarePackageFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FirmwarePackage
     */
    select?: FirmwarePackageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FirmwarePackageInclude<ExtArgs> | null
    /**
     * Filter, which FirmwarePackage to fetch.
     */
    where?: FirmwarePackageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FirmwarePackages to fetch.
     */
    orderBy?: FirmwarePackageOrderByWithRelationInput | FirmwarePackageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for FirmwarePackages.
     */
    cursor?: FirmwarePackageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FirmwarePackages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FirmwarePackages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of FirmwarePackages.
     */
    distinct?: FirmwarePackageScalarFieldEnum | FirmwarePackageScalarFieldEnum[]
  }

  /**
   * FirmwarePackage findMany
   */
  export type FirmwarePackageFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FirmwarePackage
     */
    select?: FirmwarePackageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FirmwarePackageInclude<ExtArgs> | null
    /**
     * Filter, which FirmwarePackages to fetch.
     */
    where?: FirmwarePackageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FirmwarePackages to fetch.
     */
    orderBy?: FirmwarePackageOrderByWithRelationInput | FirmwarePackageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing FirmwarePackages.
     */
    cursor?: FirmwarePackageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FirmwarePackages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FirmwarePackages.
     */
    skip?: number
    distinct?: FirmwarePackageScalarFieldEnum | FirmwarePackageScalarFieldEnum[]
  }

  /**
   * FirmwarePackage create
   */
  export type FirmwarePackageCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FirmwarePackage
     */
    select?: FirmwarePackageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FirmwarePackageInclude<ExtArgs> | null
    /**
     * The data needed to create a FirmwarePackage.
     */
    data: XOR<FirmwarePackageCreateInput, FirmwarePackageUncheckedCreateInput>
  }

  /**
   * FirmwarePackage createMany
   */
  export type FirmwarePackageCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many FirmwarePackages.
     */
    data: FirmwarePackageCreateManyInput | FirmwarePackageCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * FirmwarePackage createManyAndReturn
   */
  export type FirmwarePackageCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FirmwarePackage
     */
    select?: FirmwarePackageSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many FirmwarePackages.
     */
    data: FirmwarePackageCreateManyInput | FirmwarePackageCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * FirmwarePackage update
   */
  export type FirmwarePackageUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FirmwarePackage
     */
    select?: FirmwarePackageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FirmwarePackageInclude<ExtArgs> | null
    /**
     * The data needed to update a FirmwarePackage.
     */
    data: XOR<FirmwarePackageUpdateInput, FirmwarePackageUncheckedUpdateInput>
    /**
     * Choose, which FirmwarePackage to update.
     */
    where: FirmwarePackageWhereUniqueInput
  }

  /**
   * FirmwarePackage updateMany
   */
  export type FirmwarePackageUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update FirmwarePackages.
     */
    data: XOR<FirmwarePackageUpdateManyMutationInput, FirmwarePackageUncheckedUpdateManyInput>
    /**
     * Filter which FirmwarePackages to update
     */
    where?: FirmwarePackageWhereInput
  }

  /**
   * FirmwarePackage upsert
   */
  export type FirmwarePackageUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FirmwarePackage
     */
    select?: FirmwarePackageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FirmwarePackageInclude<ExtArgs> | null
    /**
     * The filter to search for the FirmwarePackage to update in case it exists.
     */
    where: FirmwarePackageWhereUniqueInput
    /**
     * In case the FirmwarePackage found by the `where` argument doesn't exist, create a new FirmwarePackage with this data.
     */
    create: XOR<FirmwarePackageCreateInput, FirmwarePackageUncheckedCreateInput>
    /**
     * In case the FirmwarePackage was found with the provided `where` argument, update it with this data.
     */
    update: XOR<FirmwarePackageUpdateInput, FirmwarePackageUncheckedUpdateInput>
  }

  /**
   * FirmwarePackage delete
   */
  export type FirmwarePackageDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FirmwarePackage
     */
    select?: FirmwarePackageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FirmwarePackageInclude<ExtArgs> | null
    /**
     * Filter which FirmwarePackage to delete.
     */
    where: FirmwarePackageWhereUniqueInput
  }

  /**
   * FirmwarePackage deleteMany
   */
  export type FirmwarePackageDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which FirmwarePackages to delete
     */
    where?: FirmwarePackageWhereInput
  }

  /**
   * FirmwarePackage.otaJobs
   */
  export type FirmwarePackage$otaJobsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OtaJob
     */
    select?: OtaJobSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OtaJobInclude<ExtArgs> | null
    where?: OtaJobWhereInput
    orderBy?: OtaJobOrderByWithRelationInput | OtaJobOrderByWithRelationInput[]
    cursor?: OtaJobWhereUniqueInput
    take?: number
    skip?: number
    distinct?: OtaJobScalarFieldEnum | OtaJobScalarFieldEnum[]
  }

  /**
   * FirmwarePackage without action
   */
  export type FirmwarePackageDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FirmwarePackage
     */
    select?: FirmwarePackageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FirmwarePackageInclude<ExtArgs> | null
  }


  /**
   * Model OtaJob
   */

  export type AggregateOtaJob = {
    _count: OtaJobCountAggregateOutputType | null
    _min: OtaJobMinAggregateOutputType | null
    _max: OtaJobMaxAggregateOutputType | null
  }

  export type OtaJobMinAggregateOutputType = {
    id: string | null
    tenantId: string | null
    targetType: $Enums.OtaTargetType | null
    deviceId: string | null
    firmwarePackageId: string | null
    status: $Enums.OtaJobStatus | null
    scheduledAt: Date | null
    startedAt: Date | null
    finishedAt: Date | null
    createdByUserId: string | null
    createdAt: Date | null
  }

  export type OtaJobMaxAggregateOutputType = {
    id: string | null
    tenantId: string | null
    targetType: $Enums.OtaTargetType | null
    deviceId: string | null
    firmwarePackageId: string | null
    status: $Enums.OtaJobStatus | null
    scheduledAt: Date | null
    startedAt: Date | null
    finishedAt: Date | null
    createdByUserId: string | null
    createdAt: Date | null
  }

  export type OtaJobCountAggregateOutputType = {
    id: number
    tenantId: number
    targetType: number
    deviceId: number
    groupFilter: number
    firmwarePackageId: number
    status: number
    scheduledAt: number
    startedAt: number
    finishedAt: number
    createdByUserId: number
    progress: number
    createdAt: number
    _all: number
  }


  export type OtaJobMinAggregateInputType = {
    id?: true
    tenantId?: true
    targetType?: true
    deviceId?: true
    firmwarePackageId?: true
    status?: true
    scheduledAt?: true
    startedAt?: true
    finishedAt?: true
    createdByUserId?: true
    createdAt?: true
  }

  export type OtaJobMaxAggregateInputType = {
    id?: true
    tenantId?: true
    targetType?: true
    deviceId?: true
    firmwarePackageId?: true
    status?: true
    scheduledAt?: true
    startedAt?: true
    finishedAt?: true
    createdByUserId?: true
    createdAt?: true
  }

  export type OtaJobCountAggregateInputType = {
    id?: true
    tenantId?: true
    targetType?: true
    deviceId?: true
    groupFilter?: true
    firmwarePackageId?: true
    status?: true
    scheduledAt?: true
    startedAt?: true
    finishedAt?: true
    createdByUserId?: true
    progress?: true
    createdAt?: true
    _all?: true
  }

  export type OtaJobAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which OtaJob to aggregate.
     */
    where?: OtaJobWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OtaJobs to fetch.
     */
    orderBy?: OtaJobOrderByWithRelationInput | OtaJobOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: OtaJobWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OtaJobs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OtaJobs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned OtaJobs
    **/
    _count?: true | OtaJobCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: OtaJobMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: OtaJobMaxAggregateInputType
  }

  export type GetOtaJobAggregateType<T extends OtaJobAggregateArgs> = {
        [P in keyof T & keyof AggregateOtaJob]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateOtaJob[P]>
      : GetScalarType<T[P], AggregateOtaJob[P]>
  }




  export type OtaJobGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: OtaJobWhereInput
    orderBy?: OtaJobOrderByWithAggregationInput | OtaJobOrderByWithAggregationInput[]
    by: OtaJobScalarFieldEnum[] | OtaJobScalarFieldEnum
    having?: OtaJobScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: OtaJobCountAggregateInputType | true
    _min?: OtaJobMinAggregateInputType
    _max?: OtaJobMaxAggregateInputType
  }

  export type OtaJobGroupByOutputType = {
    id: string
    tenantId: string
    targetType: $Enums.OtaTargetType
    deviceId: string | null
    groupFilter: JsonValue | null
    firmwarePackageId: string
    status: $Enums.OtaJobStatus
    scheduledAt: Date
    startedAt: Date | null
    finishedAt: Date | null
    createdByUserId: string | null
    progress: JsonValue | null
    createdAt: Date
    _count: OtaJobCountAggregateOutputType | null
    _min: OtaJobMinAggregateOutputType | null
    _max: OtaJobMaxAggregateOutputType | null
  }

  type GetOtaJobGroupByPayload<T extends OtaJobGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<OtaJobGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof OtaJobGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], OtaJobGroupByOutputType[P]>
            : GetScalarType<T[P], OtaJobGroupByOutputType[P]>
        }
      >
    >


  export type OtaJobSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tenantId?: boolean
    targetType?: boolean
    deviceId?: boolean
    groupFilter?: boolean
    firmwarePackageId?: boolean
    status?: boolean
    scheduledAt?: boolean
    startedAt?: boolean
    finishedAt?: boolean
    createdByUserId?: boolean
    progress?: boolean
    createdAt?: boolean
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
    firmwarePackage?: boolean | FirmwarePackageDefaultArgs<ExtArgs>
    createdBy?: boolean | OtaJob$createdByArgs<ExtArgs>
  }, ExtArgs["result"]["otaJob"]>

  export type OtaJobSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tenantId?: boolean
    targetType?: boolean
    deviceId?: boolean
    groupFilter?: boolean
    firmwarePackageId?: boolean
    status?: boolean
    scheduledAt?: boolean
    startedAt?: boolean
    finishedAt?: boolean
    createdByUserId?: boolean
    progress?: boolean
    createdAt?: boolean
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
    firmwarePackage?: boolean | FirmwarePackageDefaultArgs<ExtArgs>
    createdBy?: boolean | OtaJob$createdByArgs<ExtArgs>
  }, ExtArgs["result"]["otaJob"]>

  export type OtaJobSelectScalar = {
    id?: boolean
    tenantId?: boolean
    targetType?: boolean
    deviceId?: boolean
    groupFilter?: boolean
    firmwarePackageId?: boolean
    status?: boolean
    scheduledAt?: boolean
    startedAt?: boolean
    finishedAt?: boolean
    createdByUserId?: boolean
    progress?: boolean
    createdAt?: boolean
  }

  export type OtaJobInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
    firmwarePackage?: boolean | FirmwarePackageDefaultArgs<ExtArgs>
    createdBy?: boolean | OtaJob$createdByArgs<ExtArgs>
  }
  export type OtaJobIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
    firmwarePackage?: boolean | FirmwarePackageDefaultArgs<ExtArgs>
    createdBy?: boolean | OtaJob$createdByArgs<ExtArgs>
  }

  export type $OtaJobPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "OtaJob"
    objects: {
      tenant: Prisma.$TenantPayload<ExtArgs>
      firmwarePackage: Prisma.$FirmwarePackagePayload<ExtArgs>
      createdBy: Prisma.$UserPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      tenantId: string
      targetType: $Enums.OtaTargetType
      deviceId: string | null
      groupFilter: Prisma.JsonValue | null
      firmwarePackageId: string
      status: $Enums.OtaJobStatus
      scheduledAt: Date
      startedAt: Date | null
      finishedAt: Date | null
      createdByUserId: string | null
      progress: Prisma.JsonValue | null
      createdAt: Date
    }, ExtArgs["result"]["otaJob"]>
    composites: {}
  }

  type OtaJobGetPayload<S extends boolean | null | undefined | OtaJobDefaultArgs> = $Result.GetResult<Prisma.$OtaJobPayload, S>

  type OtaJobCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<OtaJobFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: OtaJobCountAggregateInputType | true
    }

  export interface OtaJobDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['OtaJob'], meta: { name: 'OtaJob' } }
    /**
     * Find zero or one OtaJob that matches the filter.
     * @param {OtaJobFindUniqueArgs} args - Arguments to find a OtaJob
     * @example
     * // Get one OtaJob
     * const otaJob = await prisma.otaJob.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends OtaJobFindUniqueArgs>(args: SelectSubset<T, OtaJobFindUniqueArgs<ExtArgs>>): Prisma__OtaJobClient<$Result.GetResult<Prisma.$OtaJobPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one OtaJob that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {OtaJobFindUniqueOrThrowArgs} args - Arguments to find a OtaJob
     * @example
     * // Get one OtaJob
     * const otaJob = await prisma.otaJob.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends OtaJobFindUniqueOrThrowArgs>(args: SelectSubset<T, OtaJobFindUniqueOrThrowArgs<ExtArgs>>): Prisma__OtaJobClient<$Result.GetResult<Prisma.$OtaJobPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first OtaJob that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OtaJobFindFirstArgs} args - Arguments to find a OtaJob
     * @example
     * // Get one OtaJob
     * const otaJob = await prisma.otaJob.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends OtaJobFindFirstArgs>(args?: SelectSubset<T, OtaJobFindFirstArgs<ExtArgs>>): Prisma__OtaJobClient<$Result.GetResult<Prisma.$OtaJobPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first OtaJob that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OtaJobFindFirstOrThrowArgs} args - Arguments to find a OtaJob
     * @example
     * // Get one OtaJob
     * const otaJob = await prisma.otaJob.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends OtaJobFindFirstOrThrowArgs>(args?: SelectSubset<T, OtaJobFindFirstOrThrowArgs<ExtArgs>>): Prisma__OtaJobClient<$Result.GetResult<Prisma.$OtaJobPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more OtaJobs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OtaJobFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all OtaJobs
     * const otaJobs = await prisma.otaJob.findMany()
     * 
     * // Get first 10 OtaJobs
     * const otaJobs = await prisma.otaJob.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const otaJobWithIdOnly = await prisma.otaJob.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends OtaJobFindManyArgs>(args?: SelectSubset<T, OtaJobFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OtaJobPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a OtaJob.
     * @param {OtaJobCreateArgs} args - Arguments to create a OtaJob.
     * @example
     * // Create one OtaJob
     * const OtaJob = await prisma.otaJob.create({
     *   data: {
     *     // ... data to create a OtaJob
     *   }
     * })
     * 
     */
    create<T extends OtaJobCreateArgs>(args: SelectSubset<T, OtaJobCreateArgs<ExtArgs>>): Prisma__OtaJobClient<$Result.GetResult<Prisma.$OtaJobPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many OtaJobs.
     * @param {OtaJobCreateManyArgs} args - Arguments to create many OtaJobs.
     * @example
     * // Create many OtaJobs
     * const otaJob = await prisma.otaJob.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends OtaJobCreateManyArgs>(args?: SelectSubset<T, OtaJobCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many OtaJobs and returns the data saved in the database.
     * @param {OtaJobCreateManyAndReturnArgs} args - Arguments to create many OtaJobs.
     * @example
     * // Create many OtaJobs
     * const otaJob = await prisma.otaJob.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many OtaJobs and only return the `id`
     * const otaJobWithIdOnly = await prisma.otaJob.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends OtaJobCreateManyAndReturnArgs>(args?: SelectSubset<T, OtaJobCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OtaJobPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a OtaJob.
     * @param {OtaJobDeleteArgs} args - Arguments to delete one OtaJob.
     * @example
     * // Delete one OtaJob
     * const OtaJob = await prisma.otaJob.delete({
     *   where: {
     *     // ... filter to delete one OtaJob
     *   }
     * })
     * 
     */
    delete<T extends OtaJobDeleteArgs>(args: SelectSubset<T, OtaJobDeleteArgs<ExtArgs>>): Prisma__OtaJobClient<$Result.GetResult<Prisma.$OtaJobPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one OtaJob.
     * @param {OtaJobUpdateArgs} args - Arguments to update one OtaJob.
     * @example
     * // Update one OtaJob
     * const otaJob = await prisma.otaJob.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends OtaJobUpdateArgs>(args: SelectSubset<T, OtaJobUpdateArgs<ExtArgs>>): Prisma__OtaJobClient<$Result.GetResult<Prisma.$OtaJobPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more OtaJobs.
     * @param {OtaJobDeleteManyArgs} args - Arguments to filter OtaJobs to delete.
     * @example
     * // Delete a few OtaJobs
     * const { count } = await prisma.otaJob.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends OtaJobDeleteManyArgs>(args?: SelectSubset<T, OtaJobDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more OtaJobs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OtaJobUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many OtaJobs
     * const otaJob = await prisma.otaJob.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends OtaJobUpdateManyArgs>(args: SelectSubset<T, OtaJobUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one OtaJob.
     * @param {OtaJobUpsertArgs} args - Arguments to update or create a OtaJob.
     * @example
     * // Update or create a OtaJob
     * const otaJob = await prisma.otaJob.upsert({
     *   create: {
     *     // ... data to create a OtaJob
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the OtaJob we want to update
     *   }
     * })
     */
    upsert<T extends OtaJobUpsertArgs>(args: SelectSubset<T, OtaJobUpsertArgs<ExtArgs>>): Prisma__OtaJobClient<$Result.GetResult<Prisma.$OtaJobPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of OtaJobs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OtaJobCountArgs} args - Arguments to filter OtaJobs to count.
     * @example
     * // Count the number of OtaJobs
     * const count = await prisma.otaJob.count({
     *   where: {
     *     // ... the filter for the OtaJobs we want to count
     *   }
     * })
    **/
    count<T extends OtaJobCountArgs>(
      args?: Subset<T, OtaJobCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], OtaJobCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a OtaJob.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OtaJobAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends OtaJobAggregateArgs>(args: Subset<T, OtaJobAggregateArgs>): Prisma.PrismaPromise<GetOtaJobAggregateType<T>>

    /**
     * Group by OtaJob.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OtaJobGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends OtaJobGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: OtaJobGroupByArgs['orderBy'] }
        : { orderBy?: OtaJobGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, OtaJobGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetOtaJobGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the OtaJob model
   */
  readonly fields: OtaJobFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for OtaJob.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__OtaJobClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    tenant<T extends TenantDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TenantDefaultArgs<ExtArgs>>): Prisma__TenantClient<$Result.GetResult<Prisma.$TenantPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    firmwarePackage<T extends FirmwarePackageDefaultArgs<ExtArgs> = {}>(args?: Subset<T, FirmwarePackageDefaultArgs<ExtArgs>>): Prisma__FirmwarePackageClient<$Result.GetResult<Prisma.$FirmwarePackagePayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    createdBy<T extends OtaJob$createdByArgs<ExtArgs> = {}>(args?: Subset<T, OtaJob$createdByArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the OtaJob model
   */ 
  interface OtaJobFieldRefs {
    readonly id: FieldRef<"OtaJob", 'String'>
    readonly tenantId: FieldRef<"OtaJob", 'String'>
    readonly targetType: FieldRef<"OtaJob", 'OtaTargetType'>
    readonly deviceId: FieldRef<"OtaJob", 'String'>
    readonly groupFilter: FieldRef<"OtaJob", 'Json'>
    readonly firmwarePackageId: FieldRef<"OtaJob", 'String'>
    readonly status: FieldRef<"OtaJob", 'OtaJobStatus'>
    readonly scheduledAt: FieldRef<"OtaJob", 'DateTime'>
    readonly startedAt: FieldRef<"OtaJob", 'DateTime'>
    readonly finishedAt: FieldRef<"OtaJob", 'DateTime'>
    readonly createdByUserId: FieldRef<"OtaJob", 'String'>
    readonly progress: FieldRef<"OtaJob", 'Json'>
    readonly createdAt: FieldRef<"OtaJob", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * OtaJob findUnique
   */
  export type OtaJobFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OtaJob
     */
    select?: OtaJobSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OtaJobInclude<ExtArgs> | null
    /**
     * Filter, which OtaJob to fetch.
     */
    where: OtaJobWhereUniqueInput
  }

  /**
   * OtaJob findUniqueOrThrow
   */
  export type OtaJobFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OtaJob
     */
    select?: OtaJobSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OtaJobInclude<ExtArgs> | null
    /**
     * Filter, which OtaJob to fetch.
     */
    where: OtaJobWhereUniqueInput
  }

  /**
   * OtaJob findFirst
   */
  export type OtaJobFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OtaJob
     */
    select?: OtaJobSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OtaJobInclude<ExtArgs> | null
    /**
     * Filter, which OtaJob to fetch.
     */
    where?: OtaJobWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OtaJobs to fetch.
     */
    orderBy?: OtaJobOrderByWithRelationInput | OtaJobOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for OtaJobs.
     */
    cursor?: OtaJobWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OtaJobs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OtaJobs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of OtaJobs.
     */
    distinct?: OtaJobScalarFieldEnum | OtaJobScalarFieldEnum[]
  }

  /**
   * OtaJob findFirstOrThrow
   */
  export type OtaJobFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OtaJob
     */
    select?: OtaJobSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OtaJobInclude<ExtArgs> | null
    /**
     * Filter, which OtaJob to fetch.
     */
    where?: OtaJobWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OtaJobs to fetch.
     */
    orderBy?: OtaJobOrderByWithRelationInput | OtaJobOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for OtaJobs.
     */
    cursor?: OtaJobWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OtaJobs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OtaJobs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of OtaJobs.
     */
    distinct?: OtaJobScalarFieldEnum | OtaJobScalarFieldEnum[]
  }

  /**
   * OtaJob findMany
   */
  export type OtaJobFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OtaJob
     */
    select?: OtaJobSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OtaJobInclude<ExtArgs> | null
    /**
     * Filter, which OtaJobs to fetch.
     */
    where?: OtaJobWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OtaJobs to fetch.
     */
    orderBy?: OtaJobOrderByWithRelationInput | OtaJobOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing OtaJobs.
     */
    cursor?: OtaJobWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OtaJobs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OtaJobs.
     */
    skip?: number
    distinct?: OtaJobScalarFieldEnum | OtaJobScalarFieldEnum[]
  }

  /**
   * OtaJob create
   */
  export type OtaJobCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OtaJob
     */
    select?: OtaJobSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OtaJobInclude<ExtArgs> | null
    /**
     * The data needed to create a OtaJob.
     */
    data: XOR<OtaJobCreateInput, OtaJobUncheckedCreateInput>
  }

  /**
   * OtaJob createMany
   */
  export type OtaJobCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many OtaJobs.
     */
    data: OtaJobCreateManyInput | OtaJobCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * OtaJob createManyAndReturn
   */
  export type OtaJobCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OtaJob
     */
    select?: OtaJobSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many OtaJobs.
     */
    data: OtaJobCreateManyInput | OtaJobCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OtaJobIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * OtaJob update
   */
  export type OtaJobUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OtaJob
     */
    select?: OtaJobSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OtaJobInclude<ExtArgs> | null
    /**
     * The data needed to update a OtaJob.
     */
    data: XOR<OtaJobUpdateInput, OtaJobUncheckedUpdateInput>
    /**
     * Choose, which OtaJob to update.
     */
    where: OtaJobWhereUniqueInput
  }

  /**
   * OtaJob updateMany
   */
  export type OtaJobUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update OtaJobs.
     */
    data: XOR<OtaJobUpdateManyMutationInput, OtaJobUncheckedUpdateManyInput>
    /**
     * Filter which OtaJobs to update
     */
    where?: OtaJobWhereInput
  }

  /**
   * OtaJob upsert
   */
  export type OtaJobUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OtaJob
     */
    select?: OtaJobSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OtaJobInclude<ExtArgs> | null
    /**
     * The filter to search for the OtaJob to update in case it exists.
     */
    where: OtaJobWhereUniqueInput
    /**
     * In case the OtaJob found by the `where` argument doesn't exist, create a new OtaJob with this data.
     */
    create: XOR<OtaJobCreateInput, OtaJobUncheckedCreateInput>
    /**
     * In case the OtaJob was found with the provided `where` argument, update it with this data.
     */
    update: XOR<OtaJobUpdateInput, OtaJobUncheckedUpdateInput>
  }

  /**
   * OtaJob delete
   */
  export type OtaJobDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OtaJob
     */
    select?: OtaJobSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OtaJobInclude<ExtArgs> | null
    /**
     * Filter which OtaJob to delete.
     */
    where: OtaJobWhereUniqueInput
  }

  /**
   * OtaJob deleteMany
   */
  export type OtaJobDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which OtaJobs to delete
     */
    where?: OtaJobWhereInput
  }

  /**
   * OtaJob.createdBy
   */
  export type OtaJob$createdByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * OtaJob without action
   */
  export type OtaJobDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OtaJob
     */
    select?: OtaJobSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OtaJobInclude<ExtArgs> | null
  }


  /**
   * Model SimInfo
   */

  export type AggregateSimInfo = {
    _count: SimInfoCountAggregateOutputType | null
    _avg: SimInfoAvgAggregateOutputType | null
    _sum: SimInfoSumAggregateOutputType | null
    _min: SimInfoMinAggregateOutputType | null
    _max: SimInfoMaxAggregateOutputType | null
  }

  export type SimInfoAvgAggregateOutputType = {
    dataUsageMb: number | null
  }

  export type SimInfoSumAggregateOutputType = {
    dataUsageMb: number | null
  }

  export type SimInfoMinAggregateOutputType = {
    iccid: string | null
    carrier: string | null
    planName: string | null
    status: $Enums.SimStatus | null
    lastSyncAt: Date | null
    dataUsageMb: number | null
    msisdn: string | null
    imsi: string | null
    notes: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type SimInfoMaxAggregateOutputType = {
    iccid: string | null
    carrier: string | null
    planName: string | null
    status: $Enums.SimStatus | null
    lastSyncAt: Date | null
    dataUsageMb: number | null
    msisdn: string | null
    imsi: string | null
    notes: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type SimInfoCountAggregateOutputType = {
    iccid: number
    carrier: number
    planName: number
    status: number
    lastSyncAt: number
    dataUsageMb: number
    msisdn: number
    imsi: number
    notes: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type SimInfoAvgAggregateInputType = {
    dataUsageMb?: true
  }

  export type SimInfoSumAggregateInputType = {
    dataUsageMb?: true
  }

  export type SimInfoMinAggregateInputType = {
    iccid?: true
    carrier?: true
    planName?: true
    status?: true
    lastSyncAt?: true
    dataUsageMb?: true
    msisdn?: true
    imsi?: true
    notes?: true
    createdAt?: true
    updatedAt?: true
  }

  export type SimInfoMaxAggregateInputType = {
    iccid?: true
    carrier?: true
    planName?: true
    status?: true
    lastSyncAt?: true
    dataUsageMb?: true
    msisdn?: true
    imsi?: true
    notes?: true
    createdAt?: true
    updatedAt?: true
  }

  export type SimInfoCountAggregateInputType = {
    iccid?: true
    carrier?: true
    planName?: true
    status?: true
    lastSyncAt?: true
    dataUsageMb?: true
    msisdn?: true
    imsi?: true
    notes?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type SimInfoAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SimInfo to aggregate.
     */
    where?: SimInfoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SimInfos to fetch.
     */
    orderBy?: SimInfoOrderByWithRelationInput | SimInfoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SimInfoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SimInfos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SimInfos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned SimInfos
    **/
    _count?: true | SimInfoCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: SimInfoAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: SimInfoSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SimInfoMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SimInfoMaxAggregateInputType
  }

  export type GetSimInfoAggregateType<T extends SimInfoAggregateArgs> = {
        [P in keyof T & keyof AggregateSimInfo]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSimInfo[P]>
      : GetScalarType<T[P], AggregateSimInfo[P]>
  }




  export type SimInfoGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SimInfoWhereInput
    orderBy?: SimInfoOrderByWithAggregationInput | SimInfoOrderByWithAggregationInput[]
    by: SimInfoScalarFieldEnum[] | SimInfoScalarFieldEnum
    having?: SimInfoScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SimInfoCountAggregateInputType | true
    _avg?: SimInfoAvgAggregateInputType
    _sum?: SimInfoSumAggregateInputType
    _min?: SimInfoMinAggregateInputType
    _max?: SimInfoMaxAggregateInputType
  }

  export type SimInfoGroupByOutputType = {
    iccid: string
    carrier: string | null
    planName: string | null
    status: $Enums.SimStatus
    lastSyncAt: Date | null
    dataUsageMb: number | null
    msisdn: string | null
    imsi: string | null
    notes: string | null
    createdAt: Date
    updatedAt: Date
    _count: SimInfoCountAggregateOutputType | null
    _avg: SimInfoAvgAggregateOutputType | null
    _sum: SimInfoSumAggregateOutputType | null
    _min: SimInfoMinAggregateOutputType | null
    _max: SimInfoMaxAggregateOutputType | null
  }

  type GetSimInfoGroupByPayload<T extends SimInfoGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SimInfoGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SimInfoGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SimInfoGroupByOutputType[P]>
            : GetScalarType<T[P], SimInfoGroupByOutputType[P]>
        }
      >
    >


  export type SimInfoSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    iccid?: boolean
    carrier?: boolean
    planName?: boolean
    status?: boolean
    lastSyncAt?: boolean
    dataUsageMb?: boolean
    msisdn?: boolean
    imsi?: boolean
    notes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    devices?: boolean | SimInfo$devicesArgs<ExtArgs>
    simActions?: boolean | SimInfo$simActionsArgs<ExtArgs>
    _count?: boolean | SimInfoCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["simInfo"]>

  export type SimInfoSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    iccid?: boolean
    carrier?: boolean
    planName?: boolean
    status?: boolean
    lastSyncAt?: boolean
    dataUsageMb?: boolean
    msisdn?: boolean
    imsi?: boolean
    notes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["simInfo"]>

  export type SimInfoSelectScalar = {
    iccid?: boolean
    carrier?: boolean
    planName?: boolean
    status?: boolean
    lastSyncAt?: boolean
    dataUsageMb?: boolean
    msisdn?: boolean
    imsi?: boolean
    notes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type SimInfoInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    devices?: boolean | SimInfo$devicesArgs<ExtArgs>
    simActions?: boolean | SimInfo$simActionsArgs<ExtArgs>
    _count?: boolean | SimInfoCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type SimInfoIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $SimInfoPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "SimInfo"
    objects: {
      devices: Prisma.$DevicePayload<ExtArgs>[]
      simActions: Prisma.$SimActionPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      iccid: string
      carrier: string | null
      planName: string | null
      status: $Enums.SimStatus
      lastSyncAt: Date | null
      dataUsageMb: number | null
      msisdn: string | null
      imsi: string | null
      notes: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["simInfo"]>
    composites: {}
  }

  type SimInfoGetPayload<S extends boolean | null | undefined | SimInfoDefaultArgs> = $Result.GetResult<Prisma.$SimInfoPayload, S>

  type SimInfoCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<SimInfoFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: SimInfoCountAggregateInputType | true
    }

  export interface SimInfoDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['SimInfo'], meta: { name: 'SimInfo' } }
    /**
     * Find zero or one SimInfo that matches the filter.
     * @param {SimInfoFindUniqueArgs} args - Arguments to find a SimInfo
     * @example
     * // Get one SimInfo
     * const simInfo = await prisma.simInfo.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SimInfoFindUniqueArgs>(args: SelectSubset<T, SimInfoFindUniqueArgs<ExtArgs>>): Prisma__SimInfoClient<$Result.GetResult<Prisma.$SimInfoPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one SimInfo that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {SimInfoFindUniqueOrThrowArgs} args - Arguments to find a SimInfo
     * @example
     * // Get one SimInfo
     * const simInfo = await prisma.simInfo.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SimInfoFindUniqueOrThrowArgs>(args: SelectSubset<T, SimInfoFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SimInfoClient<$Result.GetResult<Prisma.$SimInfoPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first SimInfo that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SimInfoFindFirstArgs} args - Arguments to find a SimInfo
     * @example
     * // Get one SimInfo
     * const simInfo = await prisma.simInfo.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SimInfoFindFirstArgs>(args?: SelectSubset<T, SimInfoFindFirstArgs<ExtArgs>>): Prisma__SimInfoClient<$Result.GetResult<Prisma.$SimInfoPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first SimInfo that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SimInfoFindFirstOrThrowArgs} args - Arguments to find a SimInfo
     * @example
     * // Get one SimInfo
     * const simInfo = await prisma.simInfo.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SimInfoFindFirstOrThrowArgs>(args?: SelectSubset<T, SimInfoFindFirstOrThrowArgs<ExtArgs>>): Prisma__SimInfoClient<$Result.GetResult<Prisma.$SimInfoPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more SimInfos that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SimInfoFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all SimInfos
     * const simInfos = await prisma.simInfo.findMany()
     * 
     * // Get first 10 SimInfos
     * const simInfos = await prisma.simInfo.findMany({ take: 10 })
     * 
     * // Only select the `iccid`
     * const simInfoWithIccidOnly = await prisma.simInfo.findMany({ select: { iccid: true } })
     * 
     */
    findMany<T extends SimInfoFindManyArgs>(args?: SelectSubset<T, SimInfoFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SimInfoPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a SimInfo.
     * @param {SimInfoCreateArgs} args - Arguments to create a SimInfo.
     * @example
     * // Create one SimInfo
     * const SimInfo = await prisma.simInfo.create({
     *   data: {
     *     // ... data to create a SimInfo
     *   }
     * })
     * 
     */
    create<T extends SimInfoCreateArgs>(args: SelectSubset<T, SimInfoCreateArgs<ExtArgs>>): Prisma__SimInfoClient<$Result.GetResult<Prisma.$SimInfoPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many SimInfos.
     * @param {SimInfoCreateManyArgs} args - Arguments to create many SimInfos.
     * @example
     * // Create many SimInfos
     * const simInfo = await prisma.simInfo.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SimInfoCreateManyArgs>(args?: SelectSubset<T, SimInfoCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many SimInfos and returns the data saved in the database.
     * @param {SimInfoCreateManyAndReturnArgs} args - Arguments to create many SimInfos.
     * @example
     * // Create many SimInfos
     * const simInfo = await prisma.simInfo.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many SimInfos and only return the `iccid`
     * const simInfoWithIccidOnly = await prisma.simInfo.createManyAndReturn({ 
     *   select: { iccid: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends SimInfoCreateManyAndReturnArgs>(args?: SelectSubset<T, SimInfoCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SimInfoPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a SimInfo.
     * @param {SimInfoDeleteArgs} args - Arguments to delete one SimInfo.
     * @example
     * // Delete one SimInfo
     * const SimInfo = await prisma.simInfo.delete({
     *   where: {
     *     // ... filter to delete one SimInfo
     *   }
     * })
     * 
     */
    delete<T extends SimInfoDeleteArgs>(args: SelectSubset<T, SimInfoDeleteArgs<ExtArgs>>): Prisma__SimInfoClient<$Result.GetResult<Prisma.$SimInfoPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one SimInfo.
     * @param {SimInfoUpdateArgs} args - Arguments to update one SimInfo.
     * @example
     * // Update one SimInfo
     * const simInfo = await prisma.simInfo.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SimInfoUpdateArgs>(args: SelectSubset<T, SimInfoUpdateArgs<ExtArgs>>): Prisma__SimInfoClient<$Result.GetResult<Prisma.$SimInfoPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more SimInfos.
     * @param {SimInfoDeleteManyArgs} args - Arguments to filter SimInfos to delete.
     * @example
     * // Delete a few SimInfos
     * const { count } = await prisma.simInfo.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SimInfoDeleteManyArgs>(args?: SelectSubset<T, SimInfoDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SimInfos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SimInfoUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many SimInfos
     * const simInfo = await prisma.simInfo.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SimInfoUpdateManyArgs>(args: SelectSubset<T, SimInfoUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one SimInfo.
     * @param {SimInfoUpsertArgs} args - Arguments to update or create a SimInfo.
     * @example
     * // Update or create a SimInfo
     * const simInfo = await prisma.simInfo.upsert({
     *   create: {
     *     // ... data to create a SimInfo
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the SimInfo we want to update
     *   }
     * })
     */
    upsert<T extends SimInfoUpsertArgs>(args: SelectSubset<T, SimInfoUpsertArgs<ExtArgs>>): Prisma__SimInfoClient<$Result.GetResult<Prisma.$SimInfoPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of SimInfos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SimInfoCountArgs} args - Arguments to filter SimInfos to count.
     * @example
     * // Count the number of SimInfos
     * const count = await prisma.simInfo.count({
     *   where: {
     *     // ... the filter for the SimInfos we want to count
     *   }
     * })
    **/
    count<T extends SimInfoCountArgs>(
      args?: Subset<T, SimInfoCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SimInfoCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a SimInfo.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SimInfoAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SimInfoAggregateArgs>(args: Subset<T, SimInfoAggregateArgs>): Prisma.PrismaPromise<GetSimInfoAggregateType<T>>

    /**
     * Group by SimInfo.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SimInfoGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SimInfoGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SimInfoGroupByArgs['orderBy'] }
        : { orderBy?: SimInfoGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SimInfoGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSimInfoGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the SimInfo model
   */
  readonly fields: SimInfoFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for SimInfo.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SimInfoClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    devices<T extends SimInfo$devicesArgs<ExtArgs> = {}>(args?: Subset<T, SimInfo$devicesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DevicePayload<ExtArgs>, T, "findMany"> | Null>
    simActions<T extends SimInfo$simActionsArgs<ExtArgs> = {}>(args?: Subset<T, SimInfo$simActionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SimActionPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the SimInfo model
   */ 
  interface SimInfoFieldRefs {
    readonly iccid: FieldRef<"SimInfo", 'String'>
    readonly carrier: FieldRef<"SimInfo", 'String'>
    readonly planName: FieldRef<"SimInfo", 'String'>
    readonly status: FieldRef<"SimInfo", 'SimStatus'>
    readonly lastSyncAt: FieldRef<"SimInfo", 'DateTime'>
    readonly dataUsageMb: FieldRef<"SimInfo", 'Float'>
    readonly msisdn: FieldRef<"SimInfo", 'String'>
    readonly imsi: FieldRef<"SimInfo", 'String'>
    readonly notes: FieldRef<"SimInfo", 'String'>
    readonly createdAt: FieldRef<"SimInfo", 'DateTime'>
    readonly updatedAt: FieldRef<"SimInfo", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * SimInfo findUnique
   */
  export type SimInfoFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SimInfo
     */
    select?: SimInfoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SimInfoInclude<ExtArgs> | null
    /**
     * Filter, which SimInfo to fetch.
     */
    where: SimInfoWhereUniqueInput
  }

  /**
   * SimInfo findUniqueOrThrow
   */
  export type SimInfoFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SimInfo
     */
    select?: SimInfoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SimInfoInclude<ExtArgs> | null
    /**
     * Filter, which SimInfo to fetch.
     */
    where: SimInfoWhereUniqueInput
  }

  /**
   * SimInfo findFirst
   */
  export type SimInfoFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SimInfo
     */
    select?: SimInfoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SimInfoInclude<ExtArgs> | null
    /**
     * Filter, which SimInfo to fetch.
     */
    where?: SimInfoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SimInfos to fetch.
     */
    orderBy?: SimInfoOrderByWithRelationInput | SimInfoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SimInfos.
     */
    cursor?: SimInfoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SimInfos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SimInfos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SimInfos.
     */
    distinct?: SimInfoScalarFieldEnum | SimInfoScalarFieldEnum[]
  }

  /**
   * SimInfo findFirstOrThrow
   */
  export type SimInfoFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SimInfo
     */
    select?: SimInfoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SimInfoInclude<ExtArgs> | null
    /**
     * Filter, which SimInfo to fetch.
     */
    where?: SimInfoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SimInfos to fetch.
     */
    orderBy?: SimInfoOrderByWithRelationInput | SimInfoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SimInfos.
     */
    cursor?: SimInfoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SimInfos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SimInfos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SimInfos.
     */
    distinct?: SimInfoScalarFieldEnum | SimInfoScalarFieldEnum[]
  }

  /**
   * SimInfo findMany
   */
  export type SimInfoFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SimInfo
     */
    select?: SimInfoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SimInfoInclude<ExtArgs> | null
    /**
     * Filter, which SimInfos to fetch.
     */
    where?: SimInfoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SimInfos to fetch.
     */
    orderBy?: SimInfoOrderByWithRelationInput | SimInfoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing SimInfos.
     */
    cursor?: SimInfoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SimInfos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SimInfos.
     */
    skip?: number
    distinct?: SimInfoScalarFieldEnum | SimInfoScalarFieldEnum[]
  }

  /**
   * SimInfo create
   */
  export type SimInfoCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SimInfo
     */
    select?: SimInfoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SimInfoInclude<ExtArgs> | null
    /**
     * The data needed to create a SimInfo.
     */
    data: XOR<SimInfoCreateInput, SimInfoUncheckedCreateInput>
  }

  /**
   * SimInfo createMany
   */
  export type SimInfoCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many SimInfos.
     */
    data: SimInfoCreateManyInput | SimInfoCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * SimInfo createManyAndReturn
   */
  export type SimInfoCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SimInfo
     */
    select?: SimInfoSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many SimInfos.
     */
    data: SimInfoCreateManyInput | SimInfoCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * SimInfo update
   */
  export type SimInfoUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SimInfo
     */
    select?: SimInfoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SimInfoInclude<ExtArgs> | null
    /**
     * The data needed to update a SimInfo.
     */
    data: XOR<SimInfoUpdateInput, SimInfoUncheckedUpdateInput>
    /**
     * Choose, which SimInfo to update.
     */
    where: SimInfoWhereUniqueInput
  }

  /**
   * SimInfo updateMany
   */
  export type SimInfoUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update SimInfos.
     */
    data: XOR<SimInfoUpdateManyMutationInput, SimInfoUncheckedUpdateManyInput>
    /**
     * Filter which SimInfos to update
     */
    where?: SimInfoWhereInput
  }

  /**
   * SimInfo upsert
   */
  export type SimInfoUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SimInfo
     */
    select?: SimInfoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SimInfoInclude<ExtArgs> | null
    /**
     * The filter to search for the SimInfo to update in case it exists.
     */
    where: SimInfoWhereUniqueInput
    /**
     * In case the SimInfo found by the `where` argument doesn't exist, create a new SimInfo with this data.
     */
    create: XOR<SimInfoCreateInput, SimInfoUncheckedCreateInput>
    /**
     * In case the SimInfo was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SimInfoUpdateInput, SimInfoUncheckedUpdateInput>
  }

  /**
   * SimInfo delete
   */
  export type SimInfoDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SimInfo
     */
    select?: SimInfoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SimInfoInclude<ExtArgs> | null
    /**
     * Filter which SimInfo to delete.
     */
    where: SimInfoWhereUniqueInput
  }

  /**
   * SimInfo deleteMany
   */
  export type SimInfoDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SimInfos to delete
     */
    where?: SimInfoWhereInput
  }

  /**
   * SimInfo.devices
   */
  export type SimInfo$devicesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Device
     */
    select?: DeviceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeviceInclude<ExtArgs> | null
    where?: DeviceWhereInput
    orderBy?: DeviceOrderByWithRelationInput | DeviceOrderByWithRelationInput[]
    cursor?: DeviceWhereUniqueInput
    take?: number
    skip?: number
    distinct?: DeviceScalarFieldEnum | DeviceScalarFieldEnum[]
  }

  /**
   * SimInfo.simActions
   */
  export type SimInfo$simActionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SimAction
     */
    select?: SimActionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SimActionInclude<ExtArgs> | null
    where?: SimActionWhereInput
    orderBy?: SimActionOrderByWithRelationInput | SimActionOrderByWithRelationInput[]
    cursor?: SimActionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SimActionScalarFieldEnum | SimActionScalarFieldEnum[]
  }

  /**
   * SimInfo without action
   */
  export type SimInfoDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SimInfo
     */
    select?: SimInfoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SimInfoInclude<ExtArgs> | null
  }


  /**
   * Model SimAction
   */

  export type AggregateSimAction = {
    _count: SimActionCountAggregateOutputType | null
    _min: SimActionMinAggregateOutputType | null
    _max: SimActionMaxAggregateOutputType | null
  }

  export type SimActionMinAggregateOutputType = {
    id: string | null
    iccid: string | null
    action: $Enums.SimActionType | null
    requestedByUserId: string | null
    requestedAt: Date | null
    status: $Enums.SimActionStatus | null
    providerRef: string | null
    errorMsg: string | null
  }

  export type SimActionMaxAggregateOutputType = {
    id: string | null
    iccid: string | null
    action: $Enums.SimActionType | null
    requestedByUserId: string | null
    requestedAt: Date | null
    status: $Enums.SimActionStatus | null
    providerRef: string | null
    errorMsg: string | null
  }

  export type SimActionCountAggregateOutputType = {
    id: number
    iccid: number
    action: number
    requestedByUserId: number
    requestedAt: number
    status: number
    providerRef: number
    errorMsg: number
    _all: number
  }


  export type SimActionMinAggregateInputType = {
    id?: true
    iccid?: true
    action?: true
    requestedByUserId?: true
    requestedAt?: true
    status?: true
    providerRef?: true
    errorMsg?: true
  }

  export type SimActionMaxAggregateInputType = {
    id?: true
    iccid?: true
    action?: true
    requestedByUserId?: true
    requestedAt?: true
    status?: true
    providerRef?: true
    errorMsg?: true
  }

  export type SimActionCountAggregateInputType = {
    id?: true
    iccid?: true
    action?: true
    requestedByUserId?: true
    requestedAt?: true
    status?: true
    providerRef?: true
    errorMsg?: true
    _all?: true
  }

  export type SimActionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SimAction to aggregate.
     */
    where?: SimActionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SimActions to fetch.
     */
    orderBy?: SimActionOrderByWithRelationInput | SimActionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SimActionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SimActions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SimActions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned SimActions
    **/
    _count?: true | SimActionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SimActionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SimActionMaxAggregateInputType
  }

  export type GetSimActionAggregateType<T extends SimActionAggregateArgs> = {
        [P in keyof T & keyof AggregateSimAction]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSimAction[P]>
      : GetScalarType<T[P], AggregateSimAction[P]>
  }




  export type SimActionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SimActionWhereInput
    orderBy?: SimActionOrderByWithAggregationInput | SimActionOrderByWithAggregationInput[]
    by: SimActionScalarFieldEnum[] | SimActionScalarFieldEnum
    having?: SimActionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SimActionCountAggregateInputType | true
    _min?: SimActionMinAggregateInputType
    _max?: SimActionMaxAggregateInputType
  }

  export type SimActionGroupByOutputType = {
    id: string
    iccid: string
    action: $Enums.SimActionType
    requestedByUserId: string | null
    requestedAt: Date
    status: $Enums.SimActionStatus
    providerRef: string | null
    errorMsg: string | null
    _count: SimActionCountAggregateOutputType | null
    _min: SimActionMinAggregateOutputType | null
    _max: SimActionMaxAggregateOutputType | null
  }

  type GetSimActionGroupByPayload<T extends SimActionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SimActionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SimActionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SimActionGroupByOutputType[P]>
            : GetScalarType<T[P], SimActionGroupByOutputType[P]>
        }
      >
    >


  export type SimActionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    iccid?: boolean
    action?: boolean
    requestedByUserId?: boolean
    requestedAt?: boolean
    status?: boolean
    providerRef?: boolean
    errorMsg?: boolean
    sim?: boolean | SimInfoDefaultArgs<ExtArgs>
    requestedBy?: boolean | SimAction$requestedByArgs<ExtArgs>
  }, ExtArgs["result"]["simAction"]>

  export type SimActionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    iccid?: boolean
    action?: boolean
    requestedByUserId?: boolean
    requestedAt?: boolean
    status?: boolean
    providerRef?: boolean
    errorMsg?: boolean
    sim?: boolean | SimInfoDefaultArgs<ExtArgs>
    requestedBy?: boolean | SimAction$requestedByArgs<ExtArgs>
  }, ExtArgs["result"]["simAction"]>

  export type SimActionSelectScalar = {
    id?: boolean
    iccid?: boolean
    action?: boolean
    requestedByUserId?: boolean
    requestedAt?: boolean
    status?: boolean
    providerRef?: boolean
    errorMsg?: boolean
  }

  export type SimActionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    sim?: boolean | SimInfoDefaultArgs<ExtArgs>
    requestedBy?: boolean | SimAction$requestedByArgs<ExtArgs>
  }
  export type SimActionIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    sim?: boolean | SimInfoDefaultArgs<ExtArgs>
    requestedBy?: boolean | SimAction$requestedByArgs<ExtArgs>
  }

  export type $SimActionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "SimAction"
    objects: {
      sim: Prisma.$SimInfoPayload<ExtArgs>
      requestedBy: Prisma.$UserPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      iccid: string
      action: $Enums.SimActionType
      requestedByUserId: string | null
      requestedAt: Date
      status: $Enums.SimActionStatus
      providerRef: string | null
      errorMsg: string | null
    }, ExtArgs["result"]["simAction"]>
    composites: {}
  }

  type SimActionGetPayload<S extends boolean | null | undefined | SimActionDefaultArgs> = $Result.GetResult<Prisma.$SimActionPayload, S>

  type SimActionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<SimActionFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: SimActionCountAggregateInputType | true
    }

  export interface SimActionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['SimAction'], meta: { name: 'SimAction' } }
    /**
     * Find zero or one SimAction that matches the filter.
     * @param {SimActionFindUniqueArgs} args - Arguments to find a SimAction
     * @example
     * // Get one SimAction
     * const simAction = await prisma.simAction.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SimActionFindUniqueArgs>(args: SelectSubset<T, SimActionFindUniqueArgs<ExtArgs>>): Prisma__SimActionClient<$Result.GetResult<Prisma.$SimActionPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one SimAction that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {SimActionFindUniqueOrThrowArgs} args - Arguments to find a SimAction
     * @example
     * // Get one SimAction
     * const simAction = await prisma.simAction.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SimActionFindUniqueOrThrowArgs>(args: SelectSubset<T, SimActionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SimActionClient<$Result.GetResult<Prisma.$SimActionPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first SimAction that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SimActionFindFirstArgs} args - Arguments to find a SimAction
     * @example
     * // Get one SimAction
     * const simAction = await prisma.simAction.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SimActionFindFirstArgs>(args?: SelectSubset<T, SimActionFindFirstArgs<ExtArgs>>): Prisma__SimActionClient<$Result.GetResult<Prisma.$SimActionPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first SimAction that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SimActionFindFirstOrThrowArgs} args - Arguments to find a SimAction
     * @example
     * // Get one SimAction
     * const simAction = await prisma.simAction.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SimActionFindFirstOrThrowArgs>(args?: SelectSubset<T, SimActionFindFirstOrThrowArgs<ExtArgs>>): Prisma__SimActionClient<$Result.GetResult<Prisma.$SimActionPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more SimActions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SimActionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all SimActions
     * const simActions = await prisma.simAction.findMany()
     * 
     * // Get first 10 SimActions
     * const simActions = await prisma.simAction.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const simActionWithIdOnly = await prisma.simAction.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SimActionFindManyArgs>(args?: SelectSubset<T, SimActionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SimActionPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a SimAction.
     * @param {SimActionCreateArgs} args - Arguments to create a SimAction.
     * @example
     * // Create one SimAction
     * const SimAction = await prisma.simAction.create({
     *   data: {
     *     // ... data to create a SimAction
     *   }
     * })
     * 
     */
    create<T extends SimActionCreateArgs>(args: SelectSubset<T, SimActionCreateArgs<ExtArgs>>): Prisma__SimActionClient<$Result.GetResult<Prisma.$SimActionPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many SimActions.
     * @param {SimActionCreateManyArgs} args - Arguments to create many SimActions.
     * @example
     * // Create many SimActions
     * const simAction = await prisma.simAction.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SimActionCreateManyArgs>(args?: SelectSubset<T, SimActionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many SimActions and returns the data saved in the database.
     * @param {SimActionCreateManyAndReturnArgs} args - Arguments to create many SimActions.
     * @example
     * // Create many SimActions
     * const simAction = await prisma.simAction.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many SimActions and only return the `id`
     * const simActionWithIdOnly = await prisma.simAction.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends SimActionCreateManyAndReturnArgs>(args?: SelectSubset<T, SimActionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SimActionPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a SimAction.
     * @param {SimActionDeleteArgs} args - Arguments to delete one SimAction.
     * @example
     * // Delete one SimAction
     * const SimAction = await prisma.simAction.delete({
     *   where: {
     *     // ... filter to delete one SimAction
     *   }
     * })
     * 
     */
    delete<T extends SimActionDeleteArgs>(args: SelectSubset<T, SimActionDeleteArgs<ExtArgs>>): Prisma__SimActionClient<$Result.GetResult<Prisma.$SimActionPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one SimAction.
     * @param {SimActionUpdateArgs} args - Arguments to update one SimAction.
     * @example
     * // Update one SimAction
     * const simAction = await prisma.simAction.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SimActionUpdateArgs>(args: SelectSubset<T, SimActionUpdateArgs<ExtArgs>>): Prisma__SimActionClient<$Result.GetResult<Prisma.$SimActionPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more SimActions.
     * @param {SimActionDeleteManyArgs} args - Arguments to filter SimActions to delete.
     * @example
     * // Delete a few SimActions
     * const { count } = await prisma.simAction.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SimActionDeleteManyArgs>(args?: SelectSubset<T, SimActionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SimActions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SimActionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many SimActions
     * const simAction = await prisma.simAction.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SimActionUpdateManyArgs>(args: SelectSubset<T, SimActionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one SimAction.
     * @param {SimActionUpsertArgs} args - Arguments to update or create a SimAction.
     * @example
     * // Update or create a SimAction
     * const simAction = await prisma.simAction.upsert({
     *   create: {
     *     // ... data to create a SimAction
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the SimAction we want to update
     *   }
     * })
     */
    upsert<T extends SimActionUpsertArgs>(args: SelectSubset<T, SimActionUpsertArgs<ExtArgs>>): Prisma__SimActionClient<$Result.GetResult<Prisma.$SimActionPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of SimActions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SimActionCountArgs} args - Arguments to filter SimActions to count.
     * @example
     * // Count the number of SimActions
     * const count = await prisma.simAction.count({
     *   where: {
     *     // ... the filter for the SimActions we want to count
     *   }
     * })
    **/
    count<T extends SimActionCountArgs>(
      args?: Subset<T, SimActionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SimActionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a SimAction.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SimActionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SimActionAggregateArgs>(args: Subset<T, SimActionAggregateArgs>): Prisma.PrismaPromise<GetSimActionAggregateType<T>>

    /**
     * Group by SimAction.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SimActionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SimActionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SimActionGroupByArgs['orderBy'] }
        : { orderBy?: SimActionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SimActionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSimActionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the SimAction model
   */
  readonly fields: SimActionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for SimAction.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SimActionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    sim<T extends SimInfoDefaultArgs<ExtArgs> = {}>(args?: Subset<T, SimInfoDefaultArgs<ExtArgs>>): Prisma__SimInfoClient<$Result.GetResult<Prisma.$SimInfoPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    requestedBy<T extends SimAction$requestedByArgs<ExtArgs> = {}>(args?: Subset<T, SimAction$requestedByArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the SimAction model
   */ 
  interface SimActionFieldRefs {
    readonly id: FieldRef<"SimAction", 'String'>
    readonly iccid: FieldRef<"SimAction", 'String'>
    readonly action: FieldRef<"SimAction", 'SimActionType'>
    readonly requestedByUserId: FieldRef<"SimAction", 'String'>
    readonly requestedAt: FieldRef<"SimAction", 'DateTime'>
    readonly status: FieldRef<"SimAction", 'SimActionStatus'>
    readonly providerRef: FieldRef<"SimAction", 'String'>
    readonly errorMsg: FieldRef<"SimAction", 'String'>
  }
    

  // Custom InputTypes
  /**
   * SimAction findUnique
   */
  export type SimActionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SimAction
     */
    select?: SimActionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SimActionInclude<ExtArgs> | null
    /**
     * Filter, which SimAction to fetch.
     */
    where: SimActionWhereUniqueInput
  }

  /**
   * SimAction findUniqueOrThrow
   */
  export type SimActionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SimAction
     */
    select?: SimActionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SimActionInclude<ExtArgs> | null
    /**
     * Filter, which SimAction to fetch.
     */
    where: SimActionWhereUniqueInput
  }

  /**
   * SimAction findFirst
   */
  export type SimActionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SimAction
     */
    select?: SimActionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SimActionInclude<ExtArgs> | null
    /**
     * Filter, which SimAction to fetch.
     */
    where?: SimActionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SimActions to fetch.
     */
    orderBy?: SimActionOrderByWithRelationInput | SimActionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SimActions.
     */
    cursor?: SimActionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SimActions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SimActions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SimActions.
     */
    distinct?: SimActionScalarFieldEnum | SimActionScalarFieldEnum[]
  }

  /**
   * SimAction findFirstOrThrow
   */
  export type SimActionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SimAction
     */
    select?: SimActionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SimActionInclude<ExtArgs> | null
    /**
     * Filter, which SimAction to fetch.
     */
    where?: SimActionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SimActions to fetch.
     */
    orderBy?: SimActionOrderByWithRelationInput | SimActionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SimActions.
     */
    cursor?: SimActionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SimActions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SimActions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SimActions.
     */
    distinct?: SimActionScalarFieldEnum | SimActionScalarFieldEnum[]
  }

  /**
   * SimAction findMany
   */
  export type SimActionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SimAction
     */
    select?: SimActionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SimActionInclude<ExtArgs> | null
    /**
     * Filter, which SimActions to fetch.
     */
    where?: SimActionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SimActions to fetch.
     */
    orderBy?: SimActionOrderByWithRelationInput | SimActionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing SimActions.
     */
    cursor?: SimActionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SimActions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SimActions.
     */
    skip?: number
    distinct?: SimActionScalarFieldEnum | SimActionScalarFieldEnum[]
  }

  /**
   * SimAction create
   */
  export type SimActionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SimAction
     */
    select?: SimActionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SimActionInclude<ExtArgs> | null
    /**
     * The data needed to create a SimAction.
     */
    data: XOR<SimActionCreateInput, SimActionUncheckedCreateInput>
  }

  /**
   * SimAction createMany
   */
  export type SimActionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many SimActions.
     */
    data: SimActionCreateManyInput | SimActionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * SimAction createManyAndReturn
   */
  export type SimActionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SimAction
     */
    select?: SimActionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many SimActions.
     */
    data: SimActionCreateManyInput | SimActionCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SimActionIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * SimAction update
   */
  export type SimActionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SimAction
     */
    select?: SimActionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SimActionInclude<ExtArgs> | null
    /**
     * The data needed to update a SimAction.
     */
    data: XOR<SimActionUpdateInput, SimActionUncheckedUpdateInput>
    /**
     * Choose, which SimAction to update.
     */
    where: SimActionWhereUniqueInput
  }

  /**
   * SimAction updateMany
   */
  export type SimActionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update SimActions.
     */
    data: XOR<SimActionUpdateManyMutationInput, SimActionUncheckedUpdateManyInput>
    /**
     * Filter which SimActions to update
     */
    where?: SimActionWhereInput
  }

  /**
   * SimAction upsert
   */
  export type SimActionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SimAction
     */
    select?: SimActionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SimActionInclude<ExtArgs> | null
    /**
     * The filter to search for the SimAction to update in case it exists.
     */
    where: SimActionWhereUniqueInput
    /**
     * In case the SimAction found by the `where` argument doesn't exist, create a new SimAction with this data.
     */
    create: XOR<SimActionCreateInput, SimActionUncheckedCreateInput>
    /**
     * In case the SimAction was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SimActionUpdateInput, SimActionUncheckedUpdateInput>
  }

  /**
   * SimAction delete
   */
  export type SimActionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SimAction
     */
    select?: SimActionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SimActionInclude<ExtArgs> | null
    /**
     * Filter which SimAction to delete.
     */
    where: SimActionWhereUniqueInput
  }

  /**
   * SimAction deleteMany
   */
  export type SimActionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SimActions to delete
     */
    where?: SimActionWhereInput
  }

  /**
   * SimAction.requestedBy
   */
  export type SimAction$requestedByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * SimAction without action
   */
  export type SimActionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SimAction
     */
    select?: SimActionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SimActionInclude<ExtArgs> | null
  }


  /**
   * Model AlertRule
   */

  export type AggregateAlertRule = {
    _count: AlertRuleCountAggregateOutputType | null
    _min: AlertRuleMinAggregateOutputType | null
    _max: AlertRuleMaxAggregateOutputType | null
  }

  export type AlertRuleMinAggregateOutputType = {
    id: string | null
    tenantId: string | null
    name: string | null
    enabled: boolean | null
    type: $Enums.AlertRuleType | null
    severity: $Enums.AlertSeverity | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type AlertRuleMaxAggregateOutputType = {
    id: string | null
    tenantId: string | null
    name: string | null
    enabled: boolean | null
    type: $Enums.AlertRuleType | null
    severity: $Enums.AlertSeverity | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type AlertRuleCountAggregateOutputType = {
    id: number
    tenantId: number
    name: number
    enabled: number
    type: number
    params: number
    severity: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type AlertRuleMinAggregateInputType = {
    id?: true
    tenantId?: true
    name?: true
    enabled?: true
    type?: true
    severity?: true
    createdAt?: true
    updatedAt?: true
  }

  export type AlertRuleMaxAggregateInputType = {
    id?: true
    tenantId?: true
    name?: true
    enabled?: true
    type?: true
    severity?: true
    createdAt?: true
    updatedAt?: true
  }

  export type AlertRuleCountAggregateInputType = {
    id?: true
    tenantId?: true
    name?: true
    enabled?: true
    type?: true
    params?: true
    severity?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type AlertRuleAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AlertRule to aggregate.
     */
    where?: AlertRuleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AlertRules to fetch.
     */
    orderBy?: AlertRuleOrderByWithRelationInput | AlertRuleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AlertRuleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AlertRules from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AlertRules.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned AlertRules
    **/
    _count?: true | AlertRuleCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AlertRuleMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AlertRuleMaxAggregateInputType
  }

  export type GetAlertRuleAggregateType<T extends AlertRuleAggregateArgs> = {
        [P in keyof T & keyof AggregateAlertRule]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAlertRule[P]>
      : GetScalarType<T[P], AggregateAlertRule[P]>
  }




  export type AlertRuleGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AlertRuleWhereInput
    orderBy?: AlertRuleOrderByWithAggregationInput | AlertRuleOrderByWithAggregationInput[]
    by: AlertRuleScalarFieldEnum[] | AlertRuleScalarFieldEnum
    having?: AlertRuleScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AlertRuleCountAggregateInputType | true
    _min?: AlertRuleMinAggregateInputType
    _max?: AlertRuleMaxAggregateInputType
  }

  export type AlertRuleGroupByOutputType = {
    id: string
    tenantId: string
    name: string
    enabled: boolean
    type: $Enums.AlertRuleType
    params: JsonValue
    severity: $Enums.AlertSeverity
    createdAt: Date
    updatedAt: Date
    _count: AlertRuleCountAggregateOutputType | null
    _min: AlertRuleMinAggregateOutputType | null
    _max: AlertRuleMaxAggregateOutputType | null
  }

  type GetAlertRuleGroupByPayload<T extends AlertRuleGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AlertRuleGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AlertRuleGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AlertRuleGroupByOutputType[P]>
            : GetScalarType<T[P], AlertRuleGroupByOutputType[P]>
        }
      >
    >


  export type AlertRuleSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tenantId?: boolean
    name?: boolean
    enabled?: boolean
    type?: boolean
    params?: boolean
    severity?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
    alertEvents?: boolean | AlertRule$alertEventsArgs<ExtArgs>
    _count?: boolean | AlertRuleCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["alertRule"]>

  export type AlertRuleSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tenantId?: boolean
    name?: boolean
    enabled?: boolean
    type?: boolean
    params?: boolean
    severity?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["alertRule"]>

  export type AlertRuleSelectScalar = {
    id?: boolean
    tenantId?: boolean
    name?: boolean
    enabled?: boolean
    type?: boolean
    params?: boolean
    severity?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type AlertRuleInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
    alertEvents?: boolean | AlertRule$alertEventsArgs<ExtArgs>
    _count?: boolean | AlertRuleCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type AlertRuleIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
  }

  export type $AlertRulePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "AlertRule"
    objects: {
      tenant: Prisma.$TenantPayload<ExtArgs>
      alertEvents: Prisma.$AlertEventPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      tenantId: string
      name: string
      enabled: boolean
      type: $Enums.AlertRuleType
      params: Prisma.JsonValue
      severity: $Enums.AlertSeverity
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["alertRule"]>
    composites: {}
  }

  type AlertRuleGetPayload<S extends boolean | null | undefined | AlertRuleDefaultArgs> = $Result.GetResult<Prisma.$AlertRulePayload, S>

  type AlertRuleCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<AlertRuleFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: AlertRuleCountAggregateInputType | true
    }

  export interface AlertRuleDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['AlertRule'], meta: { name: 'AlertRule' } }
    /**
     * Find zero or one AlertRule that matches the filter.
     * @param {AlertRuleFindUniqueArgs} args - Arguments to find a AlertRule
     * @example
     * // Get one AlertRule
     * const alertRule = await prisma.alertRule.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AlertRuleFindUniqueArgs>(args: SelectSubset<T, AlertRuleFindUniqueArgs<ExtArgs>>): Prisma__AlertRuleClient<$Result.GetResult<Prisma.$AlertRulePayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one AlertRule that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {AlertRuleFindUniqueOrThrowArgs} args - Arguments to find a AlertRule
     * @example
     * // Get one AlertRule
     * const alertRule = await prisma.alertRule.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AlertRuleFindUniqueOrThrowArgs>(args: SelectSubset<T, AlertRuleFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AlertRuleClient<$Result.GetResult<Prisma.$AlertRulePayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first AlertRule that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AlertRuleFindFirstArgs} args - Arguments to find a AlertRule
     * @example
     * // Get one AlertRule
     * const alertRule = await prisma.alertRule.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AlertRuleFindFirstArgs>(args?: SelectSubset<T, AlertRuleFindFirstArgs<ExtArgs>>): Prisma__AlertRuleClient<$Result.GetResult<Prisma.$AlertRulePayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first AlertRule that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AlertRuleFindFirstOrThrowArgs} args - Arguments to find a AlertRule
     * @example
     * // Get one AlertRule
     * const alertRule = await prisma.alertRule.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AlertRuleFindFirstOrThrowArgs>(args?: SelectSubset<T, AlertRuleFindFirstOrThrowArgs<ExtArgs>>): Prisma__AlertRuleClient<$Result.GetResult<Prisma.$AlertRulePayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more AlertRules that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AlertRuleFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all AlertRules
     * const alertRules = await prisma.alertRule.findMany()
     * 
     * // Get first 10 AlertRules
     * const alertRules = await prisma.alertRule.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const alertRuleWithIdOnly = await prisma.alertRule.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AlertRuleFindManyArgs>(args?: SelectSubset<T, AlertRuleFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AlertRulePayload<ExtArgs>, T, "findMany">>

    /**
     * Create a AlertRule.
     * @param {AlertRuleCreateArgs} args - Arguments to create a AlertRule.
     * @example
     * // Create one AlertRule
     * const AlertRule = await prisma.alertRule.create({
     *   data: {
     *     // ... data to create a AlertRule
     *   }
     * })
     * 
     */
    create<T extends AlertRuleCreateArgs>(args: SelectSubset<T, AlertRuleCreateArgs<ExtArgs>>): Prisma__AlertRuleClient<$Result.GetResult<Prisma.$AlertRulePayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many AlertRules.
     * @param {AlertRuleCreateManyArgs} args - Arguments to create many AlertRules.
     * @example
     * // Create many AlertRules
     * const alertRule = await prisma.alertRule.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AlertRuleCreateManyArgs>(args?: SelectSubset<T, AlertRuleCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many AlertRules and returns the data saved in the database.
     * @param {AlertRuleCreateManyAndReturnArgs} args - Arguments to create many AlertRules.
     * @example
     * // Create many AlertRules
     * const alertRule = await prisma.alertRule.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many AlertRules and only return the `id`
     * const alertRuleWithIdOnly = await prisma.alertRule.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AlertRuleCreateManyAndReturnArgs>(args?: SelectSubset<T, AlertRuleCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AlertRulePayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a AlertRule.
     * @param {AlertRuleDeleteArgs} args - Arguments to delete one AlertRule.
     * @example
     * // Delete one AlertRule
     * const AlertRule = await prisma.alertRule.delete({
     *   where: {
     *     // ... filter to delete one AlertRule
     *   }
     * })
     * 
     */
    delete<T extends AlertRuleDeleteArgs>(args: SelectSubset<T, AlertRuleDeleteArgs<ExtArgs>>): Prisma__AlertRuleClient<$Result.GetResult<Prisma.$AlertRulePayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one AlertRule.
     * @param {AlertRuleUpdateArgs} args - Arguments to update one AlertRule.
     * @example
     * // Update one AlertRule
     * const alertRule = await prisma.alertRule.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AlertRuleUpdateArgs>(args: SelectSubset<T, AlertRuleUpdateArgs<ExtArgs>>): Prisma__AlertRuleClient<$Result.GetResult<Prisma.$AlertRulePayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more AlertRules.
     * @param {AlertRuleDeleteManyArgs} args - Arguments to filter AlertRules to delete.
     * @example
     * // Delete a few AlertRules
     * const { count } = await prisma.alertRule.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AlertRuleDeleteManyArgs>(args?: SelectSubset<T, AlertRuleDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AlertRules.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AlertRuleUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many AlertRules
     * const alertRule = await prisma.alertRule.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AlertRuleUpdateManyArgs>(args: SelectSubset<T, AlertRuleUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one AlertRule.
     * @param {AlertRuleUpsertArgs} args - Arguments to update or create a AlertRule.
     * @example
     * // Update or create a AlertRule
     * const alertRule = await prisma.alertRule.upsert({
     *   create: {
     *     // ... data to create a AlertRule
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the AlertRule we want to update
     *   }
     * })
     */
    upsert<T extends AlertRuleUpsertArgs>(args: SelectSubset<T, AlertRuleUpsertArgs<ExtArgs>>): Prisma__AlertRuleClient<$Result.GetResult<Prisma.$AlertRulePayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of AlertRules.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AlertRuleCountArgs} args - Arguments to filter AlertRules to count.
     * @example
     * // Count the number of AlertRules
     * const count = await prisma.alertRule.count({
     *   where: {
     *     // ... the filter for the AlertRules we want to count
     *   }
     * })
    **/
    count<T extends AlertRuleCountArgs>(
      args?: Subset<T, AlertRuleCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AlertRuleCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a AlertRule.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AlertRuleAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AlertRuleAggregateArgs>(args: Subset<T, AlertRuleAggregateArgs>): Prisma.PrismaPromise<GetAlertRuleAggregateType<T>>

    /**
     * Group by AlertRule.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AlertRuleGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AlertRuleGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AlertRuleGroupByArgs['orderBy'] }
        : { orderBy?: AlertRuleGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AlertRuleGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAlertRuleGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the AlertRule model
   */
  readonly fields: AlertRuleFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for AlertRule.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AlertRuleClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    tenant<T extends TenantDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TenantDefaultArgs<ExtArgs>>): Prisma__TenantClient<$Result.GetResult<Prisma.$TenantPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    alertEvents<T extends AlertRule$alertEventsArgs<ExtArgs> = {}>(args?: Subset<T, AlertRule$alertEventsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AlertEventPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the AlertRule model
   */ 
  interface AlertRuleFieldRefs {
    readonly id: FieldRef<"AlertRule", 'String'>
    readonly tenantId: FieldRef<"AlertRule", 'String'>
    readonly name: FieldRef<"AlertRule", 'String'>
    readonly enabled: FieldRef<"AlertRule", 'Boolean'>
    readonly type: FieldRef<"AlertRule", 'AlertRuleType'>
    readonly params: FieldRef<"AlertRule", 'Json'>
    readonly severity: FieldRef<"AlertRule", 'AlertSeverity'>
    readonly createdAt: FieldRef<"AlertRule", 'DateTime'>
    readonly updatedAt: FieldRef<"AlertRule", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * AlertRule findUnique
   */
  export type AlertRuleFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AlertRule
     */
    select?: AlertRuleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AlertRuleInclude<ExtArgs> | null
    /**
     * Filter, which AlertRule to fetch.
     */
    where: AlertRuleWhereUniqueInput
  }

  /**
   * AlertRule findUniqueOrThrow
   */
  export type AlertRuleFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AlertRule
     */
    select?: AlertRuleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AlertRuleInclude<ExtArgs> | null
    /**
     * Filter, which AlertRule to fetch.
     */
    where: AlertRuleWhereUniqueInput
  }

  /**
   * AlertRule findFirst
   */
  export type AlertRuleFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AlertRule
     */
    select?: AlertRuleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AlertRuleInclude<ExtArgs> | null
    /**
     * Filter, which AlertRule to fetch.
     */
    where?: AlertRuleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AlertRules to fetch.
     */
    orderBy?: AlertRuleOrderByWithRelationInput | AlertRuleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AlertRules.
     */
    cursor?: AlertRuleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AlertRules from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AlertRules.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AlertRules.
     */
    distinct?: AlertRuleScalarFieldEnum | AlertRuleScalarFieldEnum[]
  }

  /**
   * AlertRule findFirstOrThrow
   */
  export type AlertRuleFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AlertRule
     */
    select?: AlertRuleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AlertRuleInclude<ExtArgs> | null
    /**
     * Filter, which AlertRule to fetch.
     */
    where?: AlertRuleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AlertRules to fetch.
     */
    orderBy?: AlertRuleOrderByWithRelationInput | AlertRuleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AlertRules.
     */
    cursor?: AlertRuleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AlertRules from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AlertRules.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AlertRules.
     */
    distinct?: AlertRuleScalarFieldEnum | AlertRuleScalarFieldEnum[]
  }

  /**
   * AlertRule findMany
   */
  export type AlertRuleFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AlertRule
     */
    select?: AlertRuleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AlertRuleInclude<ExtArgs> | null
    /**
     * Filter, which AlertRules to fetch.
     */
    where?: AlertRuleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AlertRules to fetch.
     */
    orderBy?: AlertRuleOrderByWithRelationInput | AlertRuleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing AlertRules.
     */
    cursor?: AlertRuleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AlertRules from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AlertRules.
     */
    skip?: number
    distinct?: AlertRuleScalarFieldEnum | AlertRuleScalarFieldEnum[]
  }

  /**
   * AlertRule create
   */
  export type AlertRuleCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AlertRule
     */
    select?: AlertRuleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AlertRuleInclude<ExtArgs> | null
    /**
     * The data needed to create a AlertRule.
     */
    data: XOR<AlertRuleCreateInput, AlertRuleUncheckedCreateInput>
  }

  /**
   * AlertRule createMany
   */
  export type AlertRuleCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many AlertRules.
     */
    data: AlertRuleCreateManyInput | AlertRuleCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * AlertRule createManyAndReturn
   */
  export type AlertRuleCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AlertRule
     */
    select?: AlertRuleSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many AlertRules.
     */
    data: AlertRuleCreateManyInput | AlertRuleCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AlertRuleIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * AlertRule update
   */
  export type AlertRuleUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AlertRule
     */
    select?: AlertRuleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AlertRuleInclude<ExtArgs> | null
    /**
     * The data needed to update a AlertRule.
     */
    data: XOR<AlertRuleUpdateInput, AlertRuleUncheckedUpdateInput>
    /**
     * Choose, which AlertRule to update.
     */
    where: AlertRuleWhereUniqueInput
  }

  /**
   * AlertRule updateMany
   */
  export type AlertRuleUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update AlertRules.
     */
    data: XOR<AlertRuleUpdateManyMutationInput, AlertRuleUncheckedUpdateManyInput>
    /**
     * Filter which AlertRules to update
     */
    where?: AlertRuleWhereInput
  }

  /**
   * AlertRule upsert
   */
  export type AlertRuleUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AlertRule
     */
    select?: AlertRuleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AlertRuleInclude<ExtArgs> | null
    /**
     * The filter to search for the AlertRule to update in case it exists.
     */
    where: AlertRuleWhereUniqueInput
    /**
     * In case the AlertRule found by the `where` argument doesn't exist, create a new AlertRule with this data.
     */
    create: XOR<AlertRuleCreateInput, AlertRuleUncheckedCreateInput>
    /**
     * In case the AlertRule was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AlertRuleUpdateInput, AlertRuleUncheckedUpdateInput>
  }

  /**
   * AlertRule delete
   */
  export type AlertRuleDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AlertRule
     */
    select?: AlertRuleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AlertRuleInclude<ExtArgs> | null
    /**
     * Filter which AlertRule to delete.
     */
    where: AlertRuleWhereUniqueInput
  }

  /**
   * AlertRule deleteMany
   */
  export type AlertRuleDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AlertRules to delete
     */
    where?: AlertRuleWhereInput
  }

  /**
   * AlertRule.alertEvents
   */
  export type AlertRule$alertEventsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AlertEvent
     */
    select?: AlertEventSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AlertEventInclude<ExtArgs> | null
    where?: AlertEventWhereInput
    orderBy?: AlertEventOrderByWithRelationInput | AlertEventOrderByWithRelationInput[]
    cursor?: AlertEventWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AlertEventScalarFieldEnum | AlertEventScalarFieldEnum[]
  }

  /**
   * AlertRule without action
   */
  export type AlertRuleDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AlertRule
     */
    select?: AlertRuleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AlertRuleInclude<ExtArgs> | null
  }


  /**
   * Model AlertEvent
   */

  export type AggregateAlertEvent = {
    _count: AlertEventCountAggregateOutputType | null
    _min: AlertEventMinAggregateOutputType | null
    _max: AlertEventMaxAggregateOutputType | null
  }

  export type AlertEventMinAggregateOutputType = {
    id: string | null
    tenantId: string | null
    deviceId: string | null
    ruleId: string | null
    severity: $Enums.AlertSeverity | null
    status: $Enums.AlertEventStatus | null
    openedAt: Date | null
    acknowledgedAt: Date | null
    closedAt: Date | null
    dedupeKey: string | null
  }

  export type AlertEventMaxAggregateOutputType = {
    id: string | null
    tenantId: string | null
    deviceId: string | null
    ruleId: string | null
    severity: $Enums.AlertSeverity | null
    status: $Enums.AlertEventStatus | null
    openedAt: Date | null
    acknowledgedAt: Date | null
    closedAt: Date | null
    dedupeKey: string | null
  }

  export type AlertEventCountAggregateOutputType = {
    id: number
    tenantId: number
    deviceId: number
    ruleId: number
    severity: number
    status: number
    openedAt: number
    acknowledgedAt: number
    closedAt: number
    details: number
    dedupeKey: number
    _all: number
  }


  export type AlertEventMinAggregateInputType = {
    id?: true
    tenantId?: true
    deviceId?: true
    ruleId?: true
    severity?: true
    status?: true
    openedAt?: true
    acknowledgedAt?: true
    closedAt?: true
    dedupeKey?: true
  }

  export type AlertEventMaxAggregateInputType = {
    id?: true
    tenantId?: true
    deviceId?: true
    ruleId?: true
    severity?: true
    status?: true
    openedAt?: true
    acknowledgedAt?: true
    closedAt?: true
    dedupeKey?: true
  }

  export type AlertEventCountAggregateInputType = {
    id?: true
    tenantId?: true
    deviceId?: true
    ruleId?: true
    severity?: true
    status?: true
    openedAt?: true
    acknowledgedAt?: true
    closedAt?: true
    details?: true
    dedupeKey?: true
    _all?: true
  }

  export type AlertEventAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AlertEvent to aggregate.
     */
    where?: AlertEventWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AlertEvents to fetch.
     */
    orderBy?: AlertEventOrderByWithRelationInput | AlertEventOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AlertEventWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AlertEvents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AlertEvents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned AlertEvents
    **/
    _count?: true | AlertEventCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AlertEventMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AlertEventMaxAggregateInputType
  }

  export type GetAlertEventAggregateType<T extends AlertEventAggregateArgs> = {
        [P in keyof T & keyof AggregateAlertEvent]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAlertEvent[P]>
      : GetScalarType<T[P], AggregateAlertEvent[P]>
  }




  export type AlertEventGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AlertEventWhereInput
    orderBy?: AlertEventOrderByWithAggregationInput | AlertEventOrderByWithAggregationInput[]
    by: AlertEventScalarFieldEnum[] | AlertEventScalarFieldEnum
    having?: AlertEventScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AlertEventCountAggregateInputType | true
    _min?: AlertEventMinAggregateInputType
    _max?: AlertEventMaxAggregateInputType
  }

  export type AlertEventGroupByOutputType = {
    id: string
    tenantId: string
    deviceId: string
    ruleId: string
    severity: $Enums.AlertSeverity
    status: $Enums.AlertEventStatus
    openedAt: Date
    acknowledgedAt: Date | null
    closedAt: Date | null
    details: JsonValue | null
    dedupeKey: string | null
    _count: AlertEventCountAggregateOutputType | null
    _min: AlertEventMinAggregateOutputType | null
    _max: AlertEventMaxAggregateOutputType | null
  }

  type GetAlertEventGroupByPayload<T extends AlertEventGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AlertEventGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AlertEventGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AlertEventGroupByOutputType[P]>
            : GetScalarType<T[P], AlertEventGroupByOutputType[P]>
        }
      >
    >


  export type AlertEventSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tenantId?: boolean
    deviceId?: boolean
    ruleId?: boolean
    severity?: boolean
    status?: boolean
    openedAt?: boolean
    acknowledgedAt?: boolean
    closedAt?: boolean
    details?: boolean
    dedupeKey?: boolean
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
    device?: boolean | DeviceDefaultArgs<ExtArgs>
    rule?: boolean | AlertRuleDefaultArgs<ExtArgs>
    notificationEvents?: boolean | AlertEvent$notificationEventsArgs<ExtArgs>
    _count?: boolean | AlertEventCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["alertEvent"]>

  export type AlertEventSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tenantId?: boolean
    deviceId?: boolean
    ruleId?: boolean
    severity?: boolean
    status?: boolean
    openedAt?: boolean
    acknowledgedAt?: boolean
    closedAt?: boolean
    details?: boolean
    dedupeKey?: boolean
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
    device?: boolean | DeviceDefaultArgs<ExtArgs>
    rule?: boolean | AlertRuleDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["alertEvent"]>

  export type AlertEventSelectScalar = {
    id?: boolean
    tenantId?: boolean
    deviceId?: boolean
    ruleId?: boolean
    severity?: boolean
    status?: boolean
    openedAt?: boolean
    acknowledgedAt?: boolean
    closedAt?: boolean
    details?: boolean
    dedupeKey?: boolean
  }

  export type AlertEventInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
    device?: boolean | DeviceDefaultArgs<ExtArgs>
    rule?: boolean | AlertRuleDefaultArgs<ExtArgs>
    notificationEvents?: boolean | AlertEvent$notificationEventsArgs<ExtArgs>
    _count?: boolean | AlertEventCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type AlertEventIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
    device?: boolean | DeviceDefaultArgs<ExtArgs>
    rule?: boolean | AlertRuleDefaultArgs<ExtArgs>
  }

  export type $AlertEventPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "AlertEvent"
    objects: {
      tenant: Prisma.$TenantPayload<ExtArgs>
      device: Prisma.$DevicePayload<ExtArgs>
      rule: Prisma.$AlertRulePayload<ExtArgs>
      notificationEvents: Prisma.$NotificationEventPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      tenantId: string
      deviceId: string
      ruleId: string
      severity: $Enums.AlertSeverity
      status: $Enums.AlertEventStatus
      openedAt: Date
      acknowledgedAt: Date | null
      closedAt: Date | null
      details: Prisma.JsonValue | null
      dedupeKey: string | null
    }, ExtArgs["result"]["alertEvent"]>
    composites: {}
  }

  type AlertEventGetPayload<S extends boolean | null | undefined | AlertEventDefaultArgs> = $Result.GetResult<Prisma.$AlertEventPayload, S>

  type AlertEventCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<AlertEventFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: AlertEventCountAggregateInputType | true
    }

  export interface AlertEventDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['AlertEvent'], meta: { name: 'AlertEvent' } }
    /**
     * Find zero or one AlertEvent that matches the filter.
     * @param {AlertEventFindUniqueArgs} args - Arguments to find a AlertEvent
     * @example
     * // Get one AlertEvent
     * const alertEvent = await prisma.alertEvent.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AlertEventFindUniqueArgs>(args: SelectSubset<T, AlertEventFindUniqueArgs<ExtArgs>>): Prisma__AlertEventClient<$Result.GetResult<Prisma.$AlertEventPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one AlertEvent that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {AlertEventFindUniqueOrThrowArgs} args - Arguments to find a AlertEvent
     * @example
     * // Get one AlertEvent
     * const alertEvent = await prisma.alertEvent.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AlertEventFindUniqueOrThrowArgs>(args: SelectSubset<T, AlertEventFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AlertEventClient<$Result.GetResult<Prisma.$AlertEventPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first AlertEvent that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AlertEventFindFirstArgs} args - Arguments to find a AlertEvent
     * @example
     * // Get one AlertEvent
     * const alertEvent = await prisma.alertEvent.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AlertEventFindFirstArgs>(args?: SelectSubset<T, AlertEventFindFirstArgs<ExtArgs>>): Prisma__AlertEventClient<$Result.GetResult<Prisma.$AlertEventPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first AlertEvent that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AlertEventFindFirstOrThrowArgs} args - Arguments to find a AlertEvent
     * @example
     * // Get one AlertEvent
     * const alertEvent = await prisma.alertEvent.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AlertEventFindFirstOrThrowArgs>(args?: SelectSubset<T, AlertEventFindFirstOrThrowArgs<ExtArgs>>): Prisma__AlertEventClient<$Result.GetResult<Prisma.$AlertEventPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more AlertEvents that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AlertEventFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all AlertEvents
     * const alertEvents = await prisma.alertEvent.findMany()
     * 
     * // Get first 10 AlertEvents
     * const alertEvents = await prisma.alertEvent.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const alertEventWithIdOnly = await prisma.alertEvent.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AlertEventFindManyArgs>(args?: SelectSubset<T, AlertEventFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AlertEventPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a AlertEvent.
     * @param {AlertEventCreateArgs} args - Arguments to create a AlertEvent.
     * @example
     * // Create one AlertEvent
     * const AlertEvent = await prisma.alertEvent.create({
     *   data: {
     *     // ... data to create a AlertEvent
     *   }
     * })
     * 
     */
    create<T extends AlertEventCreateArgs>(args: SelectSubset<T, AlertEventCreateArgs<ExtArgs>>): Prisma__AlertEventClient<$Result.GetResult<Prisma.$AlertEventPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many AlertEvents.
     * @param {AlertEventCreateManyArgs} args - Arguments to create many AlertEvents.
     * @example
     * // Create many AlertEvents
     * const alertEvent = await prisma.alertEvent.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AlertEventCreateManyArgs>(args?: SelectSubset<T, AlertEventCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many AlertEvents and returns the data saved in the database.
     * @param {AlertEventCreateManyAndReturnArgs} args - Arguments to create many AlertEvents.
     * @example
     * // Create many AlertEvents
     * const alertEvent = await prisma.alertEvent.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many AlertEvents and only return the `id`
     * const alertEventWithIdOnly = await prisma.alertEvent.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AlertEventCreateManyAndReturnArgs>(args?: SelectSubset<T, AlertEventCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AlertEventPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a AlertEvent.
     * @param {AlertEventDeleteArgs} args - Arguments to delete one AlertEvent.
     * @example
     * // Delete one AlertEvent
     * const AlertEvent = await prisma.alertEvent.delete({
     *   where: {
     *     // ... filter to delete one AlertEvent
     *   }
     * })
     * 
     */
    delete<T extends AlertEventDeleteArgs>(args: SelectSubset<T, AlertEventDeleteArgs<ExtArgs>>): Prisma__AlertEventClient<$Result.GetResult<Prisma.$AlertEventPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one AlertEvent.
     * @param {AlertEventUpdateArgs} args - Arguments to update one AlertEvent.
     * @example
     * // Update one AlertEvent
     * const alertEvent = await prisma.alertEvent.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AlertEventUpdateArgs>(args: SelectSubset<T, AlertEventUpdateArgs<ExtArgs>>): Prisma__AlertEventClient<$Result.GetResult<Prisma.$AlertEventPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more AlertEvents.
     * @param {AlertEventDeleteManyArgs} args - Arguments to filter AlertEvents to delete.
     * @example
     * // Delete a few AlertEvents
     * const { count } = await prisma.alertEvent.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AlertEventDeleteManyArgs>(args?: SelectSubset<T, AlertEventDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AlertEvents.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AlertEventUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many AlertEvents
     * const alertEvent = await prisma.alertEvent.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AlertEventUpdateManyArgs>(args: SelectSubset<T, AlertEventUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one AlertEvent.
     * @param {AlertEventUpsertArgs} args - Arguments to update or create a AlertEvent.
     * @example
     * // Update or create a AlertEvent
     * const alertEvent = await prisma.alertEvent.upsert({
     *   create: {
     *     // ... data to create a AlertEvent
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the AlertEvent we want to update
     *   }
     * })
     */
    upsert<T extends AlertEventUpsertArgs>(args: SelectSubset<T, AlertEventUpsertArgs<ExtArgs>>): Prisma__AlertEventClient<$Result.GetResult<Prisma.$AlertEventPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of AlertEvents.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AlertEventCountArgs} args - Arguments to filter AlertEvents to count.
     * @example
     * // Count the number of AlertEvents
     * const count = await prisma.alertEvent.count({
     *   where: {
     *     // ... the filter for the AlertEvents we want to count
     *   }
     * })
    **/
    count<T extends AlertEventCountArgs>(
      args?: Subset<T, AlertEventCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AlertEventCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a AlertEvent.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AlertEventAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AlertEventAggregateArgs>(args: Subset<T, AlertEventAggregateArgs>): Prisma.PrismaPromise<GetAlertEventAggregateType<T>>

    /**
     * Group by AlertEvent.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AlertEventGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AlertEventGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AlertEventGroupByArgs['orderBy'] }
        : { orderBy?: AlertEventGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AlertEventGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAlertEventGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the AlertEvent model
   */
  readonly fields: AlertEventFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for AlertEvent.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AlertEventClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    tenant<T extends TenantDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TenantDefaultArgs<ExtArgs>>): Prisma__TenantClient<$Result.GetResult<Prisma.$TenantPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    device<T extends DeviceDefaultArgs<ExtArgs> = {}>(args?: Subset<T, DeviceDefaultArgs<ExtArgs>>): Prisma__DeviceClient<$Result.GetResult<Prisma.$DevicePayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    rule<T extends AlertRuleDefaultArgs<ExtArgs> = {}>(args?: Subset<T, AlertRuleDefaultArgs<ExtArgs>>): Prisma__AlertRuleClient<$Result.GetResult<Prisma.$AlertRulePayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    notificationEvents<T extends AlertEvent$notificationEventsArgs<ExtArgs> = {}>(args?: Subset<T, AlertEvent$notificationEventsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NotificationEventPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the AlertEvent model
   */ 
  interface AlertEventFieldRefs {
    readonly id: FieldRef<"AlertEvent", 'String'>
    readonly tenantId: FieldRef<"AlertEvent", 'String'>
    readonly deviceId: FieldRef<"AlertEvent", 'String'>
    readonly ruleId: FieldRef<"AlertEvent", 'String'>
    readonly severity: FieldRef<"AlertEvent", 'AlertSeverity'>
    readonly status: FieldRef<"AlertEvent", 'AlertEventStatus'>
    readonly openedAt: FieldRef<"AlertEvent", 'DateTime'>
    readonly acknowledgedAt: FieldRef<"AlertEvent", 'DateTime'>
    readonly closedAt: FieldRef<"AlertEvent", 'DateTime'>
    readonly details: FieldRef<"AlertEvent", 'Json'>
    readonly dedupeKey: FieldRef<"AlertEvent", 'String'>
  }
    

  // Custom InputTypes
  /**
   * AlertEvent findUnique
   */
  export type AlertEventFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AlertEvent
     */
    select?: AlertEventSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AlertEventInclude<ExtArgs> | null
    /**
     * Filter, which AlertEvent to fetch.
     */
    where: AlertEventWhereUniqueInput
  }

  /**
   * AlertEvent findUniqueOrThrow
   */
  export type AlertEventFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AlertEvent
     */
    select?: AlertEventSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AlertEventInclude<ExtArgs> | null
    /**
     * Filter, which AlertEvent to fetch.
     */
    where: AlertEventWhereUniqueInput
  }

  /**
   * AlertEvent findFirst
   */
  export type AlertEventFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AlertEvent
     */
    select?: AlertEventSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AlertEventInclude<ExtArgs> | null
    /**
     * Filter, which AlertEvent to fetch.
     */
    where?: AlertEventWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AlertEvents to fetch.
     */
    orderBy?: AlertEventOrderByWithRelationInput | AlertEventOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AlertEvents.
     */
    cursor?: AlertEventWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AlertEvents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AlertEvents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AlertEvents.
     */
    distinct?: AlertEventScalarFieldEnum | AlertEventScalarFieldEnum[]
  }

  /**
   * AlertEvent findFirstOrThrow
   */
  export type AlertEventFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AlertEvent
     */
    select?: AlertEventSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AlertEventInclude<ExtArgs> | null
    /**
     * Filter, which AlertEvent to fetch.
     */
    where?: AlertEventWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AlertEvents to fetch.
     */
    orderBy?: AlertEventOrderByWithRelationInput | AlertEventOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AlertEvents.
     */
    cursor?: AlertEventWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AlertEvents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AlertEvents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AlertEvents.
     */
    distinct?: AlertEventScalarFieldEnum | AlertEventScalarFieldEnum[]
  }

  /**
   * AlertEvent findMany
   */
  export type AlertEventFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AlertEvent
     */
    select?: AlertEventSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AlertEventInclude<ExtArgs> | null
    /**
     * Filter, which AlertEvents to fetch.
     */
    where?: AlertEventWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AlertEvents to fetch.
     */
    orderBy?: AlertEventOrderByWithRelationInput | AlertEventOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing AlertEvents.
     */
    cursor?: AlertEventWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AlertEvents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AlertEvents.
     */
    skip?: number
    distinct?: AlertEventScalarFieldEnum | AlertEventScalarFieldEnum[]
  }

  /**
   * AlertEvent create
   */
  export type AlertEventCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AlertEvent
     */
    select?: AlertEventSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AlertEventInclude<ExtArgs> | null
    /**
     * The data needed to create a AlertEvent.
     */
    data: XOR<AlertEventCreateInput, AlertEventUncheckedCreateInput>
  }

  /**
   * AlertEvent createMany
   */
  export type AlertEventCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many AlertEvents.
     */
    data: AlertEventCreateManyInput | AlertEventCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * AlertEvent createManyAndReturn
   */
  export type AlertEventCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AlertEvent
     */
    select?: AlertEventSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many AlertEvents.
     */
    data: AlertEventCreateManyInput | AlertEventCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AlertEventIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * AlertEvent update
   */
  export type AlertEventUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AlertEvent
     */
    select?: AlertEventSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AlertEventInclude<ExtArgs> | null
    /**
     * The data needed to update a AlertEvent.
     */
    data: XOR<AlertEventUpdateInput, AlertEventUncheckedUpdateInput>
    /**
     * Choose, which AlertEvent to update.
     */
    where: AlertEventWhereUniqueInput
  }

  /**
   * AlertEvent updateMany
   */
  export type AlertEventUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update AlertEvents.
     */
    data: XOR<AlertEventUpdateManyMutationInput, AlertEventUncheckedUpdateManyInput>
    /**
     * Filter which AlertEvents to update
     */
    where?: AlertEventWhereInput
  }

  /**
   * AlertEvent upsert
   */
  export type AlertEventUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AlertEvent
     */
    select?: AlertEventSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AlertEventInclude<ExtArgs> | null
    /**
     * The filter to search for the AlertEvent to update in case it exists.
     */
    where: AlertEventWhereUniqueInput
    /**
     * In case the AlertEvent found by the `where` argument doesn't exist, create a new AlertEvent with this data.
     */
    create: XOR<AlertEventCreateInput, AlertEventUncheckedCreateInput>
    /**
     * In case the AlertEvent was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AlertEventUpdateInput, AlertEventUncheckedUpdateInput>
  }

  /**
   * AlertEvent delete
   */
  export type AlertEventDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AlertEvent
     */
    select?: AlertEventSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AlertEventInclude<ExtArgs> | null
    /**
     * Filter which AlertEvent to delete.
     */
    where: AlertEventWhereUniqueInput
  }

  /**
   * AlertEvent deleteMany
   */
  export type AlertEventDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AlertEvents to delete
     */
    where?: AlertEventWhereInput
  }

  /**
   * AlertEvent.notificationEvents
   */
  export type AlertEvent$notificationEventsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NotificationEvent
     */
    select?: NotificationEventSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationEventInclude<ExtArgs> | null
    where?: NotificationEventWhereInput
    orderBy?: NotificationEventOrderByWithRelationInput | NotificationEventOrderByWithRelationInput[]
    cursor?: NotificationEventWhereUniqueInput
    take?: number
    skip?: number
    distinct?: NotificationEventScalarFieldEnum | NotificationEventScalarFieldEnum[]
  }

  /**
   * AlertEvent without action
   */
  export type AlertEventDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AlertEvent
     */
    select?: AlertEventSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AlertEventInclude<ExtArgs> | null
  }


  /**
   * Model NotificationChannel
   */

  export type AggregateNotificationChannel = {
    _count: NotificationChannelCountAggregateOutputType | null
    _min: NotificationChannelMinAggregateOutputType | null
    _max: NotificationChannelMaxAggregateOutputType | null
  }

  export type NotificationChannelMinAggregateOutputType = {
    id: string | null
    tenantId: string | null
    type: $Enums.NotificationChannelType | null
    enabled: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type NotificationChannelMaxAggregateOutputType = {
    id: string | null
    tenantId: string | null
    type: $Enums.NotificationChannelType | null
    enabled: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type NotificationChannelCountAggregateOutputType = {
    id: number
    tenantId: number
    type: number
    config: number
    enabled: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type NotificationChannelMinAggregateInputType = {
    id?: true
    tenantId?: true
    type?: true
    enabled?: true
    createdAt?: true
    updatedAt?: true
  }

  export type NotificationChannelMaxAggregateInputType = {
    id?: true
    tenantId?: true
    type?: true
    enabled?: true
    createdAt?: true
    updatedAt?: true
  }

  export type NotificationChannelCountAggregateInputType = {
    id?: true
    tenantId?: true
    type?: true
    config?: true
    enabled?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type NotificationChannelAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which NotificationChannel to aggregate.
     */
    where?: NotificationChannelWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of NotificationChannels to fetch.
     */
    orderBy?: NotificationChannelOrderByWithRelationInput | NotificationChannelOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: NotificationChannelWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` NotificationChannels from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` NotificationChannels.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned NotificationChannels
    **/
    _count?: true | NotificationChannelCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: NotificationChannelMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: NotificationChannelMaxAggregateInputType
  }

  export type GetNotificationChannelAggregateType<T extends NotificationChannelAggregateArgs> = {
        [P in keyof T & keyof AggregateNotificationChannel]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateNotificationChannel[P]>
      : GetScalarType<T[P], AggregateNotificationChannel[P]>
  }




  export type NotificationChannelGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: NotificationChannelWhereInput
    orderBy?: NotificationChannelOrderByWithAggregationInput | NotificationChannelOrderByWithAggregationInput[]
    by: NotificationChannelScalarFieldEnum[] | NotificationChannelScalarFieldEnum
    having?: NotificationChannelScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: NotificationChannelCountAggregateInputType | true
    _min?: NotificationChannelMinAggregateInputType
    _max?: NotificationChannelMaxAggregateInputType
  }

  export type NotificationChannelGroupByOutputType = {
    id: string
    tenantId: string
    type: $Enums.NotificationChannelType
    config: JsonValue
    enabled: boolean
    createdAt: Date
    updatedAt: Date
    _count: NotificationChannelCountAggregateOutputType | null
    _min: NotificationChannelMinAggregateOutputType | null
    _max: NotificationChannelMaxAggregateOutputType | null
  }

  type GetNotificationChannelGroupByPayload<T extends NotificationChannelGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<NotificationChannelGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof NotificationChannelGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], NotificationChannelGroupByOutputType[P]>
            : GetScalarType<T[P], NotificationChannelGroupByOutputType[P]>
        }
      >
    >


  export type NotificationChannelSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tenantId?: boolean
    type?: boolean
    config?: boolean
    enabled?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
    notificationEvents?: boolean | NotificationChannel$notificationEventsArgs<ExtArgs>
    _count?: boolean | NotificationChannelCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["notificationChannel"]>

  export type NotificationChannelSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tenantId?: boolean
    type?: boolean
    config?: boolean
    enabled?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["notificationChannel"]>

  export type NotificationChannelSelectScalar = {
    id?: boolean
    tenantId?: boolean
    type?: boolean
    config?: boolean
    enabled?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type NotificationChannelInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
    notificationEvents?: boolean | NotificationChannel$notificationEventsArgs<ExtArgs>
    _count?: boolean | NotificationChannelCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type NotificationChannelIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
  }

  export type $NotificationChannelPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "NotificationChannel"
    objects: {
      tenant: Prisma.$TenantPayload<ExtArgs>
      notificationEvents: Prisma.$NotificationEventPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      tenantId: string
      type: $Enums.NotificationChannelType
      config: Prisma.JsonValue
      enabled: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["notificationChannel"]>
    composites: {}
  }

  type NotificationChannelGetPayload<S extends boolean | null | undefined | NotificationChannelDefaultArgs> = $Result.GetResult<Prisma.$NotificationChannelPayload, S>

  type NotificationChannelCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<NotificationChannelFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: NotificationChannelCountAggregateInputType | true
    }

  export interface NotificationChannelDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['NotificationChannel'], meta: { name: 'NotificationChannel' } }
    /**
     * Find zero or one NotificationChannel that matches the filter.
     * @param {NotificationChannelFindUniqueArgs} args - Arguments to find a NotificationChannel
     * @example
     * // Get one NotificationChannel
     * const notificationChannel = await prisma.notificationChannel.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends NotificationChannelFindUniqueArgs>(args: SelectSubset<T, NotificationChannelFindUniqueArgs<ExtArgs>>): Prisma__NotificationChannelClient<$Result.GetResult<Prisma.$NotificationChannelPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one NotificationChannel that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {NotificationChannelFindUniqueOrThrowArgs} args - Arguments to find a NotificationChannel
     * @example
     * // Get one NotificationChannel
     * const notificationChannel = await prisma.notificationChannel.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends NotificationChannelFindUniqueOrThrowArgs>(args: SelectSubset<T, NotificationChannelFindUniqueOrThrowArgs<ExtArgs>>): Prisma__NotificationChannelClient<$Result.GetResult<Prisma.$NotificationChannelPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first NotificationChannel that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationChannelFindFirstArgs} args - Arguments to find a NotificationChannel
     * @example
     * // Get one NotificationChannel
     * const notificationChannel = await prisma.notificationChannel.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends NotificationChannelFindFirstArgs>(args?: SelectSubset<T, NotificationChannelFindFirstArgs<ExtArgs>>): Prisma__NotificationChannelClient<$Result.GetResult<Prisma.$NotificationChannelPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first NotificationChannel that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationChannelFindFirstOrThrowArgs} args - Arguments to find a NotificationChannel
     * @example
     * // Get one NotificationChannel
     * const notificationChannel = await prisma.notificationChannel.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends NotificationChannelFindFirstOrThrowArgs>(args?: SelectSubset<T, NotificationChannelFindFirstOrThrowArgs<ExtArgs>>): Prisma__NotificationChannelClient<$Result.GetResult<Prisma.$NotificationChannelPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more NotificationChannels that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationChannelFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all NotificationChannels
     * const notificationChannels = await prisma.notificationChannel.findMany()
     * 
     * // Get first 10 NotificationChannels
     * const notificationChannels = await prisma.notificationChannel.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const notificationChannelWithIdOnly = await prisma.notificationChannel.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends NotificationChannelFindManyArgs>(args?: SelectSubset<T, NotificationChannelFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NotificationChannelPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a NotificationChannel.
     * @param {NotificationChannelCreateArgs} args - Arguments to create a NotificationChannel.
     * @example
     * // Create one NotificationChannel
     * const NotificationChannel = await prisma.notificationChannel.create({
     *   data: {
     *     // ... data to create a NotificationChannel
     *   }
     * })
     * 
     */
    create<T extends NotificationChannelCreateArgs>(args: SelectSubset<T, NotificationChannelCreateArgs<ExtArgs>>): Prisma__NotificationChannelClient<$Result.GetResult<Prisma.$NotificationChannelPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many NotificationChannels.
     * @param {NotificationChannelCreateManyArgs} args - Arguments to create many NotificationChannels.
     * @example
     * // Create many NotificationChannels
     * const notificationChannel = await prisma.notificationChannel.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends NotificationChannelCreateManyArgs>(args?: SelectSubset<T, NotificationChannelCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many NotificationChannels and returns the data saved in the database.
     * @param {NotificationChannelCreateManyAndReturnArgs} args - Arguments to create many NotificationChannels.
     * @example
     * // Create many NotificationChannels
     * const notificationChannel = await prisma.notificationChannel.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many NotificationChannels and only return the `id`
     * const notificationChannelWithIdOnly = await prisma.notificationChannel.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends NotificationChannelCreateManyAndReturnArgs>(args?: SelectSubset<T, NotificationChannelCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NotificationChannelPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a NotificationChannel.
     * @param {NotificationChannelDeleteArgs} args - Arguments to delete one NotificationChannel.
     * @example
     * // Delete one NotificationChannel
     * const NotificationChannel = await prisma.notificationChannel.delete({
     *   where: {
     *     // ... filter to delete one NotificationChannel
     *   }
     * })
     * 
     */
    delete<T extends NotificationChannelDeleteArgs>(args: SelectSubset<T, NotificationChannelDeleteArgs<ExtArgs>>): Prisma__NotificationChannelClient<$Result.GetResult<Prisma.$NotificationChannelPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one NotificationChannel.
     * @param {NotificationChannelUpdateArgs} args - Arguments to update one NotificationChannel.
     * @example
     * // Update one NotificationChannel
     * const notificationChannel = await prisma.notificationChannel.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends NotificationChannelUpdateArgs>(args: SelectSubset<T, NotificationChannelUpdateArgs<ExtArgs>>): Prisma__NotificationChannelClient<$Result.GetResult<Prisma.$NotificationChannelPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more NotificationChannels.
     * @param {NotificationChannelDeleteManyArgs} args - Arguments to filter NotificationChannels to delete.
     * @example
     * // Delete a few NotificationChannels
     * const { count } = await prisma.notificationChannel.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends NotificationChannelDeleteManyArgs>(args?: SelectSubset<T, NotificationChannelDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more NotificationChannels.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationChannelUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many NotificationChannels
     * const notificationChannel = await prisma.notificationChannel.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends NotificationChannelUpdateManyArgs>(args: SelectSubset<T, NotificationChannelUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one NotificationChannel.
     * @param {NotificationChannelUpsertArgs} args - Arguments to update or create a NotificationChannel.
     * @example
     * // Update or create a NotificationChannel
     * const notificationChannel = await prisma.notificationChannel.upsert({
     *   create: {
     *     // ... data to create a NotificationChannel
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the NotificationChannel we want to update
     *   }
     * })
     */
    upsert<T extends NotificationChannelUpsertArgs>(args: SelectSubset<T, NotificationChannelUpsertArgs<ExtArgs>>): Prisma__NotificationChannelClient<$Result.GetResult<Prisma.$NotificationChannelPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of NotificationChannels.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationChannelCountArgs} args - Arguments to filter NotificationChannels to count.
     * @example
     * // Count the number of NotificationChannels
     * const count = await prisma.notificationChannel.count({
     *   where: {
     *     // ... the filter for the NotificationChannels we want to count
     *   }
     * })
    **/
    count<T extends NotificationChannelCountArgs>(
      args?: Subset<T, NotificationChannelCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], NotificationChannelCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a NotificationChannel.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationChannelAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends NotificationChannelAggregateArgs>(args: Subset<T, NotificationChannelAggregateArgs>): Prisma.PrismaPromise<GetNotificationChannelAggregateType<T>>

    /**
     * Group by NotificationChannel.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationChannelGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends NotificationChannelGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: NotificationChannelGroupByArgs['orderBy'] }
        : { orderBy?: NotificationChannelGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, NotificationChannelGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetNotificationChannelGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the NotificationChannel model
   */
  readonly fields: NotificationChannelFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for NotificationChannel.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__NotificationChannelClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    tenant<T extends TenantDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TenantDefaultArgs<ExtArgs>>): Prisma__TenantClient<$Result.GetResult<Prisma.$TenantPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    notificationEvents<T extends NotificationChannel$notificationEventsArgs<ExtArgs> = {}>(args?: Subset<T, NotificationChannel$notificationEventsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NotificationEventPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the NotificationChannel model
   */ 
  interface NotificationChannelFieldRefs {
    readonly id: FieldRef<"NotificationChannel", 'String'>
    readonly tenantId: FieldRef<"NotificationChannel", 'String'>
    readonly type: FieldRef<"NotificationChannel", 'NotificationChannelType'>
    readonly config: FieldRef<"NotificationChannel", 'Json'>
    readonly enabled: FieldRef<"NotificationChannel", 'Boolean'>
    readonly createdAt: FieldRef<"NotificationChannel", 'DateTime'>
    readonly updatedAt: FieldRef<"NotificationChannel", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * NotificationChannel findUnique
   */
  export type NotificationChannelFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NotificationChannel
     */
    select?: NotificationChannelSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationChannelInclude<ExtArgs> | null
    /**
     * Filter, which NotificationChannel to fetch.
     */
    where: NotificationChannelWhereUniqueInput
  }

  /**
   * NotificationChannel findUniqueOrThrow
   */
  export type NotificationChannelFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NotificationChannel
     */
    select?: NotificationChannelSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationChannelInclude<ExtArgs> | null
    /**
     * Filter, which NotificationChannel to fetch.
     */
    where: NotificationChannelWhereUniqueInput
  }

  /**
   * NotificationChannel findFirst
   */
  export type NotificationChannelFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NotificationChannel
     */
    select?: NotificationChannelSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationChannelInclude<ExtArgs> | null
    /**
     * Filter, which NotificationChannel to fetch.
     */
    where?: NotificationChannelWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of NotificationChannels to fetch.
     */
    orderBy?: NotificationChannelOrderByWithRelationInput | NotificationChannelOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for NotificationChannels.
     */
    cursor?: NotificationChannelWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` NotificationChannels from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` NotificationChannels.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of NotificationChannels.
     */
    distinct?: NotificationChannelScalarFieldEnum | NotificationChannelScalarFieldEnum[]
  }

  /**
   * NotificationChannel findFirstOrThrow
   */
  export type NotificationChannelFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NotificationChannel
     */
    select?: NotificationChannelSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationChannelInclude<ExtArgs> | null
    /**
     * Filter, which NotificationChannel to fetch.
     */
    where?: NotificationChannelWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of NotificationChannels to fetch.
     */
    orderBy?: NotificationChannelOrderByWithRelationInput | NotificationChannelOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for NotificationChannels.
     */
    cursor?: NotificationChannelWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` NotificationChannels from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` NotificationChannels.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of NotificationChannels.
     */
    distinct?: NotificationChannelScalarFieldEnum | NotificationChannelScalarFieldEnum[]
  }

  /**
   * NotificationChannel findMany
   */
  export type NotificationChannelFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NotificationChannel
     */
    select?: NotificationChannelSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationChannelInclude<ExtArgs> | null
    /**
     * Filter, which NotificationChannels to fetch.
     */
    where?: NotificationChannelWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of NotificationChannels to fetch.
     */
    orderBy?: NotificationChannelOrderByWithRelationInput | NotificationChannelOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing NotificationChannels.
     */
    cursor?: NotificationChannelWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` NotificationChannels from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` NotificationChannels.
     */
    skip?: number
    distinct?: NotificationChannelScalarFieldEnum | NotificationChannelScalarFieldEnum[]
  }

  /**
   * NotificationChannel create
   */
  export type NotificationChannelCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NotificationChannel
     */
    select?: NotificationChannelSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationChannelInclude<ExtArgs> | null
    /**
     * The data needed to create a NotificationChannel.
     */
    data: XOR<NotificationChannelCreateInput, NotificationChannelUncheckedCreateInput>
  }

  /**
   * NotificationChannel createMany
   */
  export type NotificationChannelCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many NotificationChannels.
     */
    data: NotificationChannelCreateManyInput | NotificationChannelCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * NotificationChannel createManyAndReturn
   */
  export type NotificationChannelCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NotificationChannel
     */
    select?: NotificationChannelSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many NotificationChannels.
     */
    data: NotificationChannelCreateManyInput | NotificationChannelCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationChannelIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * NotificationChannel update
   */
  export type NotificationChannelUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NotificationChannel
     */
    select?: NotificationChannelSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationChannelInclude<ExtArgs> | null
    /**
     * The data needed to update a NotificationChannel.
     */
    data: XOR<NotificationChannelUpdateInput, NotificationChannelUncheckedUpdateInput>
    /**
     * Choose, which NotificationChannel to update.
     */
    where: NotificationChannelWhereUniqueInput
  }

  /**
   * NotificationChannel updateMany
   */
  export type NotificationChannelUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update NotificationChannels.
     */
    data: XOR<NotificationChannelUpdateManyMutationInput, NotificationChannelUncheckedUpdateManyInput>
    /**
     * Filter which NotificationChannels to update
     */
    where?: NotificationChannelWhereInput
  }

  /**
   * NotificationChannel upsert
   */
  export type NotificationChannelUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NotificationChannel
     */
    select?: NotificationChannelSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationChannelInclude<ExtArgs> | null
    /**
     * The filter to search for the NotificationChannel to update in case it exists.
     */
    where: NotificationChannelWhereUniqueInput
    /**
     * In case the NotificationChannel found by the `where` argument doesn't exist, create a new NotificationChannel with this data.
     */
    create: XOR<NotificationChannelCreateInput, NotificationChannelUncheckedCreateInput>
    /**
     * In case the NotificationChannel was found with the provided `where` argument, update it with this data.
     */
    update: XOR<NotificationChannelUpdateInput, NotificationChannelUncheckedUpdateInput>
  }

  /**
   * NotificationChannel delete
   */
  export type NotificationChannelDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NotificationChannel
     */
    select?: NotificationChannelSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationChannelInclude<ExtArgs> | null
    /**
     * Filter which NotificationChannel to delete.
     */
    where: NotificationChannelWhereUniqueInput
  }

  /**
   * NotificationChannel deleteMany
   */
  export type NotificationChannelDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which NotificationChannels to delete
     */
    where?: NotificationChannelWhereInput
  }

  /**
   * NotificationChannel.notificationEvents
   */
  export type NotificationChannel$notificationEventsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NotificationEvent
     */
    select?: NotificationEventSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationEventInclude<ExtArgs> | null
    where?: NotificationEventWhereInput
    orderBy?: NotificationEventOrderByWithRelationInput | NotificationEventOrderByWithRelationInput[]
    cursor?: NotificationEventWhereUniqueInput
    take?: number
    skip?: number
    distinct?: NotificationEventScalarFieldEnum | NotificationEventScalarFieldEnum[]
  }

  /**
   * NotificationChannel without action
   */
  export type NotificationChannelDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NotificationChannel
     */
    select?: NotificationChannelSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationChannelInclude<ExtArgs> | null
  }


  /**
   * Model NotificationEvent
   */

  export type AggregateNotificationEvent = {
    _count: NotificationEventCountAggregateOutputType | null
    _min: NotificationEventMinAggregateOutputType | null
    _max: NotificationEventMaxAggregateOutputType | null
  }

  export type NotificationEventMinAggregateOutputType = {
    id: string | null
    tenantId: string | null
    channelId: string | null
    alertEventId: string | null
    status: $Enums.NotificationEventStatus | null
    sentAt: Date | null
    errorMsg: string | null
    createdAt: Date | null
  }

  export type NotificationEventMaxAggregateOutputType = {
    id: string | null
    tenantId: string | null
    channelId: string | null
    alertEventId: string | null
    status: $Enums.NotificationEventStatus | null
    sentAt: Date | null
    errorMsg: string | null
    createdAt: Date | null
  }

  export type NotificationEventCountAggregateOutputType = {
    id: number
    tenantId: number
    channelId: number
    alertEventId: number
    status: number
    payload: number
    sentAt: number
    errorMsg: number
    createdAt: number
    _all: number
  }


  export type NotificationEventMinAggregateInputType = {
    id?: true
    tenantId?: true
    channelId?: true
    alertEventId?: true
    status?: true
    sentAt?: true
    errorMsg?: true
    createdAt?: true
  }

  export type NotificationEventMaxAggregateInputType = {
    id?: true
    tenantId?: true
    channelId?: true
    alertEventId?: true
    status?: true
    sentAt?: true
    errorMsg?: true
    createdAt?: true
  }

  export type NotificationEventCountAggregateInputType = {
    id?: true
    tenantId?: true
    channelId?: true
    alertEventId?: true
    status?: true
    payload?: true
    sentAt?: true
    errorMsg?: true
    createdAt?: true
    _all?: true
  }

  export type NotificationEventAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which NotificationEvent to aggregate.
     */
    where?: NotificationEventWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of NotificationEvents to fetch.
     */
    orderBy?: NotificationEventOrderByWithRelationInput | NotificationEventOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: NotificationEventWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` NotificationEvents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` NotificationEvents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned NotificationEvents
    **/
    _count?: true | NotificationEventCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: NotificationEventMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: NotificationEventMaxAggregateInputType
  }

  export type GetNotificationEventAggregateType<T extends NotificationEventAggregateArgs> = {
        [P in keyof T & keyof AggregateNotificationEvent]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateNotificationEvent[P]>
      : GetScalarType<T[P], AggregateNotificationEvent[P]>
  }




  export type NotificationEventGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: NotificationEventWhereInput
    orderBy?: NotificationEventOrderByWithAggregationInput | NotificationEventOrderByWithAggregationInput[]
    by: NotificationEventScalarFieldEnum[] | NotificationEventScalarFieldEnum
    having?: NotificationEventScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: NotificationEventCountAggregateInputType | true
    _min?: NotificationEventMinAggregateInputType
    _max?: NotificationEventMaxAggregateInputType
  }

  export type NotificationEventGroupByOutputType = {
    id: string
    tenantId: string
    channelId: string
    alertEventId: string | null
    status: $Enums.NotificationEventStatus
    payload: JsonValue
    sentAt: Date | null
    errorMsg: string | null
    createdAt: Date
    _count: NotificationEventCountAggregateOutputType | null
    _min: NotificationEventMinAggregateOutputType | null
    _max: NotificationEventMaxAggregateOutputType | null
  }

  type GetNotificationEventGroupByPayload<T extends NotificationEventGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<NotificationEventGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof NotificationEventGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], NotificationEventGroupByOutputType[P]>
            : GetScalarType<T[P], NotificationEventGroupByOutputType[P]>
        }
      >
    >


  export type NotificationEventSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tenantId?: boolean
    channelId?: boolean
    alertEventId?: boolean
    status?: boolean
    payload?: boolean
    sentAt?: boolean
    errorMsg?: boolean
    createdAt?: boolean
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
    channel?: boolean | NotificationChannelDefaultArgs<ExtArgs>
    alertEvent?: boolean | NotificationEvent$alertEventArgs<ExtArgs>
  }, ExtArgs["result"]["notificationEvent"]>

  export type NotificationEventSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tenantId?: boolean
    channelId?: boolean
    alertEventId?: boolean
    status?: boolean
    payload?: boolean
    sentAt?: boolean
    errorMsg?: boolean
    createdAt?: boolean
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
    channel?: boolean | NotificationChannelDefaultArgs<ExtArgs>
    alertEvent?: boolean | NotificationEvent$alertEventArgs<ExtArgs>
  }, ExtArgs["result"]["notificationEvent"]>

  export type NotificationEventSelectScalar = {
    id?: boolean
    tenantId?: boolean
    channelId?: boolean
    alertEventId?: boolean
    status?: boolean
    payload?: boolean
    sentAt?: boolean
    errorMsg?: boolean
    createdAt?: boolean
  }

  export type NotificationEventInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
    channel?: boolean | NotificationChannelDefaultArgs<ExtArgs>
    alertEvent?: boolean | NotificationEvent$alertEventArgs<ExtArgs>
  }
  export type NotificationEventIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
    channel?: boolean | NotificationChannelDefaultArgs<ExtArgs>
    alertEvent?: boolean | NotificationEvent$alertEventArgs<ExtArgs>
  }

  export type $NotificationEventPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "NotificationEvent"
    objects: {
      tenant: Prisma.$TenantPayload<ExtArgs>
      channel: Prisma.$NotificationChannelPayload<ExtArgs>
      alertEvent: Prisma.$AlertEventPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      tenantId: string
      channelId: string
      alertEventId: string | null
      status: $Enums.NotificationEventStatus
      payload: Prisma.JsonValue
      sentAt: Date | null
      errorMsg: string | null
      createdAt: Date
    }, ExtArgs["result"]["notificationEvent"]>
    composites: {}
  }

  type NotificationEventGetPayload<S extends boolean | null | undefined | NotificationEventDefaultArgs> = $Result.GetResult<Prisma.$NotificationEventPayload, S>

  type NotificationEventCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<NotificationEventFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: NotificationEventCountAggregateInputType | true
    }

  export interface NotificationEventDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['NotificationEvent'], meta: { name: 'NotificationEvent' } }
    /**
     * Find zero or one NotificationEvent that matches the filter.
     * @param {NotificationEventFindUniqueArgs} args - Arguments to find a NotificationEvent
     * @example
     * // Get one NotificationEvent
     * const notificationEvent = await prisma.notificationEvent.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends NotificationEventFindUniqueArgs>(args: SelectSubset<T, NotificationEventFindUniqueArgs<ExtArgs>>): Prisma__NotificationEventClient<$Result.GetResult<Prisma.$NotificationEventPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one NotificationEvent that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {NotificationEventFindUniqueOrThrowArgs} args - Arguments to find a NotificationEvent
     * @example
     * // Get one NotificationEvent
     * const notificationEvent = await prisma.notificationEvent.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends NotificationEventFindUniqueOrThrowArgs>(args: SelectSubset<T, NotificationEventFindUniqueOrThrowArgs<ExtArgs>>): Prisma__NotificationEventClient<$Result.GetResult<Prisma.$NotificationEventPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first NotificationEvent that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationEventFindFirstArgs} args - Arguments to find a NotificationEvent
     * @example
     * // Get one NotificationEvent
     * const notificationEvent = await prisma.notificationEvent.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends NotificationEventFindFirstArgs>(args?: SelectSubset<T, NotificationEventFindFirstArgs<ExtArgs>>): Prisma__NotificationEventClient<$Result.GetResult<Prisma.$NotificationEventPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first NotificationEvent that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationEventFindFirstOrThrowArgs} args - Arguments to find a NotificationEvent
     * @example
     * // Get one NotificationEvent
     * const notificationEvent = await prisma.notificationEvent.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends NotificationEventFindFirstOrThrowArgs>(args?: SelectSubset<T, NotificationEventFindFirstOrThrowArgs<ExtArgs>>): Prisma__NotificationEventClient<$Result.GetResult<Prisma.$NotificationEventPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more NotificationEvents that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationEventFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all NotificationEvents
     * const notificationEvents = await prisma.notificationEvent.findMany()
     * 
     * // Get first 10 NotificationEvents
     * const notificationEvents = await prisma.notificationEvent.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const notificationEventWithIdOnly = await prisma.notificationEvent.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends NotificationEventFindManyArgs>(args?: SelectSubset<T, NotificationEventFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NotificationEventPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a NotificationEvent.
     * @param {NotificationEventCreateArgs} args - Arguments to create a NotificationEvent.
     * @example
     * // Create one NotificationEvent
     * const NotificationEvent = await prisma.notificationEvent.create({
     *   data: {
     *     // ... data to create a NotificationEvent
     *   }
     * })
     * 
     */
    create<T extends NotificationEventCreateArgs>(args: SelectSubset<T, NotificationEventCreateArgs<ExtArgs>>): Prisma__NotificationEventClient<$Result.GetResult<Prisma.$NotificationEventPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many NotificationEvents.
     * @param {NotificationEventCreateManyArgs} args - Arguments to create many NotificationEvents.
     * @example
     * // Create many NotificationEvents
     * const notificationEvent = await prisma.notificationEvent.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends NotificationEventCreateManyArgs>(args?: SelectSubset<T, NotificationEventCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many NotificationEvents and returns the data saved in the database.
     * @param {NotificationEventCreateManyAndReturnArgs} args - Arguments to create many NotificationEvents.
     * @example
     * // Create many NotificationEvents
     * const notificationEvent = await prisma.notificationEvent.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many NotificationEvents and only return the `id`
     * const notificationEventWithIdOnly = await prisma.notificationEvent.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends NotificationEventCreateManyAndReturnArgs>(args?: SelectSubset<T, NotificationEventCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NotificationEventPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a NotificationEvent.
     * @param {NotificationEventDeleteArgs} args - Arguments to delete one NotificationEvent.
     * @example
     * // Delete one NotificationEvent
     * const NotificationEvent = await prisma.notificationEvent.delete({
     *   where: {
     *     // ... filter to delete one NotificationEvent
     *   }
     * })
     * 
     */
    delete<T extends NotificationEventDeleteArgs>(args: SelectSubset<T, NotificationEventDeleteArgs<ExtArgs>>): Prisma__NotificationEventClient<$Result.GetResult<Prisma.$NotificationEventPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one NotificationEvent.
     * @param {NotificationEventUpdateArgs} args - Arguments to update one NotificationEvent.
     * @example
     * // Update one NotificationEvent
     * const notificationEvent = await prisma.notificationEvent.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends NotificationEventUpdateArgs>(args: SelectSubset<T, NotificationEventUpdateArgs<ExtArgs>>): Prisma__NotificationEventClient<$Result.GetResult<Prisma.$NotificationEventPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more NotificationEvents.
     * @param {NotificationEventDeleteManyArgs} args - Arguments to filter NotificationEvents to delete.
     * @example
     * // Delete a few NotificationEvents
     * const { count } = await prisma.notificationEvent.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends NotificationEventDeleteManyArgs>(args?: SelectSubset<T, NotificationEventDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more NotificationEvents.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationEventUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many NotificationEvents
     * const notificationEvent = await prisma.notificationEvent.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends NotificationEventUpdateManyArgs>(args: SelectSubset<T, NotificationEventUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one NotificationEvent.
     * @param {NotificationEventUpsertArgs} args - Arguments to update or create a NotificationEvent.
     * @example
     * // Update or create a NotificationEvent
     * const notificationEvent = await prisma.notificationEvent.upsert({
     *   create: {
     *     // ... data to create a NotificationEvent
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the NotificationEvent we want to update
     *   }
     * })
     */
    upsert<T extends NotificationEventUpsertArgs>(args: SelectSubset<T, NotificationEventUpsertArgs<ExtArgs>>): Prisma__NotificationEventClient<$Result.GetResult<Prisma.$NotificationEventPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of NotificationEvents.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationEventCountArgs} args - Arguments to filter NotificationEvents to count.
     * @example
     * // Count the number of NotificationEvents
     * const count = await prisma.notificationEvent.count({
     *   where: {
     *     // ... the filter for the NotificationEvents we want to count
     *   }
     * })
    **/
    count<T extends NotificationEventCountArgs>(
      args?: Subset<T, NotificationEventCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], NotificationEventCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a NotificationEvent.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationEventAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends NotificationEventAggregateArgs>(args: Subset<T, NotificationEventAggregateArgs>): Prisma.PrismaPromise<GetNotificationEventAggregateType<T>>

    /**
     * Group by NotificationEvent.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationEventGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends NotificationEventGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: NotificationEventGroupByArgs['orderBy'] }
        : { orderBy?: NotificationEventGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, NotificationEventGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetNotificationEventGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the NotificationEvent model
   */
  readonly fields: NotificationEventFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for NotificationEvent.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__NotificationEventClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    tenant<T extends TenantDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TenantDefaultArgs<ExtArgs>>): Prisma__TenantClient<$Result.GetResult<Prisma.$TenantPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    channel<T extends NotificationChannelDefaultArgs<ExtArgs> = {}>(args?: Subset<T, NotificationChannelDefaultArgs<ExtArgs>>): Prisma__NotificationChannelClient<$Result.GetResult<Prisma.$NotificationChannelPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    alertEvent<T extends NotificationEvent$alertEventArgs<ExtArgs> = {}>(args?: Subset<T, NotificationEvent$alertEventArgs<ExtArgs>>): Prisma__AlertEventClient<$Result.GetResult<Prisma.$AlertEventPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the NotificationEvent model
   */ 
  interface NotificationEventFieldRefs {
    readonly id: FieldRef<"NotificationEvent", 'String'>
    readonly tenantId: FieldRef<"NotificationEvent", 'String'>
    readonly channelId: FieldRef<"NotificationEvent", 'String'>
    readonly alertEventId: FieldRef<"NotificationEvent", 'String'>
    readonly status: FieldRef<"NotificationEvent", 'NotificationEventStatus'>
    readonly payload: FieldRef<"NotificationEvent", 'Json'>
    readonly sentAt: FieldRef<"NotificationEvent", 'DateTime'>
    readonly errorMsg: FieldRef<"NotificationEvent", 'String'>
    readonly createdAt: FieldRef<"NotificationEvent", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * NotificationEvent findUnique
   */
  export type NotificationEventFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NotificationEvent
     */
    select?: NotificationEventSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationEventInclude<ExtArgs> | null
    /**
     * Filter, which NotificationEvent to fetch.
     */
    where: NotificationEventWhereUniqueInput
  }

  /**
   * NotificationEvent findUniqueOrThrow
   */
  export type NotificationEventFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NotificationEvent
     */
    select?: NotificationEventSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationEventInclude<ExtArgs> | null
    /**
     * Filter, which NotificationEvent to fetch.
     */
    where: NotificationEventWhereUniqueInput
  }

  /**
   * NotificationEvent findFirst
   */
  export type NotificationEventFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NotificationEvent
     */
    select?: NotificationEventSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationEventInclude<ExtArgs> | null
    /**
     * Filter, which NotificationEvent to fetch.
     */
    where?: NotificationEventWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of NotificationEvents to fetch.
     */
    orderBy?: NotificationEventOrderByWithRelationInput | NotificationEventOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for NotificationEvents.
     */
    cursor?: NotificationEventWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` NotificationEvents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` NotificationEvents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of NotificationEvents.
     */
    distinct?: NotificationEventScalarFieldEnum | NotificationEventScalarFieldEnum[]
  }

  /**
   * NotificationEvent findFirstOrThrow
   */
  export type NotificationEventFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NotificationEvent
     */
    select?: NotificationEventSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationEventInclude<ExtArgs> | null
    /**
     * Filter, which NotificationEvent to fetch.
     */
    where?: NotificationEventWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of NotificationEvents to fetch.
     */
    orderBy?: NotificationEventOrderByWithRelationInput | NotificationEventOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for NotificationEvents.
     */
    cursor?: NotificationEventWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` NotificationEvents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` NotificationEvents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of NotificationEvents.
     */
    distinct?: NotificationEventScalarFieldEnum | NotificationEventScalarFieldEnum[]
  }

  /**
   * NotificationEvent findMany
   */
  export type NotificationEventFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NotificationEvent
     */
    select?: NotificationEventSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationEventInclude<ExtArgs> | null
    /**
     * Filter, which NotificationEvents to fetch.
     */
    where?: NotificationEventWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of NotificationEvents to fetch.
     */
    orderBy?: NotificationEventOrderByWithRelationInput | NotificationEventOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing NotificationEvents.
     */
    cursor?: NotificationEventWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` NotificationEvents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` NotificationEvents.
     */
    skip?: number
    distinct?: NotificationEventScalarFieldEnum | NotificationEventScalarFieldEnum[]
  }

  /**
   * NotificationEvent create
   */
  export type NotificationEventCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NotificationEvent
     */
    select?: NotificationEventSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationEventInclude<ExtArgs> | null
    /**
     * The data needed to create a NotificationEvent.
     */
    data: XOR<NotificationEventCreateInput, NotificationEventUncheckedCreateInput>
  }

  /**
   * NotificationEvent createMany
   */
  export type NotificationEventCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many NotificationEvents.
     */
    data: NotificationEventCreateManyInput | NotificationEventCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * NotificationEvent createManyAndReturn
   */
  export type NotificationEventCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NotificationEvent
     */
    select?: NotificationEventSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many NotificationEvents.
     */
    data: NotificationEventCreateManyInput | NotificationEventCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationEventIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * NotificationEvent update
   */
  export type NotificationEventUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NotificationEvent
     */
    select?: NotificationEventSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationEventInclude<ExtArgs> | null
    /**
     * The data needed to update a NotificationEvent.
     */
    data: XOR<NotificationEventUpdateInput, NotificationEventUncheckedUpdateInput>
    /**
     * Choose, which NotificationEvent to update.
     */
    where: NotificationEventWhereUniqueInput
  }

  /**
   * NotificationEvent updateMany
   */
  export type NotificationEventUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update NotificationEvents.
     */
    data: XOR<NotificationEventUpdateManyMutationInput, NotificationEventUncheckedUpdateManyInput>
    /**
     * Filter which NotificationEvents to update
     */
    where?: NotificationEventWhereInput
  }

  /**
   * NotificationEvent upsert
   */
  export type NotificationEventUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NotificationEvent
     */
    select?: NotificationEventSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationEventInclude<ExtArgs> | null
    /**
     * The filter to search for the NotificationEvent to update in case it exists.
     */
    where: NotificationEventWhereUniqueInput
    /**
     * In case the NotificationEvent found by the `where` argument doesn't exist, create a new NotificationEvent with this data.
     */
    create: XOR<NotificationEventCreateInput, NotificationEventUncheckedCreateInput>
    /**
     * In case the NotificationEvent was found with the provided `where` argument, update it with this data.
     */
    update: XOR<NotificationEventUpdateInput, NotificationEventUncheckedUpdateInput>
  }

  /**
   * NotificationEvent delete
   */
  export type NotificationEventDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NotificationEvent
     */
    select?: NotificationEventSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationEventInclude<ExtArgs> | null
    /**
     * Filter which NotificationEvent to delete.
     */
    where: NotificationEventWhereUniqueInput
  }

  /**
   * NotificationEvent deleteMany
   */
  export type NotificationEventDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which NotificationEvents to delete
     */
    where?: NotificationEventWhereInput
  }

  /**
   * NotificationEvent.alertEvent
   */
  export type NotificationEvent$alertEventArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AlertEvent
     */
    select?: AlertEventSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AlertEventInclude<ExtArgs> | null
    where?: AlertEventWhereInput
  }

  /**
   * NotificationEvent without action
   */
  export type NotificationEventDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NotificationEvent
     */
    select?: NotificationEventSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationEventInclude<ExtArgs> | null
  }


  /**
   * Model DailyRollup
   */

  export type AggregateDailyRollup = {
    _count: DailyRollupCountAggregateOutputType | null
    _avg: DailyRollupAvgAggregateOutputType | null
    _sum: DailyRollupSumAggregateOutputType | null
    _min: DailyRollupMinAggregateOutputType | null
    _max: DailyRollupMaxAggregateOutputType | null
  }

  export type DailyRollupAvgAggregateOutputType = {
    energyKwhDay: number | null
    hotWaterUsageLitersDay: number | null
    heaterOnMinutesDay: number | null
    tankTempMinC: number | null
    tankTempMaxC: number | null
    ambientTempAvgC: number | null
  }

  export type DailyRollupSumAggregateOutputType = {
    energyKwhDay: number | null
    hotWaterUsageLitersDay: number | null
    heaterOnMinutesDay: number | null
    tankTempMinC: number | null
    tankTempMaxC: number | null
    ambientTempAvgC: number | null
  }

  export type DailyRollupMinAggregateOutputType = {
    id: string | null
    tenantId: string | null
    deviceId: string | null
    dayDate: Date | null
    energyKwhDay: number | null
    hotWaterUsageLitersDay: number | null
    heaterOnMinutesDay: number | null
    tankTempMinC: number | null
    tankTempMaxC: number | null
    ambientTempAvgC: number | null
    createdAt: Date | null
  }

  export type DailyRollupMaxAggregateOutputType = {
    id: string | null
    tenantId: string | null
    deviceId: string | null
    dayDate: Date | null
    energyKwhDay: number | null
    hotWaterUsageLitersDay: number | null
    heaterOnMinutesDay: number | null
    tankTempMinC: number | null
    tankTempMaxC: number | null
    ambientTempAvgC: number | null
    createdAt: Date | null
  }

  export type DailyRollupCountAggregateOutputType = {
    id: number
    tenantId: number
    deviceId: number
    dayDate: number
    energyKwhDay: number
    hotWaterUsageLitersDay: number
    heaterOnMinutesDay: number
    tankTempMinC: number
    tankTempMaxC: number
    ambientTempAvgC: number
    createdAt: number
    _all: number
  }


  export type DailyRollupAvgAggregateInputType = {
    energyKwhDay?: true
    hotWaterUsageLitersDay?: true
    heaterOnMinutesDay?: true
    tankTempMinC?: true
    tankTempMaxC?: true
    ambientTempAvgC?: true
  }

  export type DailyRollupSumAggregateInputType = {
    energyKwhDay?: true
    hotWaterUsageLitersDay?: true
    heaterOnMinutesDay?: true
    tankTempMinC?: true
    tankTempMaxC?: true
    ambientTempAvgC?: true
  }

  export type DailyRollupMinAggregateInputType = {
    id?: true
    tenantId?: true
    deviceId?: true
    dayDate?: true
    energyKwhDay?: true
    hotWaterUsageLitersDay?: true
    heaterOnMinutesDay?: true
    tankTempMinC?: true
    tankTempMaxC?: true
    ambientTempAvgC?: true
    createdAt?: true
  }

  export type DailyRollupMaxAggregateInputType = {
    id?: true
    tenantId?: true
    deviceId?: true
    dayDate?: true
    energyKwhDay?: true
    hotWaterUsageLitersDay?: true
    heaterOnMinutesDay?: true
    tankTempMinC?: true
    tankTempMaxC?: true
    ambientTempAvgC?: true
    createdAt?: true
  }

  export type DailyRollupCountAggregateInputType = {
    id?: true
    tenantId?: true
    deviceId?: true
    dayDate?: true
    energyKwhDay?: true
    hotWaterUsageLitersDay?: true
    heaterOnMinutesDay?: true
    tankTempMinC?: true
    tankTempMaxC?: true
    ambientTempAvgC?: true
    createdAt?: true
    _all?: true
  }

  export type DailyRollupAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which DailyRollup to aggregate.
     */
    where?: DailyRollupWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DailyRollups to fetch.
     */
    orderBy?: DailyRollupOrderByWithRelationInput | DailyRollupOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: DailyRollupWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DailyRollups from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DailyRollups.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned DailyRollups
    **/
    _count?: true | DailyRollupCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: DailyRollupAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: DailyRollupSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: DailyRollupMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: DailyRollupMaxAggregateInputType
  }

  export type GetDailyRollupAggregateType<T extends DailyRollupAggregateArgs> = {
        [P in keyof T & keyof AggregateDailyRollup]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateDailyRollup[P]>
      : GetScalarType<T[P], AggregateDailyRollup[P]>
  }




  export type DailyRollupGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DailyRollupWhereInput
    orderBy?: DailyRollupOrderByWithAggregationInput | DailyRollupOrderByWithAggregationInput[]
    by: DailyRollupScalarFieldEnum[] | DailyRollupScalarFieldEnum
    having?: DailyRollupScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: DailyRollupCountAggregateInputType | true
    _avg?: DailyRollupAvgAggregateInputType
    _sum?: DailyRollupSumAggregateInputType
    _min?: DailyRollupMinAggregateInputType
    _max?: DailyRollupMaxAggregateInputType
  }

  export type DailyRollupGroupByOutputType = {
    id: string
    tenantId: string
    deviceId: string
    dayDate: Date
    energyKwhDay: number | null
    hotWaterUsageLitersDay: number | null
    heaterOnMinutesDay: number | null
    tankTempMinC: number | null
    tankTempMaxC: number | null
    ambientTempAvgC: number | null
    createdAt: Date
    _count: DailyRollupCountAggregateOutputType | null
    _avg: DailyRollupAvgAggregateOutputType | null
    _sum: DailyRollupSumAggregateOutputType | null
    _min: DailyRollupMinAggregateOutputType | null
    _max: DailyRollupMaxAggregateOutputType | null
  }

  type GetDailyRollupGroupByPayload<T extends DailyRollupGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<DailyRollupGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof DailyRollupGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], DailyRollupGroupByOutputType[P]>
            : GetScalarType<T[P], DailyRollupGroupByOutputType[P]>
        }
      >
    >


  export type DailyRollupSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tenantId?: boolean
    deviceId?: boolean
    dayDate?: boolean
    energyKwhDay?: boolean
    hotWaterUsageLitersDay?: boolean
    heaterOnMinutesDay?: boolean
    tankTempMinC?: boolean
    tankTempMaxC?: boolean
    ambientTempAvgC?: boolean
    createdAt?: boolean
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
    device?: boolean | DeviceDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["dailyRollup"]>

  export type DailyRollupSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tenantId?: boolean
    deviceId?: boolean
    dayDate?: boolean
    energyKwhDay?: boolean
    hotWaterUsageLitersDay?: boolean
    heaterOnMinutesDay?: boolean
    tankTempMinC?: boolean
    tankTempMaxC?: boolean
    ambientTempAvgC?: boolean
    createdAt?: boolean
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
    device?: boolean | DeviceDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["dailyRollup"]>

  export type DailyRollupSelectScalar = {
    id?: boolean
    tenantId?: boolean
    deviceId?: boolean
    dayDate?: boolean
    energyKwhDay?: boolean
    hotWaterUsageLitersDay?: boolean
    heaterOnMinutesDay?: boolean
    tankTempMinC?: boolean
    tankTempMaxC?: boolean
    ambientTempAvgC?: boolean
    createdAt?: boolean
  }

  export type DailyRollupInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
    device?: boolean | DeviceDefaultArgs<ExtArgs>
  }
  export type DailyRollupIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
    device?: boolean | DeviceDefaultArgs<ExtArgs>
  }

  export type $DailyRollupPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "DailyRollup"
    objects: {
      tenant: Prisma.$TenantPayload<ExtArgs>
      device: Prisma.$DevicePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      tenantId: string
      deviceId: string
      dayDate: Date
      energyKwhDay: number | null
      hotWaterUsageLitersDay: number | null
      heaterOnMinutesDay: number | null
      tankTempMinC: number | null
      tankTempMaxC: number | null
      ambientTempAvgC: number | null
      createdAt: Date
    }, ExtArgs["result"]["dailyRollup"]>
    composites: {}
  }

  type DailyRollupGetPayload<S extends boolean | null | undefined | DailyRollupDefaultArgs> = $Result.GetResult<Prisma.$DailyRollupPayload, S>

  type DailyRollupCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<DailyRollupFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: DailyRollupCountAggregateInputType | true
    }

  export interface DailyRollupDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['DailyRollup'], meta: { name: 'DailyRollup' } }
    /**
     * Find zero or one DailyRollup that matches the filter.
     * @param {DailyRollupFindUniqueArgs} args - Arguments to find a DailyRollup
     * @example
     * // Get one DailyRollup
     * const dailyRollup = await prisma.dailyRollup.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends DailyRollupFindUniqueArgs>(args: SelectSubset<T, DailyRollupFindUniqueArgs<ExtArgs>>): Prisma__DailyRollupClient<$Result.GetResult<Prisma.$DailyRollupPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one DailyRollup that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {DailyRollupFindUniqueOrThrowArgs} args - Arguments to find a DailyRollup
     * @example
     * // Get one DailyRollup
     * const dailyRollup = await prisma.dailyRollup.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends DailyRollupFindUniqueOrThrowArgs>(args: SelectSubset<T, DailyRollupFindUniqueOrThrowArgs<ExtArgs>>): Prisma__DailyRollupClient<$Result.GetResult<Prisma.$DailyRollupPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first DailyRollup that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DailyRollupFindFirstArgs} args - Arguments to find a DailyRollup
     * @example
     * // Get one DailyRollup
     * const dailyRollup = await prisma.dailyRollup.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends DailyRollupFindFirstArgs>(args?: SelectSubset<T, DailyRollupFindFirstArgs<ExtArgs>>): Prisma__DailyRollupClient<$Result.GetResult<Prisma.$DailyRollupPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first DailyRollup that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DailyRollupFindFirstOrThrowArgs} args - Arguments to find a DailyRollup
     * @example
     * // Get one DailyRollup
     * const dailyRollup = await prisma.dailyRollup.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends DailyRollupFindFirstOrThrowArgs>(args?: SelectSubset<T, DailyRollupFindFirstOrThrowArgs<ExtArgs>>): Prisma__DailyRollupClient<$Result.GetResult<Prisma.$DailyRollupPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more DailyRollups that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DailyRollupFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all DailyRollups
     * const dailyRollups = await prisma.dailyRollup.findMany()
     * 
     * // Get first 10 DailyRollups
     * const dailyRollups = await prisma.dailyRollup.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const dailyRollupWithIdOnly = await prisma.dailyRollup.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends DailyRollupFindManyArgs>(args?: SelectSubset<T, DailyRollupFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DailyRollupPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a DailyRollup.
     * @param {DailyRollupCreateArgs} args - Arguments to create a DailyRollup.
     * @example
     * // Create one DailyRollup
     * const DailyRollup = await prisma.dailyRollup.create({
     *   data: {
     *     // ... data to create a DailyRollup
     *   }
     * })
     * 
     */
    create<T extends DailyRollupCreateArgs>(args: SelectSubset<T, DailyRollupCreateArgs<ExtArgs>>): Prisma__DailyRollupClient<$Result.GetResult<Prisma.$DailyRollupPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many DailyRollups.
     * @param {DailyRollupCreateManyArgs} args - Arguments to create many DailyRollups.
     * @example
     * // Create many DailyRollups
     * const dailyRollup = await prisma.dailyRollup.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends DailyRollupCreateManyArgs>(args?: SelectSubset<T, DailyRollupCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many DailyRollups and returns the data saved in the database.
     * @param {DailyRollupCreateManyAndReturnArgs} args - Arguments to create many DailyRollups.
     * @example
     * // Create many DailyRollups
     * const dailyRollup = await prisma.dailyRollup.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many DailyRollups and only return the `id`
     * const dailyRollupWithIdOnly = await prisma.dailyRollup.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends DailyRollupCreateManyAndReturnArgs>(args?: SelectSubset<T, DailyRollupCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DailyRollupPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a DailyRollup.
     * @param {DailyRollupDeleteArgs} args - Arguments to delete one DailyRollup.
     * @example
     * // Delete one DailyRollup
     * const DailyRollup = await prisma.dailyRollup.delete({
     *   where: {
     *     // ... filter to delete one DailyRollup
     *   }
     * })
     * 
     */
    delete<T extends DailyRollupDeleteArgs>(args: SelectSubset<T, DailyRollupDeleteArgs<ExtArgs>>): Prisma__DailyRollupClient<$Result.GetResult<Prisma.$DailyRollupPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one DailyRollup.
     * @param {DailyRollupUpdateArgs} args - Arguments to update one DailyRollup.
     * @example
     * // Update one DailyRollup
     * const dailyRollup = await prisma.dailyRollup.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends DailyRollupUpdateArgs>(args: SelectSubset<T, DailyRollupUpdateArgs<ExtArgs>>): Prisma__DailyRollupClient<$Result.GetResult<Prisma.$DailyRollupPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more DailyRollups.
     * @param {DailyRollupDeleteManyArgs} args - Arguments to filter DailyRollups to delete.
     * @example
     * // Delete a few DailyRollups
     * const { count } = await prisma.dailyRollup.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends DailyRollupDeleteManyArgs>(args?: SelectSubset<T, DailyRollupDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more DailyRollups.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DailyRollupUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many DailyRollups
     * const dailyRollup = await prisma.dailyRollup.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends DailyRollupUpdateManyArgs>(args: SelectSubset<T, DailyRollupUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one DailyRollup.
     * @param {DailyRollupUpsertArgs} args - Arguments to update or create a DailyRollup.
     * @example
     * // Update or create a DailyRollup
     * const dailyRollup = await prisma.dailyRollup.upsert({
     *   create: {
     *     // ... data to create a DailyRollup
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the DailyRollup we want to update
     *   }
     * })
     */
    upsert<T extends DailyRollupUpsertArgs>(args: SelectSubset<T, DailyRollupUpsertArgs<ExtArgs>>): Prisma__DailyRollupClient<$Result.GetResult<Prisma.$DailyRollupPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of DailyRollups.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DailyRollupCountArgs} args - Arguments to filter DailyRollups to count.
     * @example
     * // Count the number of DailyRollups
     * const count = await prisma.dailyRollup.count({
     *   where: {
     *     // ... the filter for the DailyRollups we want to count
     *   }
     * })
    **/
    count<T extends DailyRollupCountArgs>(
      args?: Subset<T, DailyRollupCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], DailyRollupCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a DailyRollup.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DailyRollupAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends DailyRollupAggregateArgs>(args: Subset<T, DailyRollupAggregateArgs>): Prisma.PrismaPromise<GetDailyRollupAggregateType<T>>

    /**
     * Group by DailyRollup.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DailyRollupGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends DailyRollupGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: DailyRollupGroupByArgs['orderBy'] }
        : { orderBy?: DailyRollupGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, DailyRollupGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetDailyRollupGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the DailyRollup model
   */
  readonly fields: DailyRollupFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for DailyRollup.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__DailyRollupClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    tenant<T extends TenantDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TenantDefaultArgs<ExtArgs>>): Prisma__TenantClient<$Result.GetResult<Prisma.$TenantPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    device<T extends DeviceDefaultArgs<ExtArgs> = {}>(args?: Subset<T, DeviceDefaultArgs<ExtArgs>>): Prisma__DeviceClient<$Result.GetResult<Prisma.$DevicePayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the DailyRollup model
   */ 
  interface DailyRollupFieldRefs {
    readonly id: FieldRef<"DailyRollup", 'String'>
    readonly tenantId: FieldRef<"DailyRollup", 'String'>
    readonly deviceId: FieldRef<"DailyRollup", 'String'>
    readonly dayDate: FieldRef<"DailyRollup", 'DateTime'>
    readonly energyKwhDay: FieldRef<"DailyRollup", 'Float'>
    readonly hotWaterUsageLitersDay: FieldRef<"DailyRollup", 'Float'>
    readonly heaterOnMinutesDay: FieldRef<"DailyRollup", 'Float'>
    readonly tankTempMinC: FieldRef<"DailyRollup", 'Float'>
    readonly tankTempMaxC: FieldRef<"DailyRollup", 'Float'>
    readonly ambientTempAvgC: FieldRef<"DailyRollup", 'Float'>
    readonly createdAt: FieldRef<"DailyRollup", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * DailyRollup findUnique
   */
  export type DailyRollupFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DailyRollup
     */
    select?: DailyRollupSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DailyRollupInclude<ExtArgs> | null
    /**
     * Filter, which DailyRollup to fetch.
     */
    where: DailyRollupWhereUniqueInput
  }

  /**
   * DailyRollup findUniqueOrThrow
   */
  export type DailyRollupFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DailyRollup
     */
    select?: DailyRollupSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DailyRollupInclude<ExtArgs> | null
    /**
     * Filter, which DailyRollup to fetch.
     */
    where: DailyRollupWhereUniqueInput
  }

  /**
   * DailyRollup findFirst
   */
  export type DailyRollupFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DailyRollup
     */
    select?: DailyRollupSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DailyRollupInclude<ExtArgs> | null
    /**
     * Filter, which DailyRollup to fetch.
     */
    where?: DailyRollupWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DailyRollups to fetch.
     */
    orderBy?: DailyRollupOrderByWithRelationInput | DailyRollupOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for DailyRollups.
     */
    cursor?: DailyRollupWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DailyRollups from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DailyRollups.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of DailyRollups.
     */
    distinct?: DailyRollupScalarFieldEnum | DailyRollupScalarFieldEnum[]
  }

  /**
   * DailyRollup findFirstOrThrow
   */
  export type DailyRollupFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DailyRollup
     */
    select?: DailyRollupSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DailyRollupInclude<ExtArgs> | null
    /**
     * Filter, which DailyRollup to fetch.
     */
    where?: DailyRollupWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DailyRollups to fetch.
     */
    orderBy?: DailyRollupOrderByWithRelationInput | DailyRollupOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for DailyRollups.
     */
    cursor?: DailyRollupWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DailyRollups from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DailyRollups.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of DailyRollups.
     */
    distinct?: DailyRollupScalarFieldEnum | DailyRollupScalarFieldEnum[]
  }

  /**
   * DailyRollup findMany
   */
  export type DailyRollupFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DailyRollup
     */
    select?: DailyRollupSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DailyRollupInclude<ExtArgs> | null
    /**
     * Filter, which DailyRollups to fetch.
     */
    where?: DailyRollupWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DailyRollups to fetch.
     */
    orderBy?: DailyRollupOrderByWithRelationInput | DailyRollupOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing DailyRollups.
     */
    cursor?: DailyRollupWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DailyRollups from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DailyRollups.
     */
    skip?: number
    distinct?: DailyRollupScalarFieldEnum | DailyRollupScalarFieldEnum[]
  }

  /**
   * DailyRollup create
   */
  export type DailyRollupCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DailyRollup
     */
    select?: DailyRollupSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DailyRollupInclude<ExtArgs> | null
    /**
     * The data needed to create a DailyRollup.
     */
    data: XOR<DailyRollupCreateInput, DailyRollupUncheckedCreateInput>
  }

  /**
   * DailyRollup createMany
   */
  export type DailyRollupCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many DailyRollups.
     */
    data: DailyRollupCreateManyInput | DailyRollupCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * DailyRollup createManyAndReturn
   */
  export type DailyRollupCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DailyRollup
     */
    select?: DailyRollupSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many DailyRollups.
     */
    data: DailyRollupCreateManyInput | DailyRollupCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DailyRollupIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * DailyRollup update
   */
  export type DailyRollupUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DailyRollup
     */
    select?: DailyRollupSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DailyRollupInclude<ExtArgs> | null
    /**
     * The data needed to update a DailyRollup.
     */
    data: XOR<DailyRollupUpdateInput, DailyRollupUncheckedUpdateInput>
    /**
     * Choose, which DailyRollup to update.
     */
    where: DailyRollupWhereUniqueInput
  }

  /**
   * DailyRollup updateMany
   */
  export type DailyRollupUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update DailyRollups.
     */
    data: XOR<DailyRollupUpdateManyMutationInput, DailyRollupUncheckedUpdateManyInput>
    /**
     * Filter which DailyRollups to update
     */
    where?: DailyRollupWhereInput
  }

  /**
   * DailyRollup upsert
   */
  export type DailyRollupUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DailyRollup
     */
    select?: DailyRollupSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DailyRollupInclude<ExtArgs> | null
    /**
     * The filter to search for the DailyRollup to update in case it exists.
     */
    where: DailyRollupWhereUniqueInput
    /**
     * In case the DailyRollup found by the `where` argument doesn't exist, create a new DailyRollup with this data.
     */
    create: XOR<DailyRollupCreateInput, DailyRollupUncheckedCreateInput>
    /**
     * In case the DailyRollup was found with the provided `where` argument, update it with this data.
     */
    update: XOR<DailyRollupUpdateInput, DailyRollupUncheckedUpdateInput>
  }

  /**
   * DailyRollup delete
   */
  export type DailyRollupDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DailyRollup
     */
    select?: DailyRollupSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DailyRollupInclude<ExtArgs> | null
    /**
     * Filter which DailyRollup to delete.
     */
    where: DailyRollupWhereUniqueInput
  }

  /**
   * DailyRollup deleteMany
   */
  export type DailyRollupDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which DailyRollups to delete
     */
    where?: DailyRollupWhereInput
  }

  /**
   * DailyRollup without action
   */
  export type DailyRollupDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DailyRollup
     */
    select?: DailyRollupSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DailyRollupInclude<ExtArgs> | null
  }


  /**
   * Model Entitlement
   */

  export type AggregateEntitlement = {
    _count: EntitlementCountAggregateOutputType | null
    _min: EntitlementMinAggregateOutputType | null
    _max: EntitlementMaxAggregateOutputType | null
  }

  export type EntitlementMinAggregateOutputType = {
    id: string | null
    tenantId: string | null
    scope: $Enums.EntitlementScope | null
    deviceId: string | null
    key: $Enums.EntitlementKey | null
    enabled: boolean | null
    updatedAt: Date | null
  }

  export type EntitlementMaxAggregateOutputType = {
    id: string | null
    tenantId: string | null
    scope: $Enums.EntitlementScope | null
    deviceId: string | null
    key: $Enums.EntitlementKey | null
    enabled: boolean | null
    updatedAt: Date | null
  }

  export type EntitlementCountAggregateOutputType = {
    id: number
    tenantId: number
    scope: number
    deviceId: number
    key: number
    enabled: number
    updatedAt: number
    _all: number
  }


  export type EntitlementMinAggregateInputType = {
    id?: true
    tenantId?: true
    scope?: true
    deviceId?: true
    key?: true
    enabled?: true
    updatedAt?: true
  }

  export type EntitlementMaxAggregateInputType = {
    id?: true
    tenantId?: true
    scope?: true
    deviceId?: true
    key?: true
    enabled?: true
    updatedAt?: true
  }

  export type EntitlementCountAggregateInputType = {
    id?: true
    tenantId?: true
    scope?: true
    deviceId?: true
    key?: true
    enabled?: true
    updatedAt?: true
    _all?: true
  }

  export type EntitlementAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Entitlement to aggregate.
     */
    where?: EntitlementWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Entitlements to fetch.
     */
    orderBy?: EntitlementOrderByWithRelationInput | EntitlementOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: EntitlementWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Entitlements from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Entitlements.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Entitlements
    **/
    _count?: true | EntitlementCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: EntitlementMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: EntitlementMaxAggregateInputType
  }

  export type GetEntitlementAggregateType<T extends EntitlementAggregateArgs> = {
        [P in keyof T & keyof AggregateEntitlement]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateEntitlement[P]>
      : GetScalarType<T[P], AggregateEntitlement[P]>
  }




  export type EntitlementGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EntitlementWhereInput
    orderBy?: EntitlementOrderByWithAggregationInput | EntitlementOrderByWithAggregationInput[]
    by: EntitlementScalarFieldEnum[] | EntitlementScalarFieldEnum
    having?: EntitlementScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: EntitlementCountAggregateInputType | true
    _min?: EntitlementMinAggregateInputType
    _max?: EntitlementMaxAggregateInputType
  }

  export type EntitlementGroupByOutputType = {
    id: string
    tenantId: string
    scope: $Enums.EntitlementScope
    deviceId: string | null
    key: $Enums.EntitlementKey
    enabled: boolean
    updatedAt: Date
    _count: EntitlementCountAggregateOutputType | null
    _min: EntitlementMinAggregateOutputType | null
    _max: EntitlementMaxAggregateOutputType | null
  }

  type GetEntitlementGroupByPayload<T extends EntitlementGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<EntitlementGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof EntitlementGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], EntitlementGroupByOutputType[P]>
            : GetScalarType<T[P], EntitlementGroupByOutputType[P]>
        }
      >
    >


  export type EntitlementSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tenantId?: boolean
    scope?: boolean
    deviceId?: boolean
    key?: boolean
    enabled?: boolean
    updatedAt?: boolean
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
    device?: boolean | Entitlement$deviceArgs<ExtArgs>
  }, ExtArgs["result"]["entitlement"]>

  export type EntitlementSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tenantId?: boolean
    scope?: boolean
    deviceId?: boolean
    key?: boolean
    enabled?: boolean
    updatedAt?: boolean
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
    device?: boolean | Entitlement$deviceArgs<ExtArgs>
  }, ExtArgs["result"]["entitlement"]>

  export type EntitlementSelectScalar = {
    id?: boolean
    tenantId?: boolean
    scope?: boolean
    deviceId?: boolean
    key?: boolean
    enabled?: boolean
    updatedAt?: boolean
  }

  export type EntitlementInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
    device?: boolean | Entitlement$deviceArgs<ExtArgs>
  }
  export type EntitlementIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
    device?: boolean | Entitlement$deviceArgs<ExtArgs>
  }

  export type $EntitlementPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Entitlement"
    objects: {
      tenant: Prisma.$TenantPayload<ExtArgs>
      device: Prisma.$DevicePayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      tenantId: string
      scope: $Enums.EntitlementScope
      deviceId: string | null
      key: $Enums.EntitlementKey
      enabled: boolean
      updatedAt: Date
    }, ExtArgs["result"]["entitlement"]>
    composites: {}
  }

  type EntitlementGetPayload<S extends boolean | null | undefined | EntitlementDefaultArgs> = $Result.GetResult<Prisma.$EntitlementPayload, S>

  type EntitlementCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<EntitlementFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: EntitlementCountAggregateInputType | true
    }

  export interface EntitlementDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Entitlement'], meta: { name: 'Entitlement' } }
    /**
     * Find zero or one Entitlement that matches the filter.
     * @param {EntitlementFindUniqueArgs} args - Arguments to find a Entitlement
     * @example
     * // Get one Entitlement
     * const entitlement = await prisma.entitlement.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends EntitlementFindUniqueArgs>(args: SelectSubset<T, EntitlementFindUniqueArgs<ExtArgs>>): Prisma__EntitlementClient<$Result.GetResult<Prisma.$EntitlementPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Entitlement that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {EntitlementFindUniqueOrThrowArgs} args - Arguments to find a Entitlement
     * @example
     * // Get one Entitlement
     * const entitlement = await prisma.entitlement.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends EntitlementFindUniqueOrThrowArgs>(args: SelectSubset<T, EntitlementFindUniqueOrThrowArgs<ExtArgs>>): Prisma__EntitlementClient<$Result.GetResult<Prisma.$EntitlementPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Entitlement that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EntitlementFindFirstArgs} args - Arguments to find a Entitlement
     * @example
     * // Get one Entitlement
     * const entitlement = await prisma.entitlement.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends EntitlementFindFirstArgs>(args?: SelectSubset<T, EntitlementFindFirstArgs<ExtArgs>>): Prisma__EntitlementClient<$Result.GetResult<Prisma.$EntitlementPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Entitlement that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EntitlementFindFirstOrThrowArgs} args - Arguments to find a Entitlement
     * @example
     * // Get one Entitlement
     * const entitlement = await prisma.entitlement.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends EntitlementFindFirstOrThrowArgs>(args?: SelectSubset<T, EntitlementFindFirstOrThrowArgs<ExtArgs>>): Prisma__EntitlementClient<$Result.GetResult<Prisma.$EntitlementPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Entitlements that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EntitlementFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Entitlements
     * const entitlements = await prisma.entitlement.findMany()
     * 
     * // Get first 10 Entitlements
     * const entitlements = await prisma.entitlement.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const entitlementWithIdOnly = await prisma.entitlement.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends EntitlementFindManyArgs>(args?: SelectSubset<T, EntitlementFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EntitlementPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Entitlement.
     * @param {EntitlementCreateArgs} args - Arguments to create a Entitlement.
     * @example
     * // Create one Entitlement
     * const Entitlement = await prisma.entitlement.create({
     *   data: {
     *     // ... data to create a Entitlement
     *   }
     * })
     * 
     */
    create<T extends EntitlementCreateArgs>(args: SelectSubset<T, EntitlementCreateArgs<ExtArgs>>): Prisma__EntitlementClient<$Result.GetResult<Prisma.$EntitlementPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Entitlements.
     * @param {EntitlementCreateManyArgs} args - Arguments to create many Entitlements.
     * @example
     * // Create many Entitlements
     * const entitlement = await prisma.entitlement.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends EntitlementCreateManyArgs>(args?: SelectSubset<T, EntitlementCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Entitlements and returns the data saved in the database.
     * @param {EntitlementCreateManyAndReturnArgs} args - Arguments to create many Entitlements.
     * @example
     * // Create many Entitlements
     * const entitlement = await prisma.entitlement.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Entitlements and only return the `id`
     * const entitlementWithIdOnly = await prisma.entitlement.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends EntitlementCreateManyAndReturnArgs>(args?: SelectSubset<T, EntitlementCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EntitlementPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Entitlement.
     * @param {EntitlementDeleteArgs} args - Arguments to delete one Entitlement.
     * @example
     * // Delete one Entitlement
     * const Entitlement = await prisma.entitlement.delete({
     *   where: {
     *     // ... filter to delete one Entitlement
     *   }
     * })
     * 
     */
    delete<T extends EntitlementDeleteArgs>(args: SelectSubset<T, EntitlementDeleteArgs<ExtArgs>>): Prisma__EntitlementClient<$Result.GetResult<Prisma.$EntitlementPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Entitlement.
     * @param {EntitlementUpdateArgs} args - Arguments to update one Entitlement.
     * @example
     * // Update one Entitlement
     * const entitlement = await prisma.entitlement.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends EntitlementUpdateArgs>(args: SelectSubset<T, EntitlementUpdateArgs<ExtArgs>>): Prisma__EntitlementClient<$Result.GetResult<Prisma.$EntitlementPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Entitlements.
     * @param {EntitlementDeleteManyArgs} args - Arguments to filter Entitlements to delete.
     * @example
     * // Delete a few Entitlements
     * const { count } = await prisma.entitlement.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends EntitlementDeleteManyArgs>(args?: SelectSubset<T, EntitlementDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Entitlements.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EntitlementUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Entitlements
     * const entitlement = await prisma.entitlement.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends EntitlementUpdateManyArgs>(args: SelectSubset<T, EntitlementUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Entitlement.
     * @param {EntitlementUpsertArgs} args - Arguments to update or create a Entitlement.
     * @example
     * // Update or create a Entitlement
     * const entitlement = await prisma.entitlement.upsert({
     *   create: {
     *     // ... data to create a Entitlement
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Entitlement we want to update
     *   }
     * })
     */
    upsert<T extends EntitlementUpsertArgs>(args: SelectSubset<T, EntitlementUpsertArgs<ExtArgs>>): Prisma__EntitlementClient<$Result.GetResult<Prisma.$EntitlementPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Entitlements.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EntitlementCountArgs} args - Arguments to filter Entitlements to count.
     * @example
     * // Count the number of Entitlements
     * const count = await prisma.entitlement.count({
     *   where: {
     *     // ... the filter for the Entitlements we want to count
     *   }
     * })
    **/
    count<T extends EntitlementCountArgs>(
      args?: Subset<T, EntitlementCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], EntitlementCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Entitlement.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EntitlementAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends EntitlementAggregateArgs>(args: Subset<T, EntitlementAggregateArgs>): Prisma.PrismaPromise<GetEntitlementAggregateType<T>>

    /**
     * Group by Entitlement.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EntitlementGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends EntitlementGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: EntitlementGroupByArgs['orderBy'] }
        : { orderBy?: EntitlementGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, EntitlementGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetEntitlementGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Entitlement model
   */
  readonly fields: EntitlementFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Entitlement.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__EntitlementClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    tenant<T extends TenantDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TenantDefaultArgs<ExtArgs>>): Prisma__TenantClient<$Result.GetResult<Prisma.$TenantPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    device<T extends Entitlement$deviceArgs<ExtArgs> = {}>(args?: Subset<T, Entitlement$deviceArgs<ExtArgs>>): Prisma__DeviceClient<$Result.GetResult<Prisma.$DevicePayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Entitlement model
   */ 
  interface EntitlementFieldRefs {
    readonly id: FieldRef<"Entitlement", 'String'>
    readonly tenantId: FieldRef<"Entitlement", 'String'>
    readonly scope: FieldRef<"Entitlement", 'EntitlementScope'>
    readonly deviceId: FieldRef<"Entitlement", 'String'>
    readonly key: FieldRef<"Entitlement", 'EntitlementKey'>
    readonly enabled: FieldRef<"Entitlement", 'Boolean'>
    readonly updatedAt: FieldRef<"Entitlement", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Entitlement findUnique
   */
  export type EntitlementFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Entitlement
     */
    select?: EntitlementSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EntitlementInclude<ExtArgs> | null
    /**
     * Filter, which Entitlement to fetch.
     */
    where: EntitlementWhereUniqueInput
  }

  /**
   * Entitlement findUniqueOrThrow
   */
  export type EntitlementFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Entitlement
     */
    select?: EntitlementSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EntitlementInclude<ExtArgs> | null
    /**
     * Filter, which Entitlement to fetch.
     */
    where: EntitlementWhereUniqueInput
  }

  /**
   * Entitlement findFirst
   */
  export type EntitlementFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Entitlement
     */
    select?: EntitlementSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EntitlementInclude<ExtArgs> | null
    /**
     * Filter, which Entitlement to fetch.
     */
    where?: EntitlementWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Entitlements to fetch.
     */
    orderBy?: EntitlementOrderByWithRelationInput | EntitlementOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Entitlements.
     */
    cursor?: EntitlementWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Entitlements from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Entitlements.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Entitlements.
     */
    distinct?: EntitlementScalarFieldEnum | EntitlementScalarFieldEnum[]
  }

  /**
   * Entitlement findFirstOrThrow
   */
  export type EntitlementFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Entitlement
     */
    select?: EntitlementSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EntitlementInclude<ExtArgs> | null
    /**
     * Filter, which Entitlement to fetch.
     */
    where?: EntitlementWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Entitlements to fetch.
     */
    orderBy?: EntitlementOrderByWithRelationInput | EntitlementOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Entitlements.
     */
    cursor?: EntitlementWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Entitlements from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Entitlements.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Entitlements.
     */
    distinct?: EntitlementScalarFieldEnum | EntitlementScalarFieldEnum[]
  }

  /**
   * Entitlement findMany
   */
  export type EntitlementFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Entitlement
     */
    select?: EntitlementSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EntitlementInclude<ExtArgs> | null
    /**
     * Filter, which Entitlements to fetch.
     */
    where?: EntitlementWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Entitlements to fetch.
     */
    orderBy?: EntitlementOrderByWithRelationInput | EntitlementOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Entitlements.
     */
    cursor?: EntitlementWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Entitlements from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Entitlements.
     */
    skip?: number
    distinct?: EntitlementScalarFieldEnum | EntitlementScalarFieldEnum[]
  }

  /**
   * Entitlement create
   */
  export type EntitlementCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Entitlement
     */
    select?: EntitlementSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EntitlementInclude<ExtArgs> | null
    /**
     * The data needed to create a Entitlement.
     */
    data: XOR<EntitlementCreateInput, EntitlementUncheckedCreateInput>
  }

  /**
   * Entitlement createMany
   */
  export type EntitlementCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Entitlements.
     */
    data: EntitlementCreateManyInput | EntitlementCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Entitlement createManyAndReturn
   */
  export type EntitlementCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Entitlement
     */
    select?: EntitlementSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Entitlements.
     */
    data: EntitlementCreateManyInput | EntitlementCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EntitlementIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Entitlement update
   */
  export type EntitlementUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Entitlement
     */
    select?: EntitlementSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EntitlementInclude<ExtArgs> | null
    /**
     * The data needed to update a Entitlement.
     */
    data: XOR<EntitlementUpdateInput, EntitlementUncheckedUpdateInput>
    /**
     * Choose, which Entitlement to update.
     */
    where: EntitlementWhereUniqueInput
  }

  /**
   * Entitlement updateMany
   */
  export type EntitlementUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Entitlements.
     */
    data: XOR<EntitlementUpdateManyMutationInput, EntitlementUncheckedUpdateManyInput>
    /**
     * Filter which Entitlements to update
     */
    where?: EntitlementWhereInput
  }

  /**
   * Entitlement upsert
   */
  export type EntitlementUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Entitlement
     */
    select?: EntitlementSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EntitlementInclude<ExtArgs> | null
    /**
     * The filter to search for the Entitlement to update in case it exists.
     */
    where: EntitlementWhereUniqueInput
    /**
     * In case the Entitlement found by the `where` argument doesn't exist, create a new Entitlement with this data.
     */
    create: XOR<EntitlementCreateInput, EntitlementUncheckedCreateInput>
    /**
     * In case the Entitlement was found with the provided `where` argument, update it with this data.
     */
    update: XOR<EntitlementUpdateInput, EntitlementUncheckedUpdateInput>
  }

  /**
   * Entitlement delete
   */
  export type EntitlementDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Entitlement
     */
    select?: EntitlementSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EntitlementInclude<ExtArgs> | null
    /**
     * Filter which Entitlement to delete.
     */
    where: EntitlementWhereUniqueInput
  }

  /**
   * Entitlement deleteMany
   */
  export type EntitlementDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Entitlements to delete
     */
    where?: EntitlementWhereInput
  }

  /**
   * Entitlement.device
   */
  export type Entitlement$deviceArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Device
     */
    select?: DeviceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeviceInclude<ExtArgs> | null
    where?: DeviceWhereInput
  }

  /**
   * Entitlement without action
   */
  export type EntitlementDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Entitlement
     */
    select?: EntitlementSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EntitlementInclude<ExtArgs> | null
  }


  /**
   * Model AuditLog
   */

  export type AggregateAuditLog = {
    _count: AuditLogCountAggregateOutputType | null
    _min: AuditLogMinAggregateOutputType | null
    _max: AuditLogMaxAggregateOutputType | null
  }

  export type AuditLogMinAggregateOutputType = {
    id: string | null
    tenantId: string | null
    actorUserId: string | null
    actorType: $Enums.ActorType | null
    action: string | null
    entityType: string | null
    entityId: string | null
    createdAt: Date | null
  }

  export type AuditLogMaxAggregateOutputType = {
    id: string | null
    tenantId: string | null
    actorUserId: string | null
    actorType: $Enums.ActorType | null
    action: string | null
    entityType: string | null
    entityId: string | null
    createdAt: Date | null
  }

  export type AuditLogCountAggregateOutputType = {
    id: number
    tenantId: number
    actorUserId: number
    actorType: number
    action: number
    entityType: number
    entityId: number
    metadata: number
    createdAt: number
    _all: number
  }


  export type AuditLogMinAggregateInputType = {
    id?: true
    tenantId?: true
    actorUserId?: true
    actorType?: true
    action?: true
    entityType?: true
    entityId?: true
    createdAt?: true
  }

  export type AuditLogMaxAggregateInputType = {
    id?: true
    tenantId?: true
    actorUserId?: true
    actorType?: true
    action?: true
    entityType?: true
    entityId?: true
    createdAt?: true
  }

  export type AuditLogCountAggregateInputType = {
    id?: true
    tenantId?: true
    actorUserId?: true
    actorType?: true
    action?: true
    entityType?: true
    entityId?: true
    metadata?: true
    createdAt?: true
    _all?: true
  }

  export type AuditLogAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AuditLog to aggregate.
     */
    where?: AuditLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AuditLogs to fetch.
     */
    orderBy?: AuditLogOrderByWithRelationInput | AuditLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AuditLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AuditLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AuditLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned AuditLogs
    **/
    _count?: true | AuditLogCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AuditLogMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AuditLogMaxAggregateInputType
  }

  export type GetAuditLogAggregateType<T extends AuditLogAggregateArgs> = {
        [P in keyof T & keyof AggregateAuditLog]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAuditLog[P]>
      : GetScalarType<T[P], AggregateAuditLog[P]>
  }




  export type AuditLogGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AuditLogWhereInput
    orderBy?: AuditLogOrderByWithAggregationInput | AuditLogOrderByWithAggregationInput[]
    by: AuditLogScalarFieldEnum[] | AuditLogScalarFieldEnum
    having?: AuditLogScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AuditLogCountAggregateInputType | true
    _min?: AuditLogMinAggregateInputType
    _max?: AuditLogMaxAggregateInputType
  }

  export type AuditLogGroupByOutputType = {
    id: string
    tenantId: string | null
    actorUserId: string | null
    actorType: $Enums.ActorType
    action: string
    entityType: string
    entityId: string
    metadata: JsonValue | null
    createdAt: Date
    _count: AuditLogCountAggregateOutputType | null
    _min: AuditLogMinAggregateOutputType | null
    _max: AuditLogMaxAggregateOutputType | null
  }

  type GetAuditLogGroupByPayload<T extends AuditLogGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AuditLogGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AuditLogGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AuditLogGroupByOutputType[P]>
            : GetScalarType<T[P], AuditLogGroupByOutputType[P]>
        }
      >
    >


  export type AuditLogSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tenantId?: boolean
    actorUserId?: boolean
    actorType?: boolean
    action?: boolean
    entityType?: boolean
    entityId?: boolean
    metadata?: boolean
    createdAt?: boolean
    tenant?: boolean | AuditLog$tenantArgs<ExtArgs>
  }, ExtArgs["result"]["auditLog"]>

  export type AuditLogSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tenantId?: boolean
    actorUserId?: boolean
    actorType?: boolean
    action?: boolean
    entityType?: boolean
    entityId?: boolean
    metadata?: boolean
    createdAt?: boolean
    tenant?: boolean | AuditLog$tenantArgs<ExtArgs>
  }, ExtArgs["result"]["auditLog"]>

  export type AuditLogSelectScalar = {
    id?: boolean
    tenantId?: boolean
    actorUserId?: boolean
    actorType?: boolean
    action?: boolean
    entityType?: boolean
    entityId?: boolean
    metadata?: boolean
    createdAt?: boolean
  }

  export type AuditLogInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tenant?: boolean | AuditLog$tenantArgs<ExtArgs>
  }
  export type AuditLogIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tenant?: boolean | AuditLog$tenantArgs<ExtArgs>
  }

  export type $AuditLogPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "AuditLog"
    objects: {
      tenant: Prisma.$TenantPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      tenantId: string | null
      actorUserId: string | null
      actorType: $Enums.ActorType
      action: string
      entityType: string
      entityId: string
      metadata: Prisma.JsonValue | null
      createdAt: Date
    }, ExtArgs["result"]["auditLog"]>
    composites: {}
  }

  type AuditLogGetPayload<S extends boolean | null | undefined | AuditLogDefaultArgs> = $Result.GetResult<Prisma.$AuditLogPayload, S>

  type AuditLogCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<AuditLogFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: AuditLogCountAggregateInputType | true
    }

  export interface AuditLogDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['AuditLog'], meta: { name: 'AuditLog' } }
    /**
     * Find zero or one AuditLog that matches the filter.
     * @param {AuditLogFindUniqueArgs} args - Arguments to find a AuditLog
     * @example
     * // Get one AuditLog
     * const auditLog = await prisma.auditLog.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AuditLogFindUniqueArgs>(args: SelectSubset<T, AuditLogFindUniqueArgs<ExtArgs>>): Prisma__AuditLogClient<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one AuditLog that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {AuditLogFindUniqueOrThrowArgs} args - Arguments to find a AuditLog
     * @example
     * // Get one AuditLog
     * const auditLog = await prisma.auditLog.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AuditLogFindUniqueOrThrowArgs>(args: SelectSubset<T, AuditLogFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AuditLogClient<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first AuditLog that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditLogFindFirstArgs} args - Arguments to find a AuditLog
     * @example
     * // Get one AuditLog
     * const auditLog = await prisma.auditLog.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AuditLogFindFirstArgs>(args?: SelectSubset<T, AuditLogFindFirstArgs<ExtArgs>>): Prisma__AuditLogClient<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first AuditLog that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditLogFindFirstOrThrowArgs} args - Arguments to find a AuditLog
     * @example
     * // Get one AuditLog
     * const auditLog = await prisma.auditLog.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AuditLogFindFirstOrThrowArgs>(args?: SelectSubset<T, AuditLogFindFirstOrThrowArgs<ExtArgs>>): Prisma__AuditLogClient<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more AuditLogs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditLogFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all AuditLogs
     * const auditLogs = await prisma.auditLog.findMany()
     * 
     * // Get first 10 AuditLogs
     * const auditLogs = await prisma.auditLog.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const auditLogWithIdOnly = await prisma.auditLog.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AuditLogFindManyArgs>(args?: SelectSubset<T, AuditLogFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a AuditLog.
     * @param {AuditLogCreateArgs} args - Arguments to create a AuditLog.
     * @example
     * // Create one AuditLog
     * const AuditLog = await prisma.auditLog.create({
     *   data: {
     *     // ... data to create a AuditLog
     *   }
     * })
     * 
     */
    create<T extends AuditLogCreateArgs>(args: SelectSubset<T, AuditLogCreateArgs<ExtArgs>>): Prisma__AuditLogClient<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many AuditLogs.
     * @param {AuditLogCreateManyArgs} args - Arguments to create many AuditLogs.
     * @example
     * // Create many AuditLogs
     * const auditLog = await prisma.auditLog.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AuditLogCreateManyArgs>(args?: SelectSubset<T, AuditLogCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many AuditLogs and returns the data saved in the database.
     * @param {AuditLogCreateManyAndReturnArgs} args - Arguments to create many AuditLogs.
     * @example
     * // Create many AuditLogs
     * const auditLog = await prisma.auditLog.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many AuditLogs and only return the `id`
     * const auditLogWithIdOnly = await prisma.auditLog.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AuditLogCreateManyAndReturnArgs>(args?: SelectSubset<T, AuditLogCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a AuditLog.
     * @param {AuditLogDeleteArgs} args - Arguments to delete one AuditLog.
     * @example
     * // Delete one AuditLog
     * const AuditLog = await prisma.auditLog.delete({
     *   where: {
     *     // ... filter to delete one AuditLog
     *   }
     * })
     * 
     */
    delete<T extends AuditLogDeleteArgs>(args: SelectSubset<T, AuditLogDeleteArgs<ExtArgs>>): Prisma__AuditLogClient<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one AuditLog.
     * @param {AuditLogUpdateArgs} args - Arguments to update one AuditLog.
     * @example
     * // Update one AuditLog
     * const auditLog = await prisma.auditLog.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AuditLogUpdateArgs>(args: SelectSubset<T, AuditLogUpdateArgs<ExtArgs>>): Prisma__AuditLogClient<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more AuditLogs.
     * @param {AuditLogDeleteManyArgs} args - Arguments to filter AuditLogs to delete.
     * @example
     * // Delete a few AuditLogs
     * const { count } = await prisma.auditLog.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AuditLogDeleteManyArgs>(args?: SelectSubset<T, AuditLogDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AuditLogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditLogUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many AuditLogs
     * const auditLog = await prisma.auditLog.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AuditLogUpdateManyArgs>(args: SelectSubset<T, AuditLogUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one AuditLog.
     * @param {AuditLogUpsertArgs} args - Arguments to update or create a AuditLog.
     * @example
     * // Update or create a AuditLog
     * const auditLog = await prisma.auditLog.upsert({
     *   create: {
     *     // ... data to create a AuditLog
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the AuditLog we want to update
     *   }
     * })
     */
    upsert<T extends AuditLogUpsertArgs>(args: SelectSubset<T, AuditLogUpsertArgs<ExtArgs>>): Prisma__AuditLogClient<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of AuditLogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditLogCountArgs} args - Arguments to filter AuditLogs to count.
     * @example
     * // Count the number of AuditLogs
     * const count = await prisma.auditLog.count({
     *   where: {
     *     // ... the filter for the AuditLogs we want to count
     *   }
     * })
    **/
    count<T extends AuditLogCountArgs>(
      args?: Subset<T, AuditLogCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AuditLogCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a AuditLog.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditLogAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AuditLogAggregateArgs>(args: Subset<T, AuditLogAggregateArgs>): Prisma.PrismaPromise<GetAuditLogAggregateType<T>>

    /**
     * Group by AuditLog.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditLogGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AuditLogGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AuditLogGroupByArgs['orderBy'] }
        : { orderBy?: AuditLogGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AuditLogGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAuditLogGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the AuditLog model
   */
  readonly fields: AuditLogFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for AuditLog.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AuditLogClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    tenant<T extends AuditLog$tenantArgs<ExtArgs> = {}>(args?: Subset<T, AuditLog$tenantArgs<ExtArgs>>): Prisma__TenantClient<$Result.GetResult<Prisma.$TenantPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the AuditLog model
   */ 
  interface AuditLogFieldRefs {
    readonly id: FieldRef<"AuditLog", 'String'>
    readonly tenantId: FieldRef<"AuditLog", 'String'>
    readonly actorUserId: FieldRef<"AuditLog", 'String'>
    readonly actorType: FieldRef<"AuditLog", 'ActorType'>
    readonly action: FieldRef<"AuditLog", 'String'>
    readonly entityType: FieldRef<"AuditLog", 'String'>
    readonly entityId: FieldRef<"AuditLog", 'String'>
    readonly metadata: FieldRef<"AuditLog", 'Json'>
    readonly createdAt: FieldRef<"AuditLog", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * AuditLog findUnique
   */
  export type AuditLogFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    /**
     * Filter, which AuditLog to fetch.
     */
    where: AuditLogWhereUniqueInput
  }

  /**
   * AuditLog findUniqueOrThrow
   */
  export type AuditLogFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    /**
     * Filter, which AuditLog to fetch.
     */
    where: AuditLogWhereUniqueInput
  }

  /**
   * AuditLog findFirst
   */
  export type AuditLogFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    /**
     * Filter, which AuditLog to fetch.
     */
    where?: AuditLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AuditLogs to fetch.
     */
    orderBy?: AuditLogOrderByWithRelationInput | AuditLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AuditLogs.
     */
    cursor?: AuditLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AuditLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AuditLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AuditLogs.
     */
    distinct?: AuditLogScalarFieldEnum | AuditLogScalarFieldEnum[]
  }

  /**
   * AuditLog findFirstOrThrow
   */
  export type AuditLogFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    /**
     * Filter, which AuditLog to fetch.
     */
    where?: AuditLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AuditLogs to fetch.
     */
    orderBy?: AuditLogOrderByWithRelationInput | AuditLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AuditLogs.
     */
    cursor?: AuditLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AuditLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AuditLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AuditLogs.
     */
    distinct?: AuditLogScalarFieldEnum | AuditLogScalarFieldEnum[]
  }

  /**
   * AuditLog findMany
   */
  export type AuditLogFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    /**
     * Filter, which AuditLogs to fetch.
     */
    where?: AuditLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AuditLogs to fetch.
     */
    orderBy?: AuditLogOrderByWithRelationInput | AuditLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing AuditLogs.
     */
    cursor?: AuditLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AuditLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AuditLogs.
     */
    skip?: number
    distinct?: AuditLogScalarFieldEnum | AuditLogScalarFieldEnum[]
  }

  /**
   * AuditLog create
   */
  export type AuditLogCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    /**
     * The data needed to create a AuditLog.
     */
    data: XOR<AuditLogCreateInput, AuditLogUncheckedCreateInput>
  }

  /**
   * AuditLog createMany
   */
  export type AuditLogCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many AuditLogs.
     */
    data: AuditLogCreateManyInput | AuditLogCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * AuditLog createManyAndReturn
   */
  export type AuditLogCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many AuditLogs.
     */
    data: AuditLogCreateManyInput | AuditLogCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * AuditLog update
   */
  export type AuditLogUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    /**
     * The data needed to update a AuditLog.
     */
    data: XOR<AuditLogUpdateInput, AuditLogUncheckedUpdateInput>
    /**
     * Choose, which AuditLog to update.
     */
    where: AuditLogWhereUniqueInput
  }

  /**
   * AuditLog updateMany
   */
  export type AuditLogUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update AuditLogs.
     */
    data: XOR<AuditLogUpdateManyMutationInput, AuditLogUncheckedUpdateManyInput>
    /**
     * Filter which AuditLogs to update
     */
    where?: AuditLogWhereInput
  }

  /**
   * AuditLog upsert
   */
  export type AuditLogUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    /**
     * The filter to search for the AuditLog to update in case it exists.
     */
    where: AuditLogWhereUniqueInput
    /**
     * In case the AuditLog found by the `where` argument doesn't exist, create a new AuditLog with this data.
     */
    create: XOR<AuditLogCreateInput, AuditLogUncheckedCreateInput>
    /**
     * In case the AuditLog was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AuditLogUpdateInput, AuditLogUncheckedUpdateInput>
  }

  /**
   * AuditLog delete
   */
  export type AuditLogDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    /**
     * Filter which AuditLog to delete.
     */
    where: AuditLogWhereUniqueInput
  }

  /**
   * AuditLog deleteMany
   */
  export type AuditLogDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AuditLogs to delete
     */
    where?: AuditLogWhereInput
  }

  /**
   * AuditLog.tenant
   */
  export type AuditLog$tenantArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tenant
     */
    select?: TenantSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TenantInclude<ExtArgs> | null
    where?: TenantWhereInput
  }

  /**
   * AuditLog without action
   */
  export type AuditLogDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
  }


  /**
   * Model WeatherData
   */

  export type AggregateWeatherData = {
    _count: WeatherDataCountAggregateOutputType | null
    _min: WeatherDataMinAggregateOutputType | null
    _max: WeatherDataMaxAggregateOutputType | null
  }

  export type WeatherDataMinAggregateOutputType = {
    id: string | null
    tenantId: string | null
    siteId: string | null
    date: Date | null
    createdAt: Date | null
  }

  export type WeatherDataMaxAggregateOutputType = {
    id: string | null
    tenantId: string | null
    siteId: string | null
    date: Date | null
    createdAt: Date | null
  }

  export type WeatherDataCountAggregateOutputType = {
    id: number
    tenantId: number
    siteId: number
    date: number
    summary: number
    createdAt: number
    _all: number
  }


  export type WeatherDataMinAggregateInputType = {
    id?: true
    tenantId?: true
    siteId?: true
    date?: true
    createdAt?: true
  }

  export type WeatherDataMaxAggregateInputType = {
    id?: true
    tenantId?: true
    siteId?: true
    date?: true
    createdAt?: true
  }

  export type WeatherDataCountAggregateInputType = {
    id?: true
    tenantId?: true
    siteId?: true
    date?: true
    summary?: true
    createdAt?: true
    _all?: true
  }

  export type WeatherDataAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which WeatherData to aggregate.
     */
    where?: WeatherDataWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WeatherData to fetch.
     */
    orderBy?: WeatherDataOrderByWithRelationInput | WeatherDataOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: WeatherDataWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WeatherData from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WeatherData.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned WeatherData
    **/
    _count?: true | WeatherDataCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: WeatherDataMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: WeatherDataMaxAggregateInputType
  }

  export type GetWeatherDataAggregateType<T extends WeatherDataAggregateArgs> = {
        [P in keyof T & keyof AggregateWeatherData]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateWeatherData[P]>
      : GetScalarType<T[P], AggregateWeatherData[P]>
  }




  export type WeatherDataGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: WeatherDataWhereInput
    orderBy?: WeatherDataOrderByWithAggregationInput | WeatherDataOrderByWithAggregationInput[]
    by: WeatherDataScalarFieldEnum[] | WeatherDataScalarFieldEnum
    having?: WeatherDataScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: WeatherDataCountAggregateInputType | true
    _min?: WeatherDataMinAggregateInputType
    _max?: WeatherDataMaxAggregateInputType
  }

  export type WeatherDataGroupByOutputType = {
    id: string
    tenantId: string
    siteId: string
    date: Date
    summary: JsonValue
    createdAt: Date
    _count: WeatherDataCountAggregateOutputType | null
    _min: WeatherDataMinAggregateOutputType | null
    _max: WeatherDataMaxAggregateOutputType | null
  }

  type GetWeatherDataGroupByPayload<T extends WeatherDataGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<WeatherDataGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof WeatherDataGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], WeatherDataGroupByOutputType[P]>
            : GetScalarType<T[P], WeatherDataGroupByOutputType[P]>
        }
      >
    >


  export type WeatherDataSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tenantId?: boolean
    siteId?: boolean
    date?: boolean
    summary?: boolean
    createdAt?: boolean
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
    site?: boolean | SiteDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["weatherData"]>

  export type WeatherDataSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tenantId?: boolean
    siteId?: boolean
    date?: boolean
    summary?: boolean
    createdAt?: boolean
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
    site?: boolean | SiteDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["weatherData"]>

  export type WeatherDataSelectScalar = {
    id?: boolean
    tenantId?: boolean
    siteId?: boolean
    date?: boolean
    summary?: boolean
    createdAt?: boolean
  }

  export type WeatherDataInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
    site?: boolean | SiteDefaultArgs<ExtArgs>
  }
  export type WeatherDataIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
    site?: boolean | SiteDefaultArgs<ExtArgs>
  }

  export type $WeatherDataPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "WeatherData"
    objects: {
      tenant: Prisma.$TenantPayload<ExtArgs>
      site: Prisma.$SitePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      tenantId: string
      siteId: string
      date: Date
      summary: Prisma.JsonValue
      createdAt: Date
    }, ExtArgs["result"]["weatherData"]>
    composites: {}
  }

  type WeatherDataGetPayload<S extends boolean | null | undefined | WeatherDataDefaultArgs> = $Result.GetResult<Prisma.$WeatherDataPayload, S>

  type WeatherDataCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<WeatherDataFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: WeatherDataCountAggregateInputType | true
    }

  export interface WeatherDataDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['WeatherData'], meta: { name: 'WeatherData' } }
    /**
     * Find zero or one WeatherData that matches the filter.
     * @param {WeatherDataFindUniqueArgs} args - Arguments to find a WeatherData
     * @example
     * // Get one WeatherData
     * const weatherData = await prisma.weatherData.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends WeatherDataFindUniqueArgs>(args: SelectSubset<T, WeatherDataFindUniqueArgs<ExtArgs>>): Prisma__WeatherDataClient<$Result.GetResult<Prisma.$WeatherDataPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one WeatherData that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {WeatherDataFindUniqueOrThrowArgs} args - Arguments to find a WeatherData
     * @example
     * // Get one WeatherData
     * const weatherData = await prisma.weatherData.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends WeatherDataFindUniqueOrThrowArgs>(args: SelectSubset<T, WeatherDataFindUniqueOrThrowArgs<ExtArgs>>): Prisma__WeatherDataClient<$Result.GetResult<Prisma.$WeatherDataPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first WeatherData that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WeatherDataFindFirstArgs} args - Arguments to find a WeatherData
     * @example
     * // Get one WeatherData
     * const weatherData = await prisma.weatherData.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends WeatherDataFindFirstArgs>(args?: SelectSubset<T, WeatherDataFindFirstArgs<ExtArgs>>): Prisma__WeatherDataClient<$Result.GetResult<Prisma.$WeatherDataPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first WeatherData that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WeatherDataFindFirstOrThrowArgs} args - Arguments to find a WeatherData
     * @example
     * // Get one WeatherData
     * const weatherData = await prisma.weatherData.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends WeatherDataFindFirstOrThrowArgs>(args?: SelectSubset<T, WeatherDataFindFirstOrThrowArgs<ExtArgs>>): Prisma__WeatherDataClient<$Result.GetResult<Prisma.$WeatherDataPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more WeatherData that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WeatherDataFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all WeatherData
     * const weatherData = await prisma.weatherData.findMany()
     * 
     * // Get first 10 WeatherData
     * const weatherData = await prisma.weatherData.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const weatherDataWithIdOnly = await prisma.weatherData.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends WeatherDataFindManyArgs>(args?: SelectSubset<T, WeatherDataFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WeatherDataPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a WeatherData.
     * @param {WeatherDataCreateArgs} args - Arguments to create a WeatherData.
     * @example
     * // Create one WeatherData
     * const WeatherData = await prisma.weatherData.create({
     *   data: {
     *     // ... data to create a WeatherData
     *   }
     * })
     * 
     */
    create<T extends WeatherDataCreateArgs>(args: SelectSubset<T, WeatherDataCreateArgs<ExtArgs>>): Prisma__WeatherDataClient<$Result.GetResult<Prisma.$WeatherDataPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many WeatherData.
     * @param {WeatherDataCreateManyArgs} args - Arguments to create many WeatherData.
     * @example
     * // Create many WeatherData
     * const weatherData = await prisma.weatherData.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends WeatherDataCreateManyArgs>(args?: SelectSubset<T, WeatherDataCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many WeatherData and returns the data saved in the database.
     * @param {WeatherDataCreateManyAndReturnArgs} args - Arguments to create many WeatherData.
     * @example
     * // Create many WeatherData
     * const weatherData = await prisma.weatherData.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many WeatherData and only return the `id`
     * const weatherDataWithIdOnly = await prisma.weatherData.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends WeatherDataCreateManyAndReturnArgs>(args?: SelectSubset<T, WeatherDataCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WeatherDataPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a WeatherData.
     * @param {WeatherDataDeleteArgs} args - Arguments to delete one WeatherData.
     * @example
     * // Delete one WeatherData
     * const WeatherData = await prisma.weatherData.delete({
     *   where: {
     *     // ... filter to delete one WeatherData
     *   }
     * })
     * 
     */
    delete<T extends WeatherDataDeleteArgs>(args: SelectSubset<T, WeatherDataDeleteArgs<ExtArgs>>): Prisma__WeatherDataClient<$Result.GetResult<Prisma.$WeatherDataPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one WeatherData.
     * @param {WeatherDataUpdateArgs} args - Arguments to update one WeatherData.
     * @example
     * // Update one WeatherData
     * const weatherData = await prisma.weatherData.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends WeatherDataUpdateArgs>(args: SelectSubset<T, WeatherDataUpdateArgs<ExtArgs>>): Prisma__WeatherDataClient<$Result.GetResult<Prisma.$WeatherDataPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more WeatherData.
     * @param {WeatherDataDeleteManyArgs} args - Arguments to filter WeatherData to delete.
     * @example
     * // Delete a few WeatherData
     * const { count } = await prisma.weatherData.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends WeatherDataDeleteManyArgs>(args?: SelectSubset<T, WeatherDataDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more WeatherData.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WeatherDataUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many WeatherData
     * const weatherData = await prisma.weatherData.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends WeatherDataUpdateManyArgs>(args: SelectSubset<T, WeatherDataUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one WeatherData.
     * @param {WeatherDataUpsertArgs} args - Arguments to update or create a WeatherData.
     * @example
     * // Update or create a WeatherData
     * const weatherData = await prisma.weatherData.upsert({
     *   create: {
     *     // ... data to create a WeatherData
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the WeatherData we want to update
     *   }
     * })
     */
    upsert<T extends WeatherDataUpsertArgs>(args: SelectSubset<T, WeatherDataUpsertArgs<ExtArgs>>): Prisma__WeatherDataClient<$Result.GetResult<Prisma.$WeatherDataPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of WeatherData.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WeatherDataCountArgs} args - Arguments to filter WeatherData to count.
     * @example
     * // Count the number of WeatherData
     * const count = await prisma.weatherData.count({
     *   where: {
     *     // ... the filter for the WeatherData we want to count
     *   }
     * })
    **/
    count<T extends WeatherDataCountArgs>(
      args?: Subset<T, WeatherDataCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], WeatherDataCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a WeatherData.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WeatherDataAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends WeatherDataAggregateArgs>(args: Subset<T, WeatherDataAggregateArgs>): Prisma.PrismaPromise<GetWeatherDataAggregateType<T>>

    /**
     * Group by WeatherData.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WeatherDataGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends WeatherDataGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: WeatherDataGroupByArgs['orderBy'] }
        : { orderBy?: WeatherDataGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, WeatherDataGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetWeatherDataGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the WeatherData model
   */
  readonly fields: WeatherDataFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for WeatherData.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__WeatherDataClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    tenant<T extends TenantDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TenantDefaultArgs<ExtArgs>>): Prisma__TenantClient<$Result.GetResult<Prisma.$TenantPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    site<T extends SiteDefaultArgs<ExtArgs> = {}>(args?: Subset<T, SiteDefaultArgs<ExtArgs>>): Prisma__SiteClient<$Result.GetResult<Prisma.$SitePayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the WeatherData model
   */ 
  interface WeatherDataFieldRefs {
    readonly id: FieldRef<"WeatherData", 'String'>
    readonly tenantId: FieldRef<"WeatherData", 'String'>
    readonly siteId: FieldRef<"WeatherData", 'String'>
    readonly date: FieldRef<"WeatherData", 'DateTime'>
    readonly summary: FieldRef<"WeatherData", 'Json'>
    readonly createdAt: FieldRef<"WeatherData", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * WeatherData findUnique
   */
  export type WeatherDataFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WeatherData
     */
    select?: WeatherDataSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WeatherDataInclude<ExtArgs> | null
    /**
     * Filter, which WeatherData to fetch.
     */
    where: WeatherDataWhereUniqueInput
  }

  /**
   * WeatherData findUniqueOrThrow
   */
  export type WeatherDataFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WeatherData
     */
    select?: WeatherDataSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WeatherDataInclude<ExtArgs> | null
    /**
     * Filter, which WeatherData to fetch.
     */
    where: WeatherDataWhereUniqueInput
  }

  /**
   * WeatherData findFirst
   */
  export type WeatherDataFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WeatherData
     */
    select?: WeatherDataSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WeatherDataInclude<ExtArgs> | null
    /**
     * Filter, which WeatherData to fetch.
     */
    where?: WeatherDataWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WeatherData to fetch.
     */
    orderBy?: WeatherDataOrderByWithRelationInput | WeatherDataOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for WeatherData.
     */
    cursor?: WeatherDataWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WeatherData from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WeatherData.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of WeatherData.
     */
    distinct?: WeatherDataScalarFieldEnum | WeatherDataScalarFieldEnum[]
  }

  /**
   * WeatherData findFirstOrThrow
   */
  export type WeatherDataFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WeatherData
     */
    select?: WeatherDataSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WeatherDataInclude<ExtArgs> | null
    /**
     * Filter, which WeatherData to fetch.
     */
    where?: WeatherDataWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WeatherData to fetch.
     */
    orderBy?: WeatherDataOrderByWithRelationInput | WeatherDataOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for WeatherData.
     */
    cursor?: WeatherDataWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WeatherData from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WeatherData.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of WeatherData.
     */
    distinct?: WeatherDataScalarFieldEnum | WeatherDataScalarFieldEnum[]
  }

  /**
   * WeatherData findMany
   */
  export type WeatherDataFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WeatherData
     */
    select?: WeatherDataSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WeatherDataInclude<ExtArgs> | null
    /**
     * Filter, which WeatherData to fetch.
     */
    where?: WeatherDataWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WeatherData to fetch.
     */
    orderBy?: WeatherDataOrderByWithRelationInput | WeatherDataOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing WeatherData.
     */
    cursor?: WeatherDataWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WeatherData from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WeatherData.
     */
    skip?: number
    distinct?: WeatherDataScalarFieldEnum | WeatherDataScalarFieldEnum[]
  }

  /**
   * WeatherData create
   */
  export type WeatherDataCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WeatherData
     */
    select?: WeatherDataSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WeatherDataInclude<ExtArgs> | null
    /**
     * The data needed to create a WeatherData.
     */
    data: XOR<WeatherDataCreateInput, WeatherDataUncheckedCreateInput>
  }

  /**
   * WeatherData createMany
   */
  export type WeatherDataCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many WeatherData.
     */
    data: WeatherDataCreateManyInput | WeatherDataCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * WeatherData createManyAndReturn
   */
  export type WeatherDataCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WeatherData
     */
    select?: WeatherDataSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many WeatherData.
     */
    data: WeatherDataCreateManyInput | WeatherDataCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WeatherDataIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * WeatherData update
   */
  export type WeatherDataUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WeatherData
     */
    select?: WeatherDataSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WeatherDataInclude<ExtArgs> | null
    /**
     * The data needed to update a WeatherData.
     */
    data: XOR<WeatherDataUpdateInput, WeatherDataUncheckedUpdateInput>
    /**
     * Choose, which WeatherData to update.
     */
    where: WeatherDataWhereUniqueInput
  }

  /**
   * WeatherData updateMany
   */
  export type WeatherDataUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update WeatherData.
     */
    data: XOR<WeatherDataUpdateManyMutationInput, WeatherDataUncheckedUpdateManyInput>
    /**
     * Filter which WeatherData to update
     */
    where?: WeatherDataWhereInput
  }

  /**
   * WeatherData upsert
   */
  export type WeatherDataUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WeatherData
     */
    select?: WeatherDataSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WeatherDataInclude<ExtArgs> | null
    /**
     * The filter to search for the WeatherData to update in case it exists.
     */
    where: WeatherDataWhereUniqueInput
    /**
     * In case the WeatherData found by the `where` argument doesn't exist, create a new WeatherData with this data.
     */
    create: XOR<WeatherDataCreateInput, WeatherDataUncheckedCreateInput>
    /**
     * In case the WeatherData was found with the provided `where` argument, update it with this data.
     */
    update: XOR<WeatherDataUpdateInput, WeatherDataUncheckedUpdateInput>
  }

  /**
   * WeatherData delete
   */
  export type WeatherDataDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WeatherData
     */
    select?: WeatherDataSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WeatherDataInclude<ExtArgs> | null
    /**
     * Filter which WeatherData to delete.
     */
    where: WeatherDataWhereUniqueInput
  }

  /**
   * WeatherData deleteMany
   */
  export type WeatherDataDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which WeatherData to delete
     */
    where?: WeatherDataWhereInput
  }

  /**
   * WeatherData without action
   */
  export type WeatherDataDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WeatherData
     */
    select?: WeatherDataSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WeatherDataInclude<ExtArgs> | null
  }


  /**
   * Enums
   */

  export const TransactionIsolationLevel: {
    ReadUncommitted: 'ReadUncommitted',
    ReadCommitted: 'ReadCommitted',
    RepeatableRead: 'RepeatableRead',
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const TenantScalarFieldEnum: {
    id: 'id',
    name: 'name',
    type: 'type',
    status: 'status',
    settings: 'settings',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type TenantScalarFieldEnum = (typeof TenantScalarFieldEnum)[keyof typeof TenantScalarFieldEnum]


  export const UserScalarFieldEnum: {
    id: 'id',
    email: 'email',
    passwordHash: 'passwordHash',
    name: 'name',
    status: 'status',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type UserScalarFieldEnum = (typeof UserScalarFieldEnum)[keyof typeof UserScalarFieldEnum]


  export const MembershipScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    tenantId: 'tenantId',
    role: 'role',
    createdAt: 'createdAt'
  };

  export type MembershipScalarFieldEnum = (typeof MembershipScalarFieldEnum)[keyof typeof MembershipScalarFieldEnum]


  export const SiteScalarFieldEnum: {
    id: 'id',
    tenantId: 'tenantId',
    name: 'name',
    addressLine1: 'addressLine1',
    addressLine2: 'addressLine2',
    city: 'city',
    region: 'region',
    postalCode: 'postalCode',
    country: 'country',
    lat: 'lat',
    lon: 'lon',
    locationSource: 'locationSource',
    locationAccuracyM: 'locationAccuracyM',
    locationConfidence: 'locationConfidence',
    locationUpdatedAt: 'locationUpdatedAt',
    locationUpdatedByUserId: 'locationUpdatedByUserId',
    locationLock: 'locationLock',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type SiteScalarFieldEnum = (typeof SiteScalarFieldEnum)[keyof typeof SiteScalarFieldEnum]


  export const DeviceScalarFieldEnum: {
    id: 'id',
    tenantId: 'tenantId',
    siteId: 'siteId',
    ownerUserId: 'ownerUserId',
    model: 'model',
    serialNumber: 'serialNumber',
    name: 'name',
    notes: 'notes',
    tags: 'tags',
    status: 'status',
    lastSeenAt: 'lastSeenAt',
    firmwareVersion: 'firmwareVersion',
    simIccid: 'simIccid',
    deviceLat: 'deviceLat',
    deviceLon: 'deviceLon',
    deviceLocationTs: 'deviceLocationTs',
    deviceLocationSource: 'deviceLocationSource',
    deviceLocationAccuracyM: 'deviceLocationAccuracyM',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type DeviceScalarFieldEnum = (typeof DeviceScalarFieldEnum)[keyof typeof DeviceScalarFieldEnum]


  export const DeviceSecretScalarFieldEnum: {
    id: 'id',
    deviceId: 'deviceId',
    secretHash: 'secretHash',
    publicKey: 'publicKey',
    rotatedAt: 'rotatedAt'
  };

  export type DeviceSecretScalarFieldEnum = (typeof DeviceSecretScalarFieldEnum)[keyof typeof DeviceSecretScalarFieldEnum]


  export const TelemetryScalarFieldEnum: {
    id: 'id',
    deviceId: 'deviceId',
    ts: 'ts',
    metrics: 'metrics',
    geo: 'geo',
    createdAt: 'createdAt'
  };

  export type TelemetryScalarFieldEnum = (typeof TelemetryScalarFieldEnum)[keyof typeof TelemetryScalarFieldEnum]


  export const DeviceTwinScalarFieldEnum: {
    id: 'id',
    deviceId: 'deviceId',
    lastTs: 'lastTs',
    derivedState: 'derivedState',
    updatedAt: 'updatedAt'
  };

  export type DeviceTwinScalarFieldEnum = (typeof DeviceTwinScalarFieldEnum)[keyof typeof DeviceTwinScalarFieldEnum]


  export const CommandScalarFieldEnum: {
    id: 'id',
    deviceId: 'deviceId',
    type: 'type',
    payload: 'payload',
    status: 'status',
    requestedByUserId: 'requestedByUserId',
    requestedAt: 'requestedAt',
    deliveredAt: 'deliveredAt',
    ackAt: 'ackAt',
    errorMsg: 'errorMsg'
  };

  export type CommandScalarFieldEnum = (typeof CommandScalarFieldEnum)[keyof typeof CommandScalarFieldEnum]


  export const FirmwarePackageScalarFieldEnum: {
    id: 'id',
    version: 'version',
    fileUrl: 'fileUrl',
    checksum: 'checksum',
    releaseNotes: 'releaseNotes',
    createdAt: 'createdAt'
  };

  export type FirmwarePackageScalarFieldEnum = (typeof FirmwarePackageScalarFieldEnum)[keyof typeof FirmwarePackageScalarFieldEnum]


  export const OtaJobScalarFieldEnum: {
    id: 'id',
    tenantId: 'tenantId',
    targetType: 'targetType',
    deviceId: 'deviceId',
    groupFilter: 'groupFilter',
    firmwarePackageId: 'firmwarePackageId',
    status: 'status',
    scheduledAt: 'scheduledAt',
    startedAt: 'startedAt',
    finishedAt: 'finishedAt',
    createdByUserId: 'createdByUserId',
    progress: 'progress',
    createdAt: 'createdAt'
  };

  export type OtaJobScalarFieldEnum = (typeof OtaJobScalarFieldEnum)[keyof typeof OtaJobScalarFieldEnum]


  export const SimInfoScalarFieldEnum: {
    iccid: 'iccid',
    carrier: 'carrier',
    planName: 'planName',
    status: 'status',
    lastSyncAt: 'lastSyncAt',
    dataUsageMb: 'dataUsageMb',
    msisdn: 'msisdn',
    imsi: 'imsi',
    notes: 'notes',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type SimInfoScalarFieldEnum = (typeof SimInfoScalarFieldEnum)[keyof typeof SimInfoScalarFieldEnum]


  export const SimActionScalarFieldEnum: {
    id: 'id',
    iccid: 'iccid',
    action: 'action',
    requestedByUserId: 'requestedByUserId',
    requestedAt: 'requestedAt',
    status: 'status',
    providerRef: 'providerRef',
    errorMsg: 'errorMsg'
  };

  export type SimActionScalarFieldEnum = (typeof SimActionScalarFieldEnum)[keyof typeof SimActionScalarFieldEnum]


  export const AlertRuleScalarFieldEnum: {
    id: 'id',
    tenantId: 'tenantId',
    name: 'name',
    enabled: 'enabled',
    type: 'type',
    params: 'params',
    severity: 'severity',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type AlertRuleScalarFieldEnum = (typeof AlertRuleScalarFieldEnum)[keyof typeof AlertRuleScalarFieldEnum]


  export const AlertEventScalarFieldEnum: {
    id: 'id',
    tenantId: 'tenantId',
    deviceId: 'deviceId',
    ruleId: 'ruleId',
    severity: 'severity',
    status: 'status',
    openedAt: 'openedAt',
    acknowledgedAt: 'acknowledgedAt',
    closedAt: 'closedAt',
    details: 'details',
    dedupeKey: 'dedupeKey'
  };

  export type AlertEventScalarFieldEnum = (typeof AlertEventScalarFieldEnum)[keyof typeof AlertEventScalarFieldEnum]


  export const NotificationChannelScalarFieldEnum: {
    id: 'id',
    tenantId: 'tenantId',
    type: 'type',
    config: 'config',
    enabled: 'enabled',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type NotificationChannelScalarFieldEnum = (typeof NotificationChannelScalarFieldEnum)[keyof typeof NotificationChannelScalarFieldEnum]


  export const NotificationEventScalarFieldEnum: {
    id: 'id',
    tenantId: 'tenantId',
    channelId: 'channelId',
    alertEventId: 'alertEventId',
    status: 'status',
    payload: 'payload',
    sentAt: 'sentAt',
    errorMsg: 'errorMsg',
    createdAt: 'createdAt'
  };

  export type NotificationEventScalarFieldEnum = (typeof NotificationEventScalarFieldEnum)[keyof typeof NotificationEventScalarFieldEnum]


  export const DailyRollupScalarFieldEnum: {
    id: 'id',
    tenantId: 'tenantId',
    deviceId: 'deviceId',
    dayDate: 'dayDate',
    energyKwhDay: 'energyKwhDay',
    hotWaterUsageLitersDay: 'hotWaterUsageLitersDay',
    heaterOnMinutesDay: 'heaterOnMinutesDay',
    tankTempMinC: 'tankTempMinC',
    tankTempMaxC: 'tankTempMaxC',
    ambientTempAvgC: 'ambientTempAvgC',
    createdAt: 'createdAt'
  };

  export type DailyRollupScalarFieldEnum = (typeof DailyRollupScalarFieldEnum)[keyof typeof DailyRollupScalarFieldEnum]


  export const EntitlementScalarFieldEnum: {
    id: 'id',
    tenantId: 'tenantId',
    scope: 'scope',
    deviceId: 'deviceId',
    key: 'key',
    enabled: 'enabled',
    updatedAt: 'updatedAt'
  };

  export type EntitlementScalarFieldEnum = (typeof EntitlementScalarFieldEnum)[keyof typeof EntitlementScalarFieldEnum]


  export const AuditLogScalarFieldEnum: {
    id: 'id',
    tenantId: 'tenantId',
    actorUserId: 'actorUserId',
    actorType: 'actorType',
    action: 'action',
    entityType: 'entityType',
    entityId: 'entityId',
    metadata: 'metadata',
    createdAt: 'createdAt'
  };

  export type AuditLogScalarFieldEnum = (typeof AuditLogScalarFieldEnum)[keyof typeof AuditLogScalarFieldEnum]


  export const WeatherDataScalarFieldEnum: {
    id: 'id',
    tenantId: 'tenantId',
    siteId: 'siteId',
    date: 'date',
    summary: 'summary',
    createdAt: 'createdAt'
  };

  export type WeatherDataScalarFieldEnum = (typeof WeatherDataScalarFieldEnum)[keyof typeof WeatherDataScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const NullableJsonNullValueInput: {
    DbNull: typeof DbNull,
    JsonNull: typeof JsonNull
  };

  export type NullableJsonNullValueInput = (typeof NullableJsonNullValueInput)[keyof typeof NullableJsonNullValueInput]


  export const JsonNullValueInput: {
    JsonNull: typeof JsonNull
  };

  export type JsonNullValueInput = (typeof JsonNullValueInput)[keyof typeof JsonNullValueInput]


  export const QueryMode: {
    default: 'default',
    insensitive: 'insensitive'
  };

  export type QueryMode = (typeof QueryMode)[keyof typeof QueryMode]


  export const JsonNullValueFilter: {
    DbNull: typeof DbNull,
    JsonNull: typeof JsonNull,
    AnyNull: typeof AnyNull
  };

  export type JsonNullValueFilter = (typeof JsonNullValueFilter)[keyof typeof JsonNullValueFilter]


  export const NullsOrder: {
    first: 'first',
    last: 'last'
  };

  export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder]


  /**
   * Field references 
   */


  /**
   * Reference to a field of type 'String'
   */
  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>
    


  /**
   * Reference to a field of type 'String[]'
   */
  export type ListStringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String[]'>
    


  /**
   * Reference to a field of type 'TenantType'
   */
  export type EnumTenantTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'TenantType'>
    


  /**
   * Reference to a field of type 'TenantType[]'
   */
  export type ListEnumTenantTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'TenantType[]'>
    


  /**
   * Reference to a field of type 'TenantStatus'
   */
  export type EnumTenantStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'TenantStatus'>
    


  /**
   * Reference to a field of type 'TenantStatus[]'
   */
  export type ListEnumTenantStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'TenantStatus[]'>
    


  /**
   * Reference to a field of type 'Json'
   */
  export type JsonFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Json'>
    


  /**
   * Reference to a field of type 'DateTime'
   */
  export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>
    


  /**
   * Reference to a field of type 'DateTime[]'
   */
  export type ListDateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime[]'>
    


  /**
   * Reference to a field of type 'UserStatus'
   */
  export type EnumUserStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'UserStatus'>
    


  /**
   * Reference to a field of type 'UserStatus[]'
   */
  export type ListEnumUserStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'UserStatus[]'>
    


  /**
   * Reference to a field of type 'MembershipRole'
   */
  export type EnumMembershipRoleFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'MembershipRole'>
    


  /**
   * Reference to a field of type 'MembershipRole[]'
   */
  export type ListEnumMembershipRoleFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'MembershipRole[]'>
    


  /**
   * Reference to a field of type 'Float'
   */
  export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>
    


  /**
   * Reference to a field of type 'Float[]'
   */
  export type ListFloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float[]'>
    


  /**
   * Reference to a field of type 'LocationSource'
   */
  export type EnumLocationSourceFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'LocationSource'>
    


  /**
   * Reference to a field of type 'LocationSource[]'
   */
  export type ListEnumLocationSourceFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'LocationSource[]'>
    


  /**
   * Reference to a field of type 'Boolean'
   */
  export type BooleanFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Boolean'>
    


  /**
   * Reference to a field of type 'DeviceStatus'
   */
  export type EnumDeviceStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DeviceStatus'>
    


  /**
   * Reference to a field of type 'DeviceStatus[]'
   */
  export type ListEnumDeviceStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DeviceStatus[]'>
    


  /**
   * Reference to a field of type 'DeviceLocationSource'
   */
  export type EnumDeviceLocationSourceFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DeviceLocationSource'>
    


  /**
   * Reference to a field of type 'DeviceLocationSource[]'
   */
  export type ListEnumDeviceLocationSourceFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DeviceLocationSource[]'>
    


  /**
   * Reference to a field of type 'CommandType'
   */
  export type EnumCommandTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'CommandType'>
    


  /**
   * Reference to a field of type 'CommandType[]'
   */
  export type ListEnumCommandTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'CommandType[]'>
    


  /**
   * Reference to a field of type 'CommandStatus'
   */
  export type EnumCommandStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'CommandStatus'>
    


  /**
   * Reference to a field of type 'CommandStatus[]'
   */
  export type ListEnumCommandStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'CommandStatus[]'>
    


  /**
   * Reference to a field of type 'OtaTargetType'
   */
  export type EnumOtaTargetTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'OtaTargetType'>
    


  /**
   * Reference to a field of type 'OtaTargetType[]'
   */
  export type ListEnumOtaTargetTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'OtaTargetType[]'>
    


  /**
   * Reference to a field of type 'OtaJobStatus'
   */
  export type EnumOtaJobStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'OtaJobStatus'>
    


  /**
   * Reference to a field of type 'OtaJobStatus[]'
   */
  export type ListEnumOtaJobStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'OtaJobStatus[]'>
    


  /**
   * Reference to a field of type 'SimStatus'
   */
  export type EnumSimStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'SimStatus'>
    


  /**
   * Reference to a field of type 'SimStatus[]'
   */
  export type ListEnumSimStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'SimStatus[]'>
    


  /**
   * Reference to a field of type 'SimActionType'
   */
  export type EnumSimActionTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'SimActionType'>
    


  /**
   * Reference to a field of type 'SimActionType[]'
   */
  export type ListEnumSimActionTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'SimActionType[]'>
    


  /**
   * Reference to a field of type 'SimActionStatus'
   */
  export type EnumSimActionStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'SimActionStatus'>
    


  /**
   * Reference to a field of type 'SimActionStatus[]'
   */
  export type ListEnumSimActionStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'SimActionStatus[]'>
    


  /**
   * Reference to a field of type 'AlertRuleType'
   */
  export type EnumAlertRuleTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'AlertRuleType'>
    


  /**
   * Reference to a field of type 'AlertRuleType[]'
   */
  export type ListEnumAlertRuleTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'AlertRuleType[]'>
    


  /**
   * Reference to a field of type 'AlertSeverity'
   */
  export type EnumAlertSeverityFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'AlertSeverity'>
    


  /**
   * Reference to a field of type 'AlertSeverity[]'
   */
  export type ListEnumAlertSeverityFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'AlertSeverity[]'>
    


  /**
   * Reference to a field of type 'AlertEventStatus'
   */
  export type EnumAlertEventStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'AlertEventStatus'>
    


  /**
   * Reference to a field of type 'AlertEventStatus[]'
   */
  export type ListEnumAlertEventStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'AlertEventStatus[]'>
    


  /**
   * Reference to a field of type 'NotificationChannelType'
   */
  export type EnumNotificationChannelTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'NotificationChannelType'>
    


  /**
   * Reference to a field of type 'NotificationChannelType[]'
   */
  export type ListEnumNotificationChannelTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'NotificationChannelType[]'>
    


  /**
   * Reference to a field of type 'NotificationEventStatus'
   */
  export type EnumNotificationEventStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'NotificationEventStatus'>
    


  /**
   * Reference to a field of type 'NotificationEventStatus[]'
   */
  export type ListEnumNotificationEventStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'NotificationEventStatus[]'>
    


  /**
   * Reference to a field of type 'EntitlementScope'
   */
  export type EnumEntitlementScopeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'EntitlementScope'>
    


  /**
   * Reference to a field of type 'EntitlementScope[]'
   */
  export type ListEnumEntitlementScopeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'EntitlementScope[]'>
    


  /**
   * Reference to a field of type 'EntitlementKey'
   */
  export type EnumEntitlementKeyFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'EntitlementKey'>
    


  /**
   * Reference to a field of type 'EntitlementKey[]'
   */
  export type ListEnumEntitlementKeyFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'EntitlementKey[]'>
    


  /**
   * Reference to a field of type 'ActorType'
   */
  export type EnumActorTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ActorType'>
    


  /**
   * Reference to a field of type 'ActorType[]'
   */
  export type ListEnumActorTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ActorType[]'>
    


  /**
   * Reference to a field of type 'Int'
   */
  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>
    


  /**
   * Reference to a field of type 'Int[]'
   */
  export type ListIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int[]'>
    
  /**
   * Deep Input Types
   */


  export type TenantWhereInput = {
    AND?: TenantWhereInput | TenantWhereInput[]
    OR?: TenantWhereInput[]
    NOT?: TenantWhereInput | TenantWhereInput[]
    id?: StringFilter<"Tenant"> | string
    name?: StringFilter<"Tenant"> | string
    type?: EnumTenantTypeFilter<"Tenant"> | $Enums.TenantType
    status?: EnumTenantStatusFilter<"Tenant"> | $Enums.TenantStatus
    settings?: JsonNullableFilter<"Tenant">
    createdAt?: DateTimeFilter<"Tenant"> | Date | string
    updatedAt?: DateTimeFilter<"Tenant"> | Date | string
    memberships?: MembershipListRelationFilter
    sites?: SiteListRelationFilter
    devices?: DeviceListRelationFilter
    alertRules?: AlertRuleListRelationFilter
    alertEvents?: AlertEventListRelationFilter
    notificationChannels?: NotificationChannelListRelationFilter
    notificationEvents?: NotificationEventListRelationFilter
    dailyRollups?: DailyRollupListRelationFilter
    entitlements?: EntitlementListRelationFilter
    auditLogs?: AuditLogListRelationFilter
    otaJobs?: OtaJobListRelationFilter
    weatherData?: WeatherDataListRelationFilter
  }

  export type TenantOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    type?: SortOrder
    status?: SortOrder
    settings?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    memberships?: MembershipOrderByRelationAggregateInput
    sites?: SiteOrderByRelationAggregateInput
    devices?: DeviceOrderByRelationAggregateInput
    alertRules?: AlertRuleOrderByRelationAggregateInput
    alertEvents?: AlertEventOrderByRelationAggregateInput
    notificationChannels?: NotificationChannelOrderByRelationAggregateInput
    notificationEvents?: NotificationEventOrderByRelationAggregateInput
    dailyRollups?: DailyRollupOrderByRelationAggregateInput
    entitlements?: EntitlementOrderByRelationAggregateInput
    auditLogs?: AuditLogOrderByRelationAggregateInput
    otaJobs?: OtaJobOrderByRelationAggregateInput
    weatherData?: WeatherDataOrderByRelationAggregateInput
  }

  export type TenantWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: TenantWhereInput | TenantWhereInput[]
    OR?: TenantWhereInput[]
    NOT?: TenantWhereInput | TenantWhereInput[]
    name?: StringFilter<"Tenant"> | string
    type?: EnumTenantTypeFilter<"Tenant"> | $Enums.TenantType
    status?: EnumTenantStatusFilter<"Tenant"> | $Enums.TenantStatus
    settings?: JsonNullableFilter<"Tenant">
    createdAt?: DateTimeFilter<"Tenant"> | Date | string
    updatedAt?: DateTimeFilter<"Tenant"> | Date | string
    memberships?: MembershipListRelationFilter
    sites?: SiteListRelationFilter
    devices?: DeviceListRelationFilter
    alertRules?: AlertRuleListRelationFilter
    alertEvents?: AlertEventListRelationFilter
    notificationChannels?: NotificationChannelListRelationFilter
    notificationEvents?: NotificationEventListRelationFilter
    dailyRollups?: DailyRollupListRelationFilter
    entitlements?: EntitlementListRelationFilter
    auditLogs?: AuditLogListRelationFilter
    otaJobs?: OtaJobListRelationFilter
    weatherData?: WeatherDataListRelationFilter
  }, "id">

  export type TenantOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    type?: SortOrder
    status?: SortOrder
    settings?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: TenantCountOrderByAggregateInput
    _max?: TenantMaxOrderByAggregateInput
    _min?: TenantMinOrderByAggregateInput
  }

  export type TenantScalarWhereWithAggregatesInput = {
    AND?: TenantScalarWhereWithAggregatesInput | TenantScalarWhereWithAggregatesInput[]
    OR?: TenantScalarWhereWithAggregatesInput[]
    NOT?: TenantScalarWhereWithAggregatesInput | TenantScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Tenant"> | string
    name?: StringWithAggregatesFilter<"Tenant"> | string
    type?: EnumTenantTypeWithAggregatesFilter<"Tenant"> | $Enums.TenantType
    status?: EnumTenantStatusWithAggregatesFilter<"Tenant"> | $Enums.TenantStatus
    settings?: JsonNullableWithAggregatesFilter<"Tenant">
    createdAt?: DateTimeWithAggregatesFilter<"Tenant"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Tenant"> | Date | string
  }

  export type UserWhereInput = {
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    id?: StringFilter<"User"> | string
    email?: StringFilter<"User"> | string
    passwordHash?: StringFilter<"User"> | string
    name?: StringFilter<"User"> | string
    status?: EnumUserStatusFilter<"User"> | $Enums.UserStatus
    createdAt?: DateTimeFilter<"User"> | Date | string
    updatedAt?: DateTimeFilter<"User"> | Date | string
    memberships?: MembershipListRelationFilter
    commands?: CommandListRelationFilter
    otaJobs?: OtaJobListRelationFilter
    simActions?: SimActionListRelationFilter
    siteLocUpdates?: SiteListRelationFilter
  }

  export type UserOrderByWithRelationInput = {
    id?: SortOrder
    email?: SortOrder
    passwordHash?: SortOrder
    name?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    memberships?: MembershipOrderByRelationAggregateInput
    commands?: CommandOrderByRelationAggregateInput
    otaJobs?: OtaJobOrderByRelationAggregateInput
    simActions?: SimActionOrderByRelationAggregateInput
    siteLocUpdates?: SiteOrderByRelationAggregateInput
  }

  export type UserWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    email?: string
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    passwordHash?: StringFilter<"User"> | string
    name?: StringFilter<"User"> | string
    status?: EnumUserStatusFilter<"User"> | $Enums.UserStatus
    createdAt?: DateTimeFilter<"User"> | Date | string
    updatedAt?: DateTimeFilter<"User"> | Date | string
    memberships?: MembershipListRelationFilter
    commands?: CommandListRelationFilter
    otaJobs?: OtaJobListRelationFilter
    simActions?: SimActionListRelationFilter
    siteLocUpdates?: SiteListRelationFilter
  }, "id" | "email">

  export type UserOrderByWithAggregationInput = {
    id?: SortOrder
    email?: SortOrder
    passwordHash?: SortOrder
    name?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: UserCountOrderByAggregateInput
    _max?: UserMaxOrderByAggregateInput
    _min?: UserMinOrderByAggregateInput
  }

  export type UserScalarWhereWithAggregatesInput = {
    AND?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    OR?: UserScalarWhereWithAggregatesInput[]
    NOT?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"User"> | string
    email?: StringWithAggregatesFilter<"User"> | string
    passwordHash?: StringWithAggregatesFilter<"User"> | string
    name?: StringWithAggregatesFilter<"User"> | string
    status?: EnumUserStatusWithAggregatesFilter<"User"> | $Enums.UserStatus
    createdAt?: DateTimeWithAggregatesFilter<"User"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"User"> | Date | string
  }

  export type MembershipWhereInput = {
    AND?: MembershipWhereInput | MembershipWhereInput[]
    OR?: MembershipWhereInput[]
    NOT?: MembershipWhereInput | MembershipWhereInput[]
    id?: StringFilter<"Membership"> | string
    userId?: StringFilter<"Membership"> | string
    tenantId?: StringFilter<"Membership"> | string
    role?: EnumMembershipRoleFilter<"Membership"> | $Enums.MembershipRole
    createdAt?: DateTimeFilter<"Membership"> | Date | string
    user?: XOR<UserRelationFilter, UserWhereInput>
    tenant?: XOR<TenantRelationFilter, TenantWhereInput>
  }

  export type MembershipOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    tenantId?: SortOrder
    role?: SortOrder
    createdAt?: SortOrder
    user?: UserOrderByWithRelationInput
    tenant?: TenantOrderByWithRelationInput
  }

  export type MembershipWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    userId_tenantId?: MembershipUserIdTenantIdCompoundUniqueInput
    AND?: MembershipWhereInput | MembershipWhereInput[]
    OR?: MembershipWhereInput[]
    NOT?: MembershipWhereInput | MembershipWhereInput[]
    userId?: StringFilter<"Membership"> | string
    tenantId?: StringFilter<"Membership"> | string
    role?: EnumMembershipRoleFilter<"Membership"> | $Enums.MembershipRole
    createdAt?: DateTimeFilter<"Membership"> | Date | string
    user?: XOR<UserRelationFilter, UserWhereInput>
    tenant?: XOR<TenantRelationFilter, TenantWhereInput>
  }, "id" | "userId_tenantId">

  export type MembershipOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    tenantId?: SortOrder
    role?: SortOrder
    createdAt?: SortOrder
    _count?: MembershipCountOrderByAggregateInput
    _max?: MembershipMaxOrderByAggregateInput
    _min?: MembershipMinOrderByAggregateInput
  }

  export type MembershipScalarWhereWithAggregatesInput = {
    AND?: MembershipScalarWhereWithAggregatesInput | MembershipScalarWhereWithAggregatesInput[]
    OR?: MembershipScalarWhereWithAggregatesInput[]
    NOT?: MembershipScalarWhereWithAggregatesInput | MembershipScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Membership"> | string
    userId?: StringWithAggregatesFilter<"Membership"> | string
    tenantId?: StringWithAggregatesFilter<"Membership"> | string
    role?: EnumMembershipRoleWithAggregatesFilter<"Membership"> | $Enums.MembershipRole
    createdAt?: DateTimeWithAggregatesFilter<"Membership"> | Date | string
  }

  export type SiteWhereInput = {
    AND?: SiteWhereInput | SiteWhereInput[]
    OR?: SiteWhereInput[]
    NOT?: SiteWhereInput | SiteWhereInput[]
    id?: StringFilter<"Site"> | string
    tenantId?: StringFilter<"Site"> | string
    name?: StringFilter<"Site"> | string
    addressLine1?: StringNullableFilter<"Site"> | string | null
    addressLine2?: StringNullableFilter<"Site"> | string | null
    city?: StringNullableFilter<"Site"> | string | null
    region?: StringNullableFilter<"Site"> | string | null
    postalCode?: StringNullableFilter<"Site"> | string | null
    country?: StringNullableFilter<"Site"> | string | null
    lat?: FloatNullableFilter<"Site"> | number | null
    lon?: FloatNullableFilter<"Site"> | number | null
    locationSource?: EnumLocationSourceNullableFilter<"Site"> | $Enums.LocationSource | null
    locationAccuracyM?: FloatNullableFilter<"Site"> | number | null
    locationConfidence?: FloatNullableFilter<"Site"> | number | null
    locationUpdatedAt?: DateTimeNullableFilter<"Site"> | Date | string | null
    locationUpdatedByUserId?: StringNullableFilter<"Site"> | string | null
    locationLock?: BoolFilter<"Site"> | boolean
    createdAt?: DateTimeFilter<"Site"> | Date | string
    updatedAt?: DateTimeFilter<"Site"> | Date | string
    tenant?: XOR<TenantRelationFilter, TenantWhereInput>
    locationUpdatedBy?: XOR<UserNullableRelationFilter, UserWhereInput> | null
    devices?: DeviceListRelationFilter
    weatherData?: WeatherDataListRelationFilter
  }

  export type SiteOrderByWithRelationInput = {
    id?: SortOrder
    tenantId?: SortOrder
    name?: SortOrder
    addressLine1?: SortOrderInput | SortOrder
    addressLine2?: SortOrderInput | SortOrder
    city?: SortOrderInput | SortOrder
    region?: SortOrderInput | SortOrder
    postalCode?: SortOrderInput | SortOrder
    country?: SortOrderInput | SortOrder
    lat?: SortOrderInput | SortOrder
    lon?: SortOrderInput | SortOrder
    locationSource?: SortOrderInput | SortOrder
    locationAccuracyM?: SortOrderInput | SortOrder
    locationConfidence?: SortOrderInput | SortOrder
    locationUpdatedAt?: SortOrderInput | SortOrder
    locationUpdatedByUserId?: SortOrderInput | SortOrder
    locationLock?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    tenant?: TenantOrderByWithRelationInput
    locationUpdatedBy?: UserOrderByWithRelationInput
    devices?: DeviceOrderByRelationAggregateInput
    weatherData?: WeatherDataOrderByRelationAggregateInput
  }

  export type SiteWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: SiteWhereInput | SiteWhereInput[]
    OR?: SiteWhereInput[]
    NOT?: SiteWhereInput | SiteWhereInput[]
    tenantId?: StringFilter<"Site"> | string
    name?: StringFilter<"Site"> | string
    addressLine1?: StringNullableFilter<"Site"> | string | null
    addressLine2?: StringNullableFilter<"Site"> | string | null
    city?: StringNullableFilter<"Site"> | string | null
    region?: StringNullableFilter<"Site"> | string | null
    postalCode?: StringNullableFilter<"Site"> | string | null
    country?: StringNullableFilter<"Site"> | string | null
    lat?: FloatNullableFilter<"Site"> | number | null
    lon?: FloatNullableFilter<"Site"> | number | null
    locationSource?: EnumLocationSourceNullableFilter<"Site"> | $Enums.LocationSource | null
    locationAccuracyM?: FloatNullableFilter<"Site"> | number | null
    locationConfidence?: FloatNullableFilter<"Site"> | number | null
    locationUpdatedAt?: DateTimeNullableFilter<"Site"> | Date | string | null
    locationUpdatedByUserId?: StringNullableFilter<"Site"> | string | null
    locationLock?: BoolFilter<"Site"> | boolean
    createdAt?: DateTimeFilter<"Site"> | Date | string
    updatedAt?: DateTimeFilter<"Site"> | Date | string
    tenant?: XOR<TenantRelationFilter, TenantWhereInput>
    locationUpdatedBy?: XOR<UserNullableRelationFilter, UserWhereInput> | null
    devices?: DeviceListRelationFilter
    weatherData?: WeatherDataListRelationFilter
  }, "id">

  export type SiteOrderByWithAggregationInput = {
    id?: SortOrder
    tenantId?: SortOrder
    name?: SortOrder
    addressLine1?: SortOrderInput | SortOrder
    addressLine2?: SortOrderInput | SortOrder
    city?: SortOrderInput | SortOrder
    region?: SortOrderInput | SortOrder
    postalCode?: SortOrderInput | SortOrder
    country?: SortOrderInput | SortOrder
    lat?: SortOrderInput | SortOrder
    lon?: SortOrderInput | SortOrder
    locationSource?: SortOrderInput | SortOrder
    locationAccuracyM?: SortOrderInput | SortOrder
    locationConfidence?: SortOrderInput | SortOrder
    locationUpdatedAt?: SortOrderInput | SortOrder
    locationUpdatedByUserId?: SortOrderInput | SortOrder
    locationLock?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: SiteCountOrderByAggregateInput
    _avg?: SiteAvgOrderByAggregateInput
    _max?: SiteMaxOrderByAggregateInput
    _min?: SiteMinOrderByAggregateInput
    _sum?: SiteSumOrderByAggregateInput
  }

  export type SiteScalarWhereWithAggregatesInput = {
    AND?: SiteScalarWhereWithAggregatesInput | SiteScalarWhereWithAggregatesInput[]
    OR?: SiteScalarWhereWithAggregatesInput[]
    NOT?: SiteScalarWhereWithAggregatesInput | SiteScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Site"> | string
    tenantId?: StringWithAggregatesFilter<"Site"> | string
    name?: StringWithAggregatesFilter<"Site"> | string
    addressLine1?: StringNullableWithAggregatesFilter<"Site"> | string | null
    addressLine2?: StringNullableWithAggregatesFilter<"Site"> | string | null
    city?: StringNullableWithAggregatesFilter<"Site"> | string | null
    region?: StringNullableWithAggregatesFilter<"Site"> | string | null
    postalCode?: StringNullableWithAggregatesFilter<"Site"> | string | null
    country?: StringNullableWithAggregatesFilter<"Site"> | string | null
    lat?: FloatNullableWithAggregatesFilter<"Site"> | number | null
    lon?: FloatNullableWithAggregatesFilter<"Site"> | number | null
    locationSource?: EnumLocationSourceNullableWithAggregatesFilter<"Site"> | $Enums.LocationSource | null
    locationAccuracyM?: FloatNullableWithAggregatesFilter<"Site"> | number | null
    locationConfidence?: FloatNullableWithAggregatesFilter<"Site"> | number | null
    locationUpdatedAt?: DateTimeNullableWithAggregatesFilter<"Site"> | Date | string | null
    locationUpdatedByUserId?: StringNullableWithAggregatesFilter<"Site"> | string | null
    locationLock?: BoolWithAggregatesFilter<"Site"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"Site"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Site"> | Date | string
  }

  export type DeviceWhereInput = {
    AND?: DeviceWhereInput | DeviceWhereInput[]
    OR?: DeviceWhereInput[]
    NOT?: DeviceWhereInput | DeviceWhereInput[]
    id?: StringFilter<"Device"> | string
    tenantId?: StringFilter<"Device"> | string
    siteId?: StringNullableFilter<"Device"> | string | null
    ownerUserId?: StringNullableFilter<"Device"> | string | null
    model?: StringFilter<"Device"> | string
    serialNumber?: StringFilter<"Device"> | string
    name?: StringNullableFilter<"Device"> | string | null
    notes?: StringNullableFilter<"Device"> | string | null
    tags?: JsonNullableFilter<"Device">
    status?: EnumDeviceStatusFilter<"Device"> | $Enums.DeviceStatus
    lastSeenAt?: DateTimeNullableFilter<"Device"> | Date | string | null
    firmwareVersion?: StringNullableFilter<"Device"> | string | null
    simIccid?: StringNullableFilter<"Device"> | string | null
    deviceLat?: FloatNullableFilter<"Device"> | number | null
    deviceLon?: FloatNullableFilter<"Device"> | number | null
    deviceLocationTs?: DateTimeNullableFilter<"Device"> | Date | string | null
    deviceLocationSource?: EnumDeviceLocationSourceNullableFilter<"Device"> | $Enums.DeviceLocationSource | null
    deviceLocationAccuracyM?: FloatNullableFilter<"Device"> | number | null
    createdAt?: DateTimeFilter<"Device"> | Date | string
    updatedAt?: DateTimeFilter<"Device"> | Date | string
    tenant?: XOR<TenantRelationFilter, TenantWhereInput>
    site?: XOR<SiteNullableRelationFilter, SiteWhereInput> | null
    sim?: XOR<SimInfoNullableRelationFilter, SimInfoWhereInput> | null
    secret?: XOR<DeviceSecretNullableRelationFilter, DeviceSecretWhereInput> | null
    twin?: XOR<DeviceTwinNullableRelationFilter, DeviceTwinWhereInput> | null
    telemetry?: TelemetryListRelationFilter
    commands?: CommandListRelationFilter
    alertEvents?: AlertEventListRelationFilter
    dailyRollups?: DailyRollupListRelationFilter
    entitlements?: EntitlementListRelationFilter
  }

  export type DeviceOrderByWithRelationInput = {
    id?: SortOrder
    tenantId?: SortOrder
    siteId?: SortOrderInput | SortOrder
    ownerUserId?: SortOrderInput | SortOrder
    model?: SortOrder
    serialNumber?: SortOrder
    name?: SortOrderInput | SortOrder
    notes?: SortOrderInput | SortOrder
    tags?: SortOrderInput | SortOrder
    status?: SortOrder
    lastSeenAt?: SortOrderInput | SortOrder
    firmwareVersion?: SortOrderInput | SortOrder
    simIccid?: SortOrderInput | SortOrder
    deviceLat?: SortOrderInput | SortOrder
    deviceLon?: SortOrderInput | SortOrder
    deviceLocationTs?: SortOrderInput | SortOrder
    deviceLocationSource?: SortOrderInput | SortOrder
    deviceLocationAccuracyM?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    tenant?: TenantOrderByWithRelationInput
    site?: SiteOrderByWithRelationInput
    sim?: SimInfoOrderByWithRelationInput
    secret?: DeviceSecretOrderByWithRelationInput
    twin?: DeviceTwinOrderByWithRelationInput
    telemetry?: TelemetryOrderByRelationAggregateInput
    commands?: CommandOrderByRelationAggregateInput
    alertEvents?: AlertEventOrderByRelationAggregateInput
    dailyRollups?: DailyRollupOrderByRelationAggregateInput
    entitlements?: EntitlementOrderByRelationAggregateInput
  }

  export type DeviceWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    tenantId_serialNumber?: DeviceTenantIdSerialNumberCompoundUniqueInput
    AND?: DeviceWhereInput | DeviceWhereInput[]
    OR?: DeviceWhereInput[]
    NOT?: DeviceWhereInput | DeviceWhereInput[]
    tenantId?: StringFilter<"Device"> | string
    siteId?: StringNullableFilter<"Device"> | string | null
    ownerUserId?: StringNullableFilter<"Device"> | string | null
    model?: StringFilter<"Device"> | string
    serialNumber?: StringFilter<"Device"> | string
    name?: StringNullableFilter<"Device"> | string | null
    notes?: StringNullableFilter<"Device"> | string | null
    tags?: JsonNullableFilter<"Device">
    status?: EnumDeviceStatusFilter<"Device"> | $Enums.DeviceStatus
    lastSeenAt?: DateTimeNullableFilter<"Device"> | Date | string | null
    firmwareVersion?: StringNullableFilter<"Device"> | string | null
    simIccid?: StringNullableFilter<"Device"> | string | null
    deviceLat?: FloatNullableFilter<"Device"> | number | null
    deviceLon?: FloatNullableFilter<"Device"> | number | null
    deviceLocationTs?: DateTimeNullableFilter<"Device"> | Date | string | null
    deviceLocationSource?: EnumDeviceLocationSourceNullableFilter<"Device"> | $Enums.DeviceLocationSource | null
    deviceLocationAccuracyM?: FloatNullableFilter<"Device"> | number | null
    createdAt?: DateTimeFilter<"Device"> | Date | string
    updatedAt?: DateTimeFilter<"Device"> | Date | string
    tenant?: XOR<TenantRelationFilter, TenantWhereInput>
    site?: XOR<SiteNullableRelationFilter, SiteWhereInput> | null
    sim?: XOR<SimInfoNullableRelationFilter, SimInfoWhereInput> | null
    secret?: XOR<DeviceSecretNullableRelationFilter, DeviceSecretWhereInput> | null
    twin?: XOR<DeviceTwinNullableRelationFilter, DeviceTwinWhereInput> | null
    telemetry?: TelemetryListRelationFilter
    commands?: CommandListRelationFilter
    alertEvents?: AlertEventListRelationFilter
    dailyRollups?: DailyRollupListRelationFilter
    entitlements?: EntitlementListRelationFilter
  }, "id" | "tenantId_serialNumber">

  export type DeviceOrderByWithAggregationInput = {
    id?: SortOrder
    tenantId?: SortOrder
    siteId?: SortOrderInput | SortOrder
    ownerUserId?: SortOrderInput | SortOrder
    model?: SortOrder
    serialNumber?: SortOrder
    name?: SortOrderInput | SortOrder
    notes?: SortOrderInput | SortOrder
    tags?: SortOrderInput | SortOrder
    status?: SortOrder
    lastSeenAt?: SortOrderInput | SortOrder
    firmwareVersion?: SortOrderInput | SortOrder
    simIccid?: SortOrderInput | SortOrder
    deviceLat?: SortOrderInput | SortOrder
    deviceLon?: SortOrderInput | SortOrder
    deviceLocationTs?: SortOrderInput | SortOrder
    deviceLocationSource?: SortOrderInput | SortOrder
    deviceLocationAccuracyM?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: DeviceCountOrderByAggregateInput
    _avg?: DeviceAvgOrderByAggregateInput
    _max?: DeviceMaxOrderByAggregateInput
    _min?: DeviceMinOrderByAggregateInput
    _sum?: DeviceSumOrderByAggregateInput
  }

  export type DeviceScalarWhereWithAggregatesInput = {
    AND?: DeviceScalarWhereWithAggregatesInput | DeviceScalarWhereWithAggregatesInput[]
    OR?: DeviceScalarWhereWithAggregatesInput[]
    NOT?: DeviceScalarWhereWithAggregatesInput | DeviceScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Device"> | string
    tenantId?: StringWithAggregatesFilter<"Device"> | string
    siteId?: StringNullableWithAggregatesFilter<"Device"> | string | null
    ownerUserId?: StringNullableWithAggregatesFilter<"Device"> | string | null
    model?: StringWithAggregatesFilter<"Device"> | string
    serialNumber?: StringWithAggregatesFilter<"Device"> | string
    name?: StringNullableWithAggregatesFilter<"Device"> | string | null
    notes?: StringNullableWithAggregatesFilter<"Device"> | string | null
    tags?: JsonNullableWithAggregatesFilter<"Device">
    status?: EnumDeviceStatusWithAggregatesFilter<"Device"> | $Enums.DeviceStatus
    lastSeenAt?: DateTimeNullableWithAggregatesFilter<"Device"> | Date | string | null
    firmwareVersion?: StringNullableWithAggregatesFilter<"Device"> | string | null
    simIccid?: StringNullableWithAggregatesFilter<"Device"> | string | null
    deviceLat?: FloatNullableWithAggregatesFilter<"Device"> | number | null
    deviceLon?: FloatNullableWithAggregatesFilter<"Device"> | number | null
    deviceLocationTs?: DateTimeNullableWithAggregatesFilter<"Device"> | Date | string | null
    deviceLocationSource?: EnumDeviceLocationSourceNullableWithAggregatesFilter<"Device"> | $Enums.DeviceLocationSource | null
    deviceLocationAccuracyM?: FloatNullableWithAggregatesFilter<"Device"> | number | null
    createdAt?: DateTimeWithAggregatesFilter<"Device"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Device"> | Date | string
  }

  export type DeviceSecretWhereInput = {
    AND?: DeviceSecretWhereInput | DeviceSecretWhereInput[]
    OR?: DeviceSecretWhereInput[]
    NOT?: DeviceSecretWhereInput | DeviceSecretWhereInput[]
    id?: StringFilter<"DeviceSecret"> | string
    deviceId?: StringFilter<"DeviceSecret"> | string
    secretHash?: StringFilter<"DeviceSecret"> | string
    publicKey?: StringNullableFilter<"DeviceSecret"> | string | null
    rotatedAt?: DateTimeFilter<"DeviceSecret"> | Date | string
    device?: XOR<DeviceRelationFilter, DeviceWhereInput>
  }

  export type DeviceSecretOrderByWithRelationInput = {
    id?: SortOrder
    deviceId?: SortOrder
    secretHash?: SortOrder
    publicKey?: SortOrderInput | SortOrder
    rotatedAt?: SortOrder
    device?: DeviceOrderByWithRelationInput
  }

  export type DeviceSecretWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    deviceId?: string
    AND?: DeviceSecretWhereInput | DeviceSecretWhereInput[]
    OR?: DeviceSecretWhereInput[]
    NOT?: DeviceSecretWhereInput | DeviceSecretWhereInput[]
    secretHash?: StringFilter<"DeviceSecret"> | string
    publicKey?: StringNullableFilter<"DeviceSecret"> | string | null
    rotatedAt?: DateTimeFilter<"DeviceSecret"> | Date | string
    device?: XOR<DeviceRelationFilter, DeviceWhereInput>
  }, "id" | "deviceId">

  export type DeviceSecretOrderByWithAggregationInput = {
    id?: SortOrder
    deviceId?: SortOrder
    secretHash?: SortOrder
    publicKey?: SortOrderInput | SortOrder
    rotatedAt?: SortOrder
    _count?: DeviceSecretCountOrderByAggregateInput
    _max?: DeviceSecretMaxOrderByAggregateInput
    _min?: DeviceSecretMinOrderByAggregateInput
  }

  export type DeviceSecretScalarWhereWithAggregatesInput = {
    AND?: DeviceSecretScalarWhereWithAggregatesInput | DeviceSecretScalarWhereWithAggregatesInput[]
    OR?: DeviceSecretScalarWhereWithAggregatesInput[]
    NOT?: DeviceSecretScalarWhereWithAggregatesInput | DeviceSecretScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"DeviceSecret"> | string
    deviceId?: StringWithAggregatesFilter<"DeviceSecret"> | string
    secretHash?: StringWithAggregatesFilter<"DeviceSecret"> | string
    publicKey?: StringNullableWithAggregatesFilter<"DeviceSecret"> | string | null
    rotatedAt?: DateTimeWithAggregatesFilter<"DeviceSecret"> | Date | string
  }

  export type TelemetryWhereInput = {
    AND?: TelemetryWhereInput | TelemetryWhereInput[]
    OR?: TelemetryWhereInput[]
    NOT?: TelemetryWhereInput | TelemetryWhereInput[]
    id?: StringFilter<"Telemetry"> | string
    deviceId?: StringFilter<"Telemetry"> | string
    ts?: DateTimeFilter<"Telemetry"> | Date | string
    metrics?: JsonFilter<"Telemetry">
    geo?: JsonNullableFilter<"Telemetry">
    createdAt?: DateTimeFilter<"Telemetry"> | Date | string
    device?: XOR<DeviceRelationFilter, DeviceWhereInput>
  }

  export type TelemetryOrderByWithRelationInput = {
    id?: SortOrder
    deviceId?: SortOrder
    ts?: SortOrder
    metrics?: SortOrder
    geo?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    device?: DeviceOrderByWithRelationInput
  }

  export type TelemetryWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: TelemetryWhereInput | TelemetryWhereInput[]
    OR?: TelemetryWhereInput[]
    NOT?: TelemetryWhereInput | TelemetryWhereInput[]
    deviceId?: StringFilter<"Telemetry"> | string
    ts?: DateTimeFilter<"Telemetry"> | Date | string
    metrics?: JsonFilter<"Telemetry">
    geo?: JsonNullableFilter<"Telemetry">
    createdAt?: DateTimeFilter<"Telemetry"> | Date | string
    device?: XOR<DeviceRelationFilter, DeviceWhereInput>
  }, "id">

  export type TelemetryOrderByWithAggregationInput = {
    id?: SortOrder
    deviceId?: SortOrder
    ts?: SortOrder
    metrics?: SortOrder
    geo?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: TelemetryCountOrderByAggregateInput
    _max?: TelemetryMaxOrderByAggregateInput
    _min?: TelemetryMinOrderByAggregateInput
  }

  export type TelemetryScalarWhereWithAggregatesInput = {
    AND?: TelemetryScalarWhereWithAggregatesInput | TelemetryScalarWhereWithAggregatesInput[]
    OR?: TelemetryScalarWhereWithAggregatesInput[]
    NOT?: TelemetryScalarWhereWithAggregatesInput | TelemetryScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Telemetry"> | string
    deviceId?: StringWithAggregatesFilter<"Telemetry"> | string
    ts?: DateTimeWithAggregatesFilter<"Telemetry"> | Date | string
    metrics?: JsonWithAggregatesFilter<"Telemetry">
    geo?: JsonNullableWithAggregatesFilter<"Telemetry">
    createdAt?: DateTimeWithAggregatesFilter<"Telemetry"> | Date | string
  }

  export type DeviceTwinWhereInput = {
    AND?: DeviceTwinWhereInput | DeviceTwinWhereInput[]
    OR?: DeviceTwinWhereInput[]
    NOT?: DeviceTwinWhereInput | DeviceTwinWhereInput[]
    id?: StringFilter<"DeviceTwin"> | string
    deviceId?: StringFilter<"DeviceTwin"> | string
    lastTs?: DateTimeNullableFilter<"DeviceTwin"> | Date | string | null
    derivedState?: JsonFilter<"DeviceTwin">
    updatedAt?: DateTimeFilter<"DeviceTwin"> | Date | string
    device?: XOR<DeviceRelationFilter, DeviceWhereInput>
  }

  export type DeviceTwinOrderByWithRelationInput = {
    id?: SortOrder
    deviceId?: SortOrder
    lastTs?: SortOrderInput | SortOrder
    derivedState?: SortOrder
    updatedAt?: SortOrder
    device?: DeviceOrderByWithRelationInput
  }

  export type DeviceTwinWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    deviceId?: string
    AND?: DeviceTwinWhereInput | DeviceTwinWhereInput[]
    OR?: DeviceTwinWhereInput[]
    NOT?: DeviceTwinWhereInput | DeviceTwinWhereInput[]
    lastTs?: DateTimeNullableFilter<"DeviceTwin"> | Date | string | null
    derivedState?: JsonFilter<"DeviceTwin">
    updatedAt?: DateTimeFilter<"DeviceTwin"> | Date | string
    device?: XOR<DeviceRelationFilter, DeviceWhereInput>
  }, "id" | "deviceId">

  export type DeviceTwinOrderByWithAggregationInput = {
    id?: SortOrder
    deviceId?: SortOrder
    lastTs?: SortOrderInput | SortOrder
    derivedState?: SortOrder
    updatedAt?: SortOrder
    _count?: DeviceTwinCountOrderByAggregateInput
    _max?: DeviceTwinMaxOrderByAggregateInput
    _min?: DeviceTwinMinOrderByAggregateInput
  }

  export type DeviceTwinScalarWhereWithAggregatesInput = {
    AND?: DeviceTwinScalarWhereWithAggregatesInput | DeviceTwinScalarWhereWithAggregatesInput[]
    OR?: DeviceTwinScalarWhereWithAggregatesInput[]
    NOT?: DeviceTwinScalarWhereWithAggregatesInput | DeviceTwinScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"DeviceTwin"> | string
    deviceId?: StringWithAggregatesFilter<"DeviceTwin"> | string
    lastTs?: DateTimeNullableWithAggregatesFilter<"DeviceTwin"> | Date | string | null
    derivedState?: JsonWithAggregatesFilter<"DeviceTwin">
    updatedAt?: DateTimeWithAggregatesFilter<"DeviceTwin"> | Date | string
  }

  export type CommandWhereInput = {
    AND?: CommandWhereInput | CommandWhereInput[]
    OR?: CommandWhereInput[]
    NOT?: CommandWhereInput | CommandWhereInput[]
    id?: StringFilter<"Command"> | string
    deviceId?: StringFilter<"Command"> | string
    type?: EnumCommandTypeFilter<"Command"> | $Enums.CommandType
    payload?: JsonFilter<"Command">
    status?: EnumCommandStatusFilter<"Command"> | $Enums.CommandStatus
    requestedByUserId?: StringNullableFilter<"Command"> | string | null
    requestedAt?: DateTimeFilter<"Command"> | Date | string
    deliveredAt?: DateTimeNullableFilter<"Command"> | Date | string | null
    ackAt?: DateTimeNullableFilter<"Command"> | Date | string | null
    errorMsg?: StringNullableFilter<"Command"> | string | null
    device?: XOR<DeviceRelationFilter, DeviceWhereInput>
    requestedBy?: XOR<UserNullableRelationFilter, UserWhereInput> | null
  }

  export type CommandOrderByWithRelationInput = {
    id?: SortOrder
    deviceId?: SortOrder
    type?: SortOrder
    payload?: SortOrder
    status?: SortOrder
    requestedByUserId?: SortOrderInput | SortOrder
    requestedAt?: SortOrder
    deliveredAt?: SortOrderInput | SortOrder
    ackAt?: SortOrderInput | SortOrder
    errorMsg?: SortOrderInput | SortOrder
    device?: DeviceOrderByWithRelationInput
    requestedBy?: UserOrderByWithRelationInput
  }

  export type CommandWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: CommandWhereInput | CommandWhereInput[]
    OR?: CommandWhereInput[]
    NOT?: CommandWhereInput | CommandWhereInput[]
    deviceId?: StringFilter<"Command"> | string
    type?: EnumCommandTypeFilter<"Command"> | $Enums.CommandType
    payload?: JsonFilter<"Command">
    status?: EnumCommandStatusFilter<"Command"> | $Enums.CommandStatus
    requestedByUserId?: StringNullableFilter<"Command"> | string | null
    requestedAt?: DateTimeFilter<"Command"> | Date | string
    deliveredAt?: DateTimeNullableFilter<"Command"> | Date | string | null
    ackAt?: DateTimeNullableFilter<"Command"> | Date | string | null
    errorMsg?: StringNullableFilter<"Command"> | string | null
    device?: XOR<DeviceRelationFilter, DeviceWhereInput>
    requestedBy?: XOR<UserNullableRelationFilter, UserWhereInput> | null
  }, "id">

  export type CommandOrderByWithAggregationInput = {
    id?: SortOrder
    deviceId?: SortOrder
    type?: SortOrder
    payload?: SortOrder
    status?: SortOrder
    requestedByUserId?: SortOrderInput | SortOrder
    requestedAt?: SortOrder
    deliveredAt?: SortOrderInput | SortOrder
    ackAt?: SortOrderInput | SortOrder
    errorMsg?: SortOrderInput | SortOrder
    _count?: CommandCountOrderByAggregateInput
    _max?: CommandMaxOrderByAggregateInput
    _min?: CommandMinOrderByAggregateInput
  }

  export type CommandScalarWhereWithAggregatesInput = {
    AND?: CommandScalarWhereWithAggregatesInput | CommandScalarWhereWithAggregatesInput[]
    OR?: CommandScalarWhereWithAggregatesInput[]
    NOT?: CommandScalarWhereWithAggregatesInput | CommandScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Command"> | string
    deviceId?: StringWithAggregatesFilter<"Command"> | string
    type?: EnumCommandTypeWithAggregatesFilter<"Command"> | $Enums.CommandType
    payload?: JsonWithAggregatesFilter<"Command">
    status?: EnumCommandStatusWithAggregatesFilter<"Command"> | $Enums.CommandStatus
    requestedByUserId?: StringNullableWithAggregatesFilter<"Command"> | string | null
    requestedAt?: DateTimeWithAggregatesFilter<"Command"> | Date | string
    deliveredAt?: DateTimeNullableWithAggregatesFilter<"Command"> | Date | string | null
    ackAt?: DateTimeNullableWithAggregatesFilter<"Command"> | Date | string | null
    errorMsg?: StringNullableWithAggregatesFilter<"Command"> | string | null
  }

  export type FirmwarePackageWhereInput = {
    AND?: FirmwarePackageWhereInput | FirmwarePackageWhereInput[]
    OR?: FirmwarePackageWhereInput[]
    NOT?: FirmwarePackageWhereInput | FirmwarePackageWhereInput[]
    id?: StringFilter<"FirmwarePackage"> | string
    version?: StringFilter<"FirmwarePackage"> | string
    fileUrl?: StringFilter<"FirmwarePackage"> | string
    checksum?: StringFilter<"FirmwarePackage"> | string
    releaseNotes?: StringNullableFilter<"FirmwarePackage"> | string | null
    createdAt?: DateTimeFilter<"FirmwarePackage"> | Date | string
    otaJobs?: OtaJobListRelationFilter
  }

  export type FirmwarePackageOrderByWithRelationInput = {
    id?: SortOrder
    version?: SortOrder
    fileUrl?: SortOrder
    checksum?: SortOrder
    releaseNotes?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    otaJobs?: OtaJobOrderByRelationAggregateInput
  }

  export type FirmwarePackageWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    version?: string
    AND?: FirmwarePackageWhereInput | FirmwarePackageWhereInput[]
    OR?: FirmwarePackageWhereInput[]
    NOT?: FirmwarePackageWhereInput | FirmwarePackageWhereInput[]
    fileUrl?: StringFilter<"FirmwarePackage"> | string
    checksum?: StringFilter<"FirmwarePackage"> | string
    releaseNotes?: StringNullableFilter<"FirmwarePackage"> | string | null
    createdAt?: DateTimeFilter<"FirmwarePackage"> | Date | string
    otaJobs?: OtaJobListRelationFilter
  }, "id" | "version">

  export type FirmwarePackageOrderByWithAggregationInput = {
    id?: SortOrder
    version?: SortOrder
    fileUrl?: SortOrder
    checksum?: SortOrder
    releaseNotes?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: FirmwarePackageCountOrderByAggregateInput
    _max?: FirmwarePackageMaxOrderByAggregateInput
    _min?: FirmwarePackageMinOrderByAggregateInput
  }

  export type FirmwarePackageScalarWhereWithAggregatesInput = {
    AND?: FirmwarePackageScalarWhereWithAggregatesInput | FirmwarePackageScalarWhereWithAggregatesInput[]
    OR?: FirmwarePackageScalarWhereWithAggregatesInput[]
    NOT?: FirmwarePackageScalarWhereWithAggregatesInput | FirmwarePackageScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"FirmwarePackage"> | string
    version?: StringWithAggregatesFilter<"FirmwarePackage"> | string
    fileUrl?: StringWithAggregatesFilter<"FirmwarePackage"> | string
    checksum?: StringWithAggregatesFilter<"FirmwarePackage"> | string
    releaseNotes?: StringNullableWithAggregatesFilter<"FirmwarePackage"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"FirmwarePackage"> | Date | string
  }

  export type OtaJobWhereInput = {
    AND?: OtaJobWhereInput | OtaJobWhereInput[]
    OR?: OtaJobWhereInput[]
    NOT?: OtaJobWhereInput | OtaJobWhereInput[]
    id?: StringFilter<"OtaJob"> | string
    tenantId?: StringFilter<"OtaJob"> | string
    targetType?: EnumOtaTargetTypeFilter<"OtaJob"> | $Enums.OtaTargetType
    deviceId?: StringNullableFilter<"OtaJob"> | string | null
    groupFilter?: JsonNullableFilter<"OtaJob">
    firmwarePackageId?: StringFilter<"OtaJob"> | string
    status?: EnumOtaJobStatusFilter<"OtaJob"> | $Enums.OtaJobStatus
    scheduledAt?: DateTimeFilter<"OtaJob"> | Date | string
    startedAt?: DateTimeNullableFilter<"OtaJob"> | Date | string | null
    finishedAt?: DateTimeNullableFilter<"OtaJob"> | Date | string | null
    createdByUserId?: StringNullableFilter<"OtaJob"> | string | null
    progress?: JsonNullableFilter<"OtaJob">
    createdAt?: DateTimeFilter<"OtaJob"> | Date | string
    tenant?: XOR<TenantRelationFilter, TenantWhereInput>
    firmwarePackage?: XOR<FirmwarePackageRelationFilter, FirmwarePackageWhereInput>
    createdBy?: XOR<UserNullableRelationFilter, UserWhereInput> | null
  }

  export type OtaJobOrderByWithRelationInput = {
    id?: SortOrder
    tenantId?: SortOrder
    targetType?: SortOrder
    deviceId?: SortOrderInput | SortOrder
    groupFilter?: SortOrderInput | SortOrder
    firmwarePackageId?: SortOrder
    status?: SortOrder
    scheduledAt?: SortOrder
    startedAt?: SortOrderInput | SortOrder
    finishedAt?: SortOrderInput | SortOrder
    createdByUserId?: SortOrderInput | SortOrder
    progress?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    tenant?: TenantOrderByWithRelationInput
    firmwarePackage?: FirmwarePackageOrderByWithRelationInput
    createdBy?: UserOrderByWithRelationInput
  }

  export type OtaJobWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: OtaJobWhereInput | OtaJobWhereInput[]
    OR?: OtaJobWhereInput[]
    NOT?: OtaJobWhereInput | OtaJobWhereInput[]
    tenantId?: StringFilter<"OtaJob"> | string
    targetType?: EnumOtaTargetTypeFilter<"OtaJob"> | $Enums.OtaTargetType
    deviceId?: StringNullableFilter<"OtaJob"> | string | null
    groupFilter?: JsonNullableFilter<"OtaJob">
    firmwarePackageId?: StringFilter<"OtaJob"> | string
    status?: EnumOtaJobStatusFilter<"OtaJob"> | $Enums.OtaJobStatus
    scheduledAt?: DateTimeFilter<"OtaJob"> | Date | string
    startedAt?: DateTimeNullableFilter<"OtaJob"> | Date | string | null
    finishedAt?: DateTimeNullableFilter<"OtaJob"> | Date | string | null
    createdByUserId?: StringNullableFilter<"OtaJob"> | string | null
    progress?: JsonNullableFilter<"OtaJob">
    createdAt?: DateTimeFilter<"OtaJob"> | Date | string
    tenant?: XOR<TenantRelationFilter, TenantWhereInput>
    firmwarePackage?: XOR<FirmwarePackageRelationFilter, FirmwarePackageWhereInput>
    createdBy?: XOR<UserNullableRelationFilter, UserWhereInput> | null
  }, "id">

  export type OtaJobOrderByWithAggregationInput = {
    id?: SortOrder
    tenantId?: SortOrder
    targetType?: SortOrder
    deviceId?: SortOrderInput | SortOrder
    groupFilter?: SortOrderInput | SortOrder
    firmwarePackageId?: SortOrder
    status?: SortOrder
    scheduledAt?: SortOrder
    startedAt?: SortOrderInput | SortOrder
    finishedAt?: SortOrderInput | SortOrder
    createdByUserId?: SortOrderInput | SortOrder
    progress?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: OtaJobCountOrderByAggregateInput
    _max?: OtaJobMaxOrderByAggregateInput
    _min?: OtaJobMinOrderByAggregateInput
  }

  export type OtaJobScalarWhereWithAggregatesInput = {
    AND?: OtaJobScalarWhereWithAggregatesInput | OtaJobScalarWhereWithAggregatesInput[]
    OR?: OtaJobScalarWhereWithAggregatesInput[]
    NOT?: OtaJobScalarWhereWithAggregatesInput | OtaJobScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"OtaJob"> | string
    tenantId?: StringWithAggregatesFilter<"OtaJob"> | string
    targetType?: EnumOtaTargetTypeWithAggregatesFilter<"OtaJob"> | $Enums.OtaTargetType
    deviceId?: StringNullableWithAggregatesFilter<"OtaJob"> | string | null
    groupFilter?: JsonNullableWithAggregatesFilter<"OtaJob">
    firmwarePackageId?: StringWithAggregatesFilter<"OtaJob"> | string
    status?: EnumOtaJobStatusWithAggregatesFilter<"OtaJob"> | $Enums.OtaJobStatus
    scheduledAt?: DateTimeWithAggregatesFilter<"OtaJob"> | Date | string
    startedAt?: DateTimeNullableWithAggregatesFilter<"OtaJob"> | Date | string | null
    finishedAt?: DateTimeNullableWithAggregatesFilter<"OtaJob"> | Date | string | null
    createdByUserId?: StringNullableWithAggregatesFilter<"OtaJob"> | string | null
    progress?: JsonNullableWithAggregatesFilter<"OtaJob">
    createdAt?: DateTimeWithAggregatesFilter<"OtaJob"> | Date | string
  }

  export type SimInfoWhereInput = {
    AND?: SimInfoWhereInput | SimInfoWhereInput[]
    OR?: SimInfoWhereInput[]
    NOT?: SimInfoWhereInput | SimInfoWhereInput[]
    iccid?: StringFilter<"SimInfo"> | string
    carrier?: StringNullableFilter<"SimInfo"> | string | null
    planName?: StringNullableFilter<"SimInfo"> | string | null
    status?: EnumSimStatusFilter<"SimInfo"> | $Enums.SimStatus
    lastSyncAt?: DateTimeNullableFilter<"SimInfo"> | Date | string | null
    dataUsageMb?: FloatNullableFilter<"SimInfo"> | number | null
    msisdn?: StringNullableFilter<"SimInfo"> | string | null
    imsi?: StringNullableFilter<"SimInfo"> | string | null
    notes?: StringNullableFilter<"SimInfo"> | string | null
    createdAt?: DateTimeFilter<"SimInfo"> | Date | string
    updatedAt?: DateTimeFilter<"SimInfo"> | Date | string
    devices?: DeviceListRelationFilter
    simActions?: SimActionListRelationFilter
  }

  export type SimInfoOrderByWithRelationInput = {
    iccid?: SortOrder
    carrier?: SortOrderInput | SortOrder
    planName?: SortOrderInput | SortOrder
    status?: SortOrder
    lastSyncAt?: SortOrderInput | SortOrder
    dataUsageMb?: SortOrderInput | SortOrder
    msisdn?: SortOrderInput | SortOrder
    imsi?: SortOrderInput | SortOrder
    notes?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    devices?: DeviceOrderByRelationAggregateInput
    simActions?: SimActionOrderByRelationAggregateInput
  }

  export type SimInfoWhereUniqueInput = Prisma.AtLeast<{
    iccid?: string
    AND?: SimInfoWhereInput | SimInfoWhereInput[]
    OR?: SimInfoWhereInput[]
    NOT?: SimInfoWhereInput | SimInfoWhereInput[]
    carrier?: StringNullableFilter<"SimInfo"> | string | null
    planName?: StringNullableFilter<"SimInfo"> | string | null
    status?: EnumSimStatusFilter<"SimInfo"> | $Enums.SimStatus
    lastSyncAt?: DateTimeNullableFilter<"SimInfo"> | Date | string | null
    dataUsageMb?: FloatNullableFilter<"SimInfo"> | number | null
    msisdn?: StringNullableFilter<"SimInfo"> | string | null
    imsi?: StringNullableFilter<"SimInfo"> | string | null
    notes?: StringNullableFilter<"SimInfo"> | string | null
    createdAt?: DateTimeFilter<"SimInfo"> | Date | string
    updatedAt?: DateTimeFilter<"SimInfo"> | Date | string
    devices?: DeviceListRelationFilter
    simActions?: SimActionListRelationFilter
  }, "iccid">

  export type SimInfoOrderByWithAggregationInput = {
    iccid?: SortOrder
    carrier?: SortOrderInput | SortOrder
    planName?: SortOrderInput | SortOrder
    status?: SortOrder
    lastSyncAt?: SortOrderInput | SortOrder
    dataUsageMb?: SortOrderInput | SortOrder
    msisdn?: SortOrderInput | SortOrder
    imsi?: SortOrderInput | SortOrder
    notes?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: SimInfoCountOrderByAggregateInput
    _avg?: SimInfoAvgOrderByAggregateInput
    _max?: SimInfoMaxOrderByAggregateInput
    _min?: SimInfoMinOrderByAggregateInput
    _sum?: SimInfoSumOrderByAggregateInput
  }

  export type SimInfoScalarWhereWithAggregatesInput = {
    AND?: SimInfoScalarWhereWithAggregatesInput | SimInfoScalarWhereWithAggregatesInput[]
    OR?: SimInfoScalarWhereWithAggregatesInput[]
    NOT?: SimInfoScalarWhereWithAggregatesInput | SimInfoScalarWhereWithAggregatesInput[]
    iccid?: StringWithAggregatesFilter<"SimInfo"> | string
    carrier?: StringNullableWithAggregatesFilter<"SimInfo"> | string | null
    planName?: StringNullableWithAggregatesFilter<"SimInfo"> | string | null
    status?: EnumSimStatusWithAggregatesFilter<"SimInfo"> | $Enums.SimStatus
    lastSyncAt?: DateTimeNullableWithAggregatesFilter<"SimInfo"> | Date | string | null
    dataUsageMb?: FloatNullableWithAggregatesFilter<"SimInfo"> | number | null
    msisdn?: StringNullableWithAggregatesFilter<"SimInfo"> | string | null
    imsi?: StringNullableWithAggregatesFilter<"SimInfo"> | string | null
    notes?: StringNullableWithAggregatesFilter<"SimInfo"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"SimInfo"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"SimInfo"> | Date | string
  }

  export type SimActionWhereInput = {
    AND?: SimActionWhereInput | SimActionWhereInput[]
    OR?: SimActionWhereInput[]
    NOT?: SimActionWhereInput | SimActionWhereInput[]
    id?: StringFilter<"SimAction"> | string
    iccid?: StringFilter<"SimAction"> | string
    action?: EnumSimActionTypeFilter<"SimAction"> | $Enums.SimActionType
    requestedByUserId?: StringNullableFilter<"SimAction"> | string | null
    requestedAt?: DateTimeFilter<"SimAction"> | Date | string
    status?: EnumSimActionStatusFilter<"SimAction"> | $Enums.SimActionStatus
    providerRef?: StringNullableFilter<"SimAction"> | string | null
    errorMsg?: StringNullableFilter<"SimAction"> | string | null
    sim?: XOR<SimInfoRelationFilter, SimInfoWhereInput>
    requestedBy?: XOR<UserNullableRelationFilter, UserWhereInput> | null
  }

  export type SimActionOrderByWithRelationInput = {
    id?: SortOrder
    iccid?: SortOrder
    action?: SortOrder
    requestedByUserId?: SortOrderInput | SortOrder
    requestedAt?: SortOrder
    status?: SortOrder
    providerRef?: SortOrderInput | SortOrder
    errorMsg?: SortOrderInput | SortOrder
    sim?: SimInfoOrderByWithRelationInput
    requestedBy?: UserOrderByWithRelationInput
  }

  export type SimActionWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: SimActionWhereInput | SimActionWhereInput[]
    OR?: SimActionWhereInput[]
    NOT?: SimActionWhereInput | SimActionWhereInput[]
    iccid?: StringFilter<"SimAction"> | string
    action?: EnumSimActionTypeFilter<"SimAction"> | $Enums.SimActionType
    requestedByUserId?: StringNullableFilter<"SimAction"> | string | null
    requestedAt?: DateTimeFilter<"SimAction"> | Date | string
    status?: EnumSimActionStatusFilter<"SimAction"> | $Enums.SimActionStatus
    providerRef?: StringNullableFilter<"SimAction"> | string | null
    errorMsg?: StringNullableFilter<"SimAction"> | string | null
    sim?: XOR<SimInfoRelationFilter, SimInfoWhereInput>
    requestedBy?: XOR<UserNullableRelationFilter, UserWhereInput> | null
  }, "id">

  export type SimActionOrderByWithAggregationInput = {
    id?: SortOrder
    iccid?: SortOrder
    action?: SortOrder
    requestedByUserId?: SortOrderInput | SortOrder
    requestedAt?: SortOrder
    status?: SortOrder
    providerRef?: SortOrderInput | SortOrder
    errorMsg?: SortOrderInput | SortOrder
    _count?: SimActionCountOrderByAggregateInput
    _max?: SimActionMaxOrderByAggregateInput
    _min?: SimActionMinOrderByAggregateInput
  }

  export type SimActionScalarWhereWithAggregatesInput = {
    AND?: SimActionScalarWhereWithAggregatesInput | SimActionScalarWhereWithAggregatesInput[]
    OR?: SimActionScalarWhereWithAggregatesInput[]
    NOT?: SimActionScalarWhereWithAggregatesInput | SimActionScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"SimAction"> | string
    iccid?: StringWithAggregatesFilter<"SimAction"> | string
    action?: EnumSimActionTypeWithAggregatesFilter<"SimAction"> | $Enums.SimActionType
    requestedByUserId?: StringNullableWithAggregatesFilter<"SimAction"> | string | null
    requestedAt?: DateTimeWithAggregatesFilter<"SimAction"> | Date | string
    status?: EnumSimActionStatusWithAggregatesFilter<"SimAction"> | $Enums.SimActionStatus
    providerRef?: StringNullableWithAggregatesFilter<"SimAction"> | string | null
    errorMsg?: StringNullableWithAggregatesFilter<"SimAction"> | string | null
  }

  export type AlertRuleWhereInput = {
    AND?: AlertRuleWhereInput | AlertRuleWhereInput[]
    OR?: AlertRuleWhereInput[]
    NOT?: AlertRuleWhereInput | AlertRuleWhereInput[]
    id?: StringFilter<"AlertRule"> | string
    tenantId?: StringFilter<"AlertRule"> | string
    name?: StringFilter<"AlertRule"> | string
    enabled?: BoolFilter<"AlertRule"> | boolean
    type?: EnumAlertRuleTypeFilter<"AlertRule"> | $Enums.AlertRuleType
    params?: JsonFilter<"AlertRule">
    severity?: EnumAlertSeverityFilter<"AlertRule"> | $Enums.AlertSeverity
    createdAt?: DateTimeFilter<"AlertRule"> | Date | string
    updatedAt?: DateTimeFilter<"AlertRule"> | Date | string
    tenant?: XOR<TenantRelationFilter, TenantWhereInput>
    alertEvents?: AlertEventListRelationFilter
  }

  export type AlertRuleOrderByWithRelationInput = {
    id?: SortOrder
    tenantId?: SortOrder
    name?: SortOrder
    enabled?: SortOrder
    type?: SortOrder
    params?: SortOrder
    severity?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    tenant?: TenantOrderByWithRelationInput
    alertEvents?: AlertEventOrderByRelationAggregateInput
  }

  export type AlertRuleWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: AlertRuleWhereInput | AlertRuleWhereInput[]
    OR?: AlertRuleWhereInput[]
    NOT?: AlertRuleWhereInput | AlertRuleWhereInput[]
    tenantId?: StringFilter<"AlertRule"> | string
    name?: StringFilter<"AlertRule"> | string
    enabled?: BoolFilter<"AlertRule"> | boolean
    type?: EnumAlertRuleTypeFilter<"AlertRule"> | $Enums.AlertRuleType
    params?: JsonFilter<"AlertRule">
    severity?: EnumAlertSeverityFilter<"AlertRule"> | $Enums.AlertSeverity
    createdAt?: DateTimeFilter<"AlertRule"> | Date | string
    updatedAt?: DateTimeFilter<"AlertRule"> | Date | string
    tenant?: XOR<TenantRelationFilter, TenantWhereInput>
    alertEvents?: AlertEventListRelationFilter
  }, "id">

  export type AlertRuleOrderByWithAggregationInput = {
    id?: SortOrder
    tenantId?: SortOrder
    name?: SortOrder
    enabled?: SortOrder
    type?: SortOrder
    params?: SortOrder
    severity?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: AlertRuleCountOrderByAggregateInput
    _max?: AlertRuleMaxOrderByAggregateInput
    _min?: AlertRuleMinOrderByAggregateInput
  }

  export type AlertRuleScalarWhereWithAggregatesInput = {
    AND?: AlertRuleScalarWhereWithAggregatesInput | AlertRuleScalarWhereWithAggregatesInput[]
    OR?: AlertRuleScalarWhereWithAggregatesInput[]
    NOT?: AlertRuleScalarWhereWithAggregatesInput | AlertRuleScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"AlertRule"> | string
    tenantId?: StringWithAggregatesFilter<"AlertRule"> | string
    name?: StringWithAggregatesFilter<"AlertRule"> | string
    enabled?: BoolWithAggregatesFilter<"AlertRule"> | boolean
    type?: EnumAlertRuleTypeWithAggregatesFilter<"AlertRule"> | $Enums.AlertRuleType
    params?: JsonWithAggregatesFilter<"AlertRule">
    severity?: EnumAlertSeverityWithAggregatesFilter<"AlertRule"> | $Enums.AlertSeverity
    createdAt?: DateTimeWithAggregatesFilter<"AlertRule"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"AlertRule"> | Date | string
  }

  export type AlertEventWhereInput = {
    AND?: AlertEventWhereInput | AlertEventWhereInput[]
    OR?: AlertEventWhereInput[]
    NOT?: AlertEventWhereInput | AlertEventWhereInput[]
    id?: StringFilter<"AlertEvent"> | string
    tenantId?: StringFilter<"AlertEvent"> | string
    deviceId?: StringFilter<"AlertEvent"> | string
    ruleId?: StringFilter<"AlertEvent"> | string
    severity?: EnumAlertSeverityFilter<"AlertEvent"> | $Enums.AlertSeverity
    status?: EnumAlertEventStatusFilter<"AlertEvent"> | $Enums.AlertEventStatus
    openedAt?: DateTimeFilter<"AlertEvent"> | Date | string
    acknowledgedAt?: DateTimeNullableFilter<"AlertEvent"> | Date | string | null
    closedAt?: DateTimeNullableFilter<"AlertEvent"> | Date | string | null
    details?: JsonNullableFilter<"AlertEvent">
    dedupeKey?: StringNullableFilter<"AlertEvent"> | string | null
    tenant?: XOR<TenantRelationFilter, TenantWhereInput>
    device?: XOR<DeviceRelationFilter, DeviceWhereInput>
    rule?: XOR<AlertRuleRelationFilter, AlertRuleWhereInput>
    notificationEvents?: NotificationEventListRelationFilter
  }

  export type AlertEventOrderByWithRelationInput = {
    id?: SortOrder
    tenantId?: SortOrder
    deviceId?: SortOrder
    ruleId?: SortOrder
    severity?: SortOrder
    status?: SortOrder
    openedAt?: SortOrder
    acknowledgedAt?: SortOrderInput | SortOrder
    closedAt?: SortOrderInput | SortOrder
    details?: SortOrderInput | SortOrder
    dedupeKey?: SortOrderInput | SortOrder
    tenant?: TenantOrderByWithRelationInput
    device?: DeviceOrderByWithRelationInput
    rule?: AlertRuleOrderByWithRelationInput
    notificationEvents?: NotificationEventOrderByRelationAggregateInput
  }

  export type AlertEventWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    dedupeKey?: string
    AND?: AlertEventWhereInput | AlertEventWhereInput[]
    OR?: AlertEventWhereInput[]
    NOT?: AlertEventWhereInput | AlertEventWhereInput[]
    tenantId?: StringFilter<"AlertEvent"> | string
    deviceId?: StringFilter<"AlertEvent"> | string
    ruleId?: StringFilter<"AlertEvent"> | string
    severity?: EnumAlertSeverityFilter<"AlertEvent"> | $Enums.AlertSeverity
    status?: EnumAlertEventStatusFilter<"AlertEvent"> | $Enums.AlertEventStatus
    openedAt?: DateTimeFilter<"AlertEvent"> | Date | string
    acknowledgedAt?: DateTimeNullableFilter<"AlertEvent"> | Date | string | null
    closedAt?: DateTimeNullableFilter<"AlertEvent"> | Date | string | null
    details?: JsonNullableFilter<"AlertEvent">
    tenant?: XOR<TenantRelationFilter, TenantWhereInput>
    device?: XOR<DeviceRelationFilter, DeviceWhereInput>
    rule?: XOR<AlertRuleRelationFilter, AlertRuleWhereInput>
    notificationEvents?: NotificationEventListRelationFilter
  }, "id" | "dedupeKey">

  export type AlertEventOrderByWithAggregationInput = {
    id?: SortOrder
    tenantId?: SortOrder
    deviceId?: SortOrder
    ruleId?: SortOrder
    severity?: SortOrder
    status?: SortOrder
    openedAt?: SortOrder
    acknowledgedAt?: SortOrderInput | SortOrder
    closedAt?: SortOrderInput | SortOrder
    details?: SortOrderInput | SortOrder
    dedupeKey?: SortOrderInput | SortOrder
    _count?: AlertEventCountOrderByAggregateInput
    _max?: AlertEventMaxOrderByAggregateInput
    _min?: AlertEventMinOrderByAggregateInput
  }

  export type AlertEventScalarWhereWithAggregatesInput = {
    AND?: AlertEventScalarWhereWithAggregatesInput | AlertEventScalarWhereWithAggregatesInput[]
    OR?: AlertEventScalarWhereWithAggregatesInput[]
    NOT?: AlertEventScalarWhereWithAggregatesInput | AlertEventScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"AlertEvent"> | string
    tenantId?: StringWithAggregatesFilter<"AlertEvent"> | string
    deviceId?: StringWithAggregatesFilter<"AlertEvent"> | string
    ruleId?: StringWithAggregatesFilter<"AlertEvent"> | string
    severity?: EnumAlertSeverityWithAggregatesFilter<"AlertEvent"> | $Enums.AlertSeverity
    status?: EnumAlertEventStatusWithAggregatesFilter<"AlertEvent"> | $Enums.AlertEventStatus
    openedAt?: DateTimeWithAggregatesFilter<"AlertEvent"> | Date | string
    acknowledgedAt?: DateTimeNullableWithAggregatesFilter<"AlertEvent"> | Date | string | null
    closedAt?: DateTimeNullableWithAggregatesFilter<"AlertEvent"> | Date | string | null
    details?: JsonNullableWithAggregatesFilter<"AlertEvent">
    dedupeKey?: StringNullableWithAggregatesFilter<"AlertEvent"> | string | null
  }

  export type NotificationChannelWhereInput = {
    AND?: NotificationChannelWhereInput | NotificationChannelWhereInput[]
    OR?: NotificationChannelWhereInput[]
    NOT?: NotificationChannelWhereInput | NotificationChannelWhereInput[]
    id?: StringFilter<"NotificationChannel"> | string
    tenantId?: StringFilter<"NotificationChannel"> | string
    type?: EnumNotificationChannelTypeFilter<"NotificationChannel"> | $Enums.NotificationChannelType
    config?: JsonFilter<"NotificationChannel">
    enabled?: BoolFilter<"NotificationChannel"> | boolean
    createdAt?: DateTimeFilter<"NotificationChannel"> | Date | string
    updatedAt?: DateTimeFilter<"NotificationChannel"> | Date | string
    tenant?: XOR<TenantRelationFilter, TenantWhereInput>
    notificationEvents?: NotificationEventListRelationFilter
  }

  export type NotificationChannelOrderByWithRelationInput = {
    id?: SortOrder
    tenantId?: SortOrder
    type?: SortOrder
    config?: SortOrder
    enabled?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    tenant?: TenantOrderByWithRelationInput
    notificationEvents?: NotificationEventOrderByRelationAggregateInput
  }

  export type NotificationChannelWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: NotificationChannelWhereInput | NotificationChannelWhereInput[]
    OR?: NotificationChannelWhereInput[]
    NOT?: NotificationChannelWhereInput | NotificationChannelWhereInput[]
    tenantId?: StringFilter<"NotificationChannel"> | string
    type?: EnumNotificationChannelTypeFilter<"NotificationChannel"> | $Enums.NotificationChannelType
    config?: JsonFilter<"NotificationChannel">
    enabled?: BoolFilter<"NotificationChannel"> | boolean
    createdAt?: DateTimeFilter<"NotificationChannel"> | Date | string
    updatedAt?: DateTimeFilter<"NotificationChannel"> | Date | string
    tenant?: XOR<TenantRelationFilter, TenantWhereInput>
    notificationEvents?: NotificationEventListRelationFilter
  }, "id">

  export type NotificationChannelOrderByWithAggregationInput = {
    id?: SortOrder
    tenantId?: SortOrder
    type?: SortOrder
    config?: SortOrder
    enabled?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: NotificationChannelCountOrderByAggregateInput
    _max?: NotificationChannelMaxOrderByAggregateInput
    _min?: NotificationChannelMinOrderByAggregateInput
  }

  export type NotificationChannelScalarWhereWithAggregatesInput = {
    AND?: NotificationChannelScalarWhereWithAggregatesInput | NotificationChannelScalarWhereWithAggregatesInput[]
    OR?: NotificationChannelScalarWhereWithAggregatesInput[]
    NOT?: NotificationChannelScalarWhereWithAggregatesInput | NotificationChannelScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"NotificationChannel"> | string
    tenantId?: StringWithAggregatesFilter<"NotificationChannel"> | string
    type?: EnumNotificationChannelTypeWithAggregatesFilter<"NotificationChannel"> | $Enums.NotificationChannelType
    config?: JsonWithAggregatesFilter<"NotificationChannel">
    enabled?: BoolWithAggregatesFilter<"NotificationChannel"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"NotificationChannel"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"NotificationChannel"> | Date | string
  }

  export type NotificationEventWhereInput = {
    AND?: NotificationEventWhereInput | NotificationEventWhereInput[]
    OR?: NotificationEventWhereInput[]
    NOT?: NotificationEventWhereInput | NotificationEventWhereInput[]
    id?: StringFilter<"NotificationEvent"> | string
    tenantId?: StringFilter<"NotificationEvent"> | string
    channelId?: StringFilter<"NotificationEvent"> | string
    alertEventId?: StringNullableFilter<"NotificationEvent"> | string | null
    status?: EnumNotificationEventStatusFilter<"NotificationEvent"> | $Enums.NotificationEventStatus
    payload?: JsonFilter<"NotificationEvent">
    sentAt?: DateTimeNullableFilter<"NotificationEvent"> | Date | string | null
    errorMsg?: StringNullableFilter<"NotificationEvent"> | string | null
    createdAt?: DateTimeFilter<"NotificationEvent"> | Date | string
    tenant?: XOR<TenantRelationFilter, TenantWhereInput>
    channel?: XOR<NotificationChannelRelationFilter, NotificationChannelWhereInput>
    alertEvent?: XOR<AlertEventNullableRelationFilter, AlertEventWhereInput> | null
  }

  export type NotificationEventOrderByWithRelationInput = {
    id?: SortOrder
    tenantId?: SortOrder
    channelId?: SortOrder
    alertEventId?: SortOrderInput | SortOrder
    status?: SortOrder
    payload?: SortOrder
    sentAt?: SortOrderInput | SortOrder
    errorMsg?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    tenant?: TenantOrderByWithRelationInput
    channel?: NotificationChannelOrderByWithRelationInput
    alertEvent?: AlertEventOrderByWithRelationInput
  }

  export type NotificationEventWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: NotificationEventWhereInput | NotificationEventWhereInput[]
    OR?: NotificationEventWhereInput[]
    NOT?: NotificationEventWhereInput | NotificationEventWhereInput[]
    tenantId?: StringFilter<"NotificationEvent"> | string
    channelId?: StringFilter<"NotificationEvent"> | string
    alertEventId?: StringNullableFilter<"NotificationEvent"> | string | null
    status?: EnumNotificationEventStatusFilter<"NotificationEvent"> | $Enums.NotificationEventStatus
    payload?: JsonFilter<"NotificationEvent">
    sentAt?: DateTimeNullableFilter<"NotificationEvent"> | Date | string | null
    errorMsg?: StringNullableFilter<"NotificationEvent"> | string | null
    createdAt?: DateTimeFilter<"NotificationEvent"> | Date | string
    tenant?: XOR<TenantRelationFilter, TenantWhereInput>
    channel?: XOR<NotificationChannelRelationFilter, NotificationChannelWhereInput>
    alertEvent?: XOR<AlertEventNullableRelationFilter, AlertEventWhereInput> | null
  }, "id">

  export type NotificationEventOrderByWithAggregationInput = {
    id?: SortOrder
    tenantId?: SortOrder
    channelId?: SortOrder
    alertEventId?: SortOrderInput | SortOrder
    status?: SortOrder
    payload?: SortOrder
    sentAt?: SortOrderInput | SortOrder
    errorMsg?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: NotificationEventCountOrderByAggregateInput
    _max?: NotificationEventMaxOrderByAggregateInput
    _min?: NotificationEventMinOrderByAggregateInput
  }

  export type NotificationEventScalarWhereWithAggregatesInput = {
    AND?: NotificationEventScalarWhereWithAggregatesInput | NotificationEventScalarWhereWithAggregatesInput[]
    OR?: NotificationEventScalarWhereWithAggregatesInput[]
    NOT?: NotificationEventScalarWhereWithAggregatesInput | NotificationEventScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"NotificationEvent"> | string
    tenantId?: StringWithAggregatesFilter<"NotificationEvent"> | string
    channelId?: StringWithAggregatesFilter<"NotificationEvent"> | string
    alertEventId?: StringNullableWithAggregatesFilter<"NotificationEvent"> | string | null
    status?: EnumNotificationEventStatusWithAggregatesFilter<"NotificationEvent"> | $Enums.NotificationEventStatus
    payload?: JsonWithAggregatesFilter<"NotificationEvent">
    sentAt?: DateTimeNullableWithAggregatesFilter<"NotificationEvent"> | Date | string | null
    errorMsg?: StringNullableWithAggregatesFilter<"NotificationEvent"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"NotificationEvent"> | Date | string
  }

  export type DailyRollupWhereInput = {
    AND?: DailyRollupWhereInput | DailyRollupWhereInput[]
    OR?: DailyRollupWhereInput[]
    NOT?: DailyRollupWhereInput | DailyRollupWhereInput[]
    id?: StringFilter<"DailyRollup"> | string
    tenantId?: StringFilter<"DailyRollup"> | string
    deviceId?: StringFilter<"DailyRollup"> | string
    dayDate?: DateTimeFilter<"DailyRollup"> | Date | string
    energyKwhDay?: FloatNullableFilter<"DailyRollup"> | number | null
    hotWaterUsageLitersDay?: FloatNullableFilter<"DailyRollup"> | number | null
    heaterOnMinutesDay?: FloatNullableFilter<"DailyRollup"> | number | null
    tankTempMinC?: FloatNullableFilter<"DailyRollup"> | number | null
    tankTempMaxC?: FloatNullableFilter<"DailyRollup"> | number | null
    ambientTempAvgC?: FloatNullableFilter<"DailyRollup"> | number | null
    createdAt?: DateTimeFilter<"DailyRollup"> | Date | string
    tenant?: XOR<TenantRelationFilter, TenantWhereInput>
    device?: XOR<DeviceRelationFilter, DeviceWhereInput>
  }

  export type DailyRollupOrderByWithRelationInput = {
    id?: SortOrder
    tenantId?: SortOrder
    deviceId?: SortOrder
    dayDate?: SortOrder
    energyKwhDay?: SortOrderInput | SortOrder
    hotWaterUsageLitersDay?: SortOrderInput | SortOrder
    heaterOnMinutesDay?: SortOrderInput | SortOrder
    tankTempMinC?: SortOrderInput | SortOrder
    tankTempMaxC?: SortOrderInput | SortOrder
    ambientTempAvgC?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    tenant?: TenantOrderByWithRelationInput
    device?: DeviceOrderByWithRelationInput
  }

  export type DailyRollupWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    deviceId_dayDate?: DailyRollupDeviceIdDayDateCompoundUniqueInput
    AND?: DailyRollupWhereInput | DailyRollupWhereInput[]
    OR?: DailyRollupWhereInput[]
    NOT?: DailyRollupWhereInput | DailyRollupWhereInput[]
    tenantId?: StringFilter<"DailyRollup"> | string
    deviceId?: StringFilter<"DailyRollup"> | string
    dayDate?: DateTimeFilter<"DailyRollup"> | Date | string
    energyKwhDay?: FloatNullableFilter<"DailyRollup"> | number | null
    hotWaterUsageLitersDay?: FloatNullableFilter<"DailyRollup"> | number | null
    heaterOnMinutesDay?: FloatNullableFilter<"DailyRollup"> | number | null
    tankTempMinC?: FloatNullableFilter<"DailyRollup"> | number | null
    tankTempMaxC?: FloatNullableFilter<"DailyRollup"> | number | null
    ambientTempAvgC?: FloatNullableFilter<"DailyRollup"> | number | null
    createdAt?: DateTimeFilter<"DailyRollup"> | Date | string
    tenant?: XOR<TenantRelationFilter, TenantWhereInput>
    device?: XOR<DeviceRelationFilter, DeviceWhereInput>
  }, "id" | "deviceId_dayDate">

  export type DailyRollupOrderByWithAggregationInput = {
    id?: SortOrder
    tenantId?: SortOrder
    deviceId?: SortOrder
    dayDate?: SortOrder
    energyKwhDay?: SortOrderInput | SortOrder
    hotWaterUsageLitersDay?: SortOrderInput | SortOrder
    heaterOnMinutesDay?: SortOrderInput | SortOrder
    tankTempMinC?: SortOrderInput | SortOrder
    tankTempMaxC?: SortOrderInput | SortOrder
    ambientTempAvgC?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: DailyRollupCountOrderByAggregateInput
    _avg?: DailyRollupAvgOrderByAggregateInput
    _max?: DailyRollupMaxOrderByAggregateInput
    _min?: DailyRollupMinOrderByAggregateInput
    _sum?: DailyRollupSumOrderByAggregateInput
  }

  export type DailyRollupScalarWhereWithAggregatesInput = {
    AND?: DailyRollupScalarWhereWithAggregatesInput | DailyRollupScalarWhereWithAggregatesInput[]
    OR?: DailyRollupScalarWhereWithAggregatesInput[]
    NOT?: DailyRollupScalarWhereWithAggregatesInput | DailyRollupScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"DailyRollup"> | string
    tenantId?: StringWithAggregatesFilter<"DailyRollup"> | string
    deviceId?: StringWithAggregatesFilter<"DailyRollup"> | string
    dayDate?: DateTimeWithAggregatesFilter<"DailyRollup"> | Date | string
    energyKwhDay?: FloatNullableWithAggregatesFilter<"DailyRollup"> | number | null
    hotWaterUsageLitersDay?: FloatNullableWithAggregatesFilter<"DailyRollup"> | number | null
    heaterOnMinutesDay?: FloatNullableWithAggregatesFilter<"DailyRollup"> | number | null
    tankTempMinC?: FloatNullableWithAggregatesFilter<"DailyRollup"> | number | null
    tankTempMaxC?: FloatNullableWithAggregatesFilter<"DailyRollup"> | number | null
    ambientTempAvgC?: FloatNullableWithAggregatesFilter<"DailyRollup"> | number | null
    createdAt?: DateTimeWithAggregatesFilter<"DailyRollup"> | Date | string
  }

  export type EntitlementWhereInput = {
    AND?: EntitlementWhereInput | EntitlementWhereInput[]
    OR?: EntitlementWhereInput[]
    NOT?: EntitlementWhereInput | EntitlementWhereInput[]
    id?: StringFilter<"Entitlement"> | string
    tenantId?: StringFilter<"Entitlement"> | string
    scope?: EnumEntitlementScopeFilter<"Entitlement"> | $Enums.EntitlementScope
    deviceId?: StringNullableFilter<"Entitlement"> | string | null
    key?: EnumEntitlementKeyFilter<"Entitlement"> | $Enums.EntitlementKey
    enabled?: BoolFilter<"Entitlement"> | boolean
    updatedAt?: DateTimeFilter<"Entitlement"> | Date | string
    tenant?: XOR<TenantRelationFilter, TenantWhereInput>
    device?: XOR<DeviceNullableRelationFilter, DeviceWhereInput> | null
  }

  export type EntitlementOrderByWithRelationInput = {
    id?: SortOrder
    tenantId?: SortOrder
    scope?: SortOrder
    deviceId?: SortOrderInput | SortOrder
    key?: SortOrder
    enabled?: SortOrder
    updatedAt?: SortOrder
    tenant?: TenantOrderByWithRelationInput
    device?: DeviceOrderByWithRelationInput
  }

  export type EntitlementWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    tenantId_key_deviceId?: EntitlementTenantIdKeyDeviceIdCompoundUniqueInput
    AND?: EntitlementWhereInput | EntitlementWhereInput[]
    OR?: EntitlementWhereInput[]
    NOT?: EntitlementWhereInput | EntitlementWhereInput[]
    tenantId?: StringFilter<"Entitlement"> | string
    scope?: EnumEntitlementScopeFilter<"Entitlement"> | $Enums.EntitlementScope
    deviceId?: StringNullableFilter<"Entitlement"> | string | null
    key?: EnumEntitlementKeyFilter<"Entitlement"> | $Enums.EntitlementKey
    enabled?: BoolFilter<"Entitlement"> | boolean
    updatedAt?: DateTimeFilter<"Entitlement"> | Date | string
    tenant?: XOR<TenantRelationFilter, TenantWhereInput>
    device?: XOR<DeviceNullableRelationFilter, DeviceWhereInput> | null
  }, "id" | "tenantId_key_deviceId">

  export type EntitlementOrderByWithAggregationInput = {
    id?: SortOrder
    tenantId?: SortOrder
    scope?: SortOrder
    deviceId?: SortOrderInput | SortOrder
    key?: SortOrder
    enabled?: SortOrder
    updatedAt?: SortOrder
    _count?: EntitlementCountOrderByAggregateInput
    _max?: EntitlementMaxOrderByAggregateInput
    _min?: EntitlementMinOrderByAggregateInput
  }

  export type EntitlementScalarWhereWithAggregatesInput = {
    AND?: EntitlementScalarWhereWithAggregatesInput | EntitlementScalarWhereWithAggregatesInput[]
    OR?: EntitlementScalarWhereWithAggregatesInput[]
    NOT?: EntitlementScalarWhereWithAggregatesInput | EntitlementScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Entitlement"> | string
    tenantId?: StringWithAggregatesFilter<"Entitlement"> | string
    scope?: EnumEntitlementScopeWithAggregatesFilter<"Entitlement"> | $Enums.EntitlementScope
    deviceId?: StringNullableWithAggregatesFilter<"Entitlement"> | string | null
    key?: EnumEntitlementKeyWithAggregatesFilter<"Entitlement"> | $Enums.EntitlementKey
    enabled?: BoolWithAggregatesFilter<"Entitlement"> | boolean
    updatedAt?: DateTimeWithAggregatesFilter<"Entitlement"> | Date | string
  }

  export type AuditLogWhereInput = {
    AND?: AuditLogWhereInput | AuditLogWhereInput[]
    OR?: AuditLogWhereInput[]
    NOT?: AuditLogWhereInput | AuditLogWhereInput[]
    id?: StringFilter<"AuditLog"> | string
    tenantId?: StringNullableFilter<"AuditLog"> | string | null
    actorUserId?: StringNullableFilter<"AuditLog"> | string | null
    actorType?: EnumActorTypeFilter<"AuditLog"> | $Enums.ActorType
    action?: StringFilter<"AuditLog"> | string
    entityType?: StringFilter<"AuditLog"> | string
    entityId?: StringFilter<"AuditLog"> | string
    metadata?: JsonNullableFilter<"AuditLog">
    createdAt?: DateTimeFilter<"AuditLog"> | Date | string
    tenant?: XOR<TenantNullableRelationFilter, TenantWhereInput> | null
  }

  export type AuditLogOrderByWithRelationInput = {
    id?: SortOrder
    tenantId?: SortOrderInput | SortOrder
    actorUserId?: SortOrderInput | SortOrder
    actorType?: SortOrder
    action?: SortOrder
    entityType?: SortOrder
    entityId?: SortOrder
    metadata?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    tenant?: TenantOrderByWithRelationInput
  }

  export type AuditLogWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: AuditLogWhereInput | AuditLogWhereInput[]
    OR?: AuditLogWhereInput[]
    NOT?: AuditLogWhereInput | AuditLogWhereInput[]
    tenantId?: StringNullableFilter<"AuditLog"> | string | null
    actorUserId?: StringNullableFilter<"AuditLog"> | string | null
    actorType?: EnumActorTypeFilter<"AuditLog"> | $Enums.ActorType
    action?: StringFilter<"AuditLog"> | string
    entityType?: StringFilter<"AuditLog"> | string
    entityId?: StringFilter<"AuditLog"> | string
    metadata?: JsonNullableFilter<"AuditLog">
    createdAt?: DateTimeFilter<"AuditLog"> | Date | string
    tenant?: XOR<TenantNullableRelationFilter, TenantWhereInput> | null
  }, "id">

  export type AuditLogOrderByWithAggregationInput = {
    id?: SortOrder
    tenantId?: SortOrderInput | SortOrder
    actorUserId?: SortOrderInput | SortOrder
    actorType?: SortOrder
    action?: SortOrder
    entityType?: SortOrder
    entityId?: SortOrder
    metadata?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: AuditLogCountOrderByAggregateInput
    _max?: AuditLogMaxOrderByAggregateInput
    _min?: AuditLogMinOrderByAggregateInput
  }

  export type AuditLogScalarWhereWithAggregatesInput = {
    AND?: AuditLogScalarWhereWithAggregatesInput | AuditLogScalarWhereWithAggregatesInput[]
    OR?: AuditLogScalarWhereWithAggregatesInput[]
    NOT?: AuditLogScalarWhereWithAggregatesInput | AuditLogScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"AuditLog"> | string
    tenantId?: StringNullableWithAggregatesFilter<"AuditLog"> | string | null
    actorUserId?: StringNullableWithAggregatesFilter<"AuditLog"> | string | null
    actorType?: EnumActorTypeWithAggregatesFilter<"AuditLog"> | $Enums.ActorType
    action?: StringWithAggregatesFilter<"AuditLog"> | string
    entityType?: StringWithAggregatesFilter<"AuditLog"> | string
    entityId?: StringWithAggregatesFilter<"AuditLog"> | string
    metadata?: JsonNullableWithAggregatesFilter<"AuditLog">
    createdAt?: DateTimeWithAggregatesFilter<"AuditLog"> | Date | string
  }

  export type WeatherDataWhereInput = {
    AND?: WeatherDataWhereInput | WeatherDataWhereInput[]
    OR?: WeatherDataWhereInput[]
    NOT?: WeatherDataWhereInput | WeatherDataWhereInput[]
    id?: StringFilter<"WeatherData"> | string
    tenantId?: StringFilter<"WeatherData"> | string
    siteId?: StringFilter<"WeatherData"> | string
    date?: DateTimeFilter<"WeatherData"> | Date | string
    summary?: JsonFilter<"WeatherData">
    createdAt?: DateTimeFilter<"WeatherData"> | Date | string
    tenant?: XOR<TenantRelationFilter, TenantWhereInput>
    site?: XOR<SiteRelationFilter, SiteWhereInput>
  }

  export type WeatherDataOrderByWithRelationInput = {
    id?: SortOrder
    tenantId?: SortOrder
    siteId?: SortOrder
    date?: SortOrder
    summary?: SortOrder
    createdAt?: SortOrder
    tenant?: TenantOrderByWithRelationInput
    site?: SiteOrderByWithRelationInput
  }

  export type WeatherDataWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    siteId_date?: WeatherDataSiteIdDateCompoundUniqueInput
    AND?: WeatherDataWhereInput | WeatherDataWhereInput[]
    OR?: WeatherDataWhereInput[]
    NOT?: WeatherDataWhereInput | WeatherDataWhereInput[]
    tenantId?: StringFilter<"WeatherData"> | string
    siteId?: StringFilter<"WeatherData"> | string
    date?: DateTimeFilter<"WeatherData"> | Date | string
    summary?: JsonFilter<"WeatherData">
    createdAt?: DateTimeFilter<"WeatherData"> | Date | string
    tenant?: XOR<TenantRelationFilter, TenantWhereInput>
    site?: XOR<SiteRelationFilter, SiteWhereInput>
  }, "id" | "siteId_date">

  export type WeatherDataOrderByWithAggregationInput = {
    id?: SortOrder
    tenantId?: SortOrder
    siteId?: SortOrder
    date?: SortOrder
    summary?: SortOrder
    createdAt?: SortOrder
    _count?: WeatherDataCountOrderByAggregateInput
    _max?: WeatherDataMaxOrderByAggregateInput
    _min?: WeatherDataMinOrderByAggregateInput
  }

  export type WeatherDataScalarWhereWithAggregatesInput = {
    AND?: WeatherDataScalarWhereWithAggregatesInput | WeatherDataScalarWhereWithAggregatesInput[]
    OR?: WeatherDataScalarWhereWithAggregatesInput[]
    NOT?: WeatherDataScalarWhereWithAggregatesInput | WeatherDataScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"WeatherData"> | string
    tenantId?: StringWithAggregatesFilter<"WeatherData"> | string
    siteId?: StringWithAggregatesFilter<"WeatherData"> | string
    date?: DateTimeWithAggregatesFilter<"WeatherData"> | Date | string
    summary?: JsonWithAggregatesFilter<"WeatherData">
    createdAt?: DateTimeWithAggregatesFilter<"WeatherData"> | Date | string
  }

  export type TenantCreateInput = {
    id?: string
    name: string
    type: $Enums.TenantType
    status?: $Enums.TenantStatus
    settings?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    memberships?: MembershipCreateNestedManyWithoutTenantInput
    sites?: SiteCreateNestedManyWithoutTenantInput
    devices?: DeviceCreateNestedManyWithoutTenantInput
    alertRules?: AlertRuleCreateNestedManyWithoutTenantInput
    alertEvents?: AlertEventCreateNestedManyWithoutTenantInput
    notificationChannels?: NotificationChannelCreateNestedManyWithoutTenantInput
    notificationEvents?: NotificationEventCreateNestedManyWithoutTenantInput
    dailyRollups?: DailyRollupCreateNestedManyWithoutTenantInput
    entitlements?: EntitlementCreateNestedManyWithoutTenantInput
    auditLogs?: AuditLogCreateNestedManyWithoutTenantInput
    otaJobs?: OtaJobCreateNestedManyWithoutTenantInput
    weatherData?: WeatherDataCreateNestedManyWithoutTenantInput
  }

  export type TenantUncheckedCreateInput = {
    id?: string
    name: string
    type: $Enums.TenantType
    status?: $Enums.TenantStatus
    settings?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    memberships?: MembershipUncheckedCreateNestedManyWithoutTenantInput
    sites?: SiteUncheckedCreateNestedManyWithoutTenantInput
    devices?: DeviceUncheckedCreateNestedManyWithoutTenantInput
    alertRules?: AlertRuleUncheckedCreateNestedManyWithoutTenantInput
    alertEvents?: AlertEventUncheckedCreateNestedManyWithoutTenantInput
    notificationChannels?: NotificationChannelUncheckedCreateNestedManyWithoutTenantInput
    notificationEvents?: NotificationEventUncheckedCreateNestedManyWithoutTenantInput
    dailyRollups?: DailyRollupUncheckedCreateNestedManyWithoutTenantInput
    entitlements?: EntitlementUncheckedCreateNestedManyWithoutTenantInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutTenantInput
    otaJobs?: OtaJobUncheckedCreateNestedManyWithoutTenantInput
    weatherData?: WeatherDataUncheckedCreateNestedManyWithoutTenantInput
  }

  export type TenantUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumTenantTypeFieldUpdateOperationsInput | $Enums.TenantType
    status?: EnumTenantStatusFieldUpdateOperationsInput | $Enums.TenantStatus
    settings?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    memberships?: MembershipUpdateManyWithoutTenantNestedInput
    sites?: SiteUpdateManyWithoutTenantNestedInput
    devices?: DeviceUpdateManyWithoutTenantNestedInput
    alertRules?: AlertRuleUpdateManyWithoutTenantNestedInput
    alertEvents?: AlertEventUpdateManyWithoutTenantNestedInput
    notificationChannels?: NotificationChannelUpdateManyWithoutTenantNestedInput
    notificationEvents?: NotificationEventUpdateManyWithoutTenantNestedInput
    dailyRollups?: DailyRollupUpdateManyWithoutTenantNestedInput
    entitlements?: EntitlementUpdateManyWithoutTenantNestedInput
    auditLogs?: AuditLogUpdateManyWithoutTenantNestedInput
    otaJobs?: OtaJobUpdateManyWithoutTenantNestedInput
    weatherData?: WeatherDataUpdateManyWithoutTenantNestedInput
  }

  export type TenantUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumTenantTypeFieldUpdateOperationsInput | $Enums.TenantType
    status?: EnumTenantStatusFieldUpdateOperationsInput | $Enums.TenantStatus
    settings?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    memberships?: MembershipUncheckedUpdateManyWithoutTenantNestedInput
    sites?: SiteUncheckedUpdateManyWithoutTenantNestedInput
    devices?: DeviceUncheckedUpdateManyWithoutTenantNestedInput
    alertRules?: AlertRuleUncheckedUpdateManyWithoutTenantNestedInput
    alertEvents?: AlertEventUncheckedUpdateManyWithoutTenantNestedInput
    notificationChannels?: NotificationChannelUncheckedUpdateManyWithoutTenantNestedInput
    notificationEvents?: NotificationEventUncheckedUpdateManyWithoutTenantNestedInput
    dailyRollups?: DailyRollupUncheckedUpdateManyWithoutTenantNestedInput
    entitlements?: EntitlementUncheckedUpdateManyWithoutTenantNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutTenantNestedInput
    otaJobs?: OtaJobUncheckedUpdateManyWithoutTenantNestedInput
    weatherData?: WeatherDataUncheckedUpdateManyWithoutTenantNestedInput
  }

  export type TenantCreateManyInput = {
    id?: string
    name: string
    type: $Enums.TenantType
    status?: $Enums.TenantStatus
    settings?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TenantUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumTenantTypeFieldUpdateOperationsInput | $Enums.TenantType
    status?: EnumTenantStatusFieldUpdateOperationsInput | $Enums.TenantStatus
    settings?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TenantUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumTenantTypeFieldUpdateOperationsInput | $Enums.TenantType
    status?: EnumTenantStatusFieldUpdateOperationsInput | $Enums.TenantStatus
    settings?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserCreateInput = {
    id?: string
    email: string
    passwordHash: string
    name: string
    status?: $Enums.UserStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    memberships?: MembershipCreateNestedManyWithoutUserInput
    commands?: CommandCreateNestedManyWithoutRequestedByInput
    otaJobs?: OtaJobCreateNestedManyWithoutCreatedByInput
    simActions?: SimActionCreateNestedManyWithoutRequestedByInput
    siteLocUpdates?: SiteCreateNestedManyWithoutLocationUpdatedByInput
  }

  export type UserUncheckedCreateInput = {
    id?: string
    email: string
    passwordHash: string
    name: string
    status?: $Enums.UserStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    memberships?: MembershipUncheckedCreateNestedManyWithoutUserInput
    commands?: CommandUncheckedCreateNestedManyWithoutRequestedByInput
    otaJobs?: OtaJobUncheckedCreateNestedManyWithoutCreatedByInput
    simActions?: SimActionUncheckedCreateNestedManyWithoutRequestedByInput
    siteLocUpdates?: SiteUncheckedCreateNestedManyWithoutLocationUpdatedByInput
  }

  export type UserUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    status?: EnumUserStatusFieldUpdateOperationsInput | $Enums.UserStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    memberships?: MembershipUpdateManyWithoutUserNestedInput
    commands?: CommandUpdateManyWithoutRequestedByNestedInput
    otaJobs?: OtaJobUpdateManyWithoutCreatedByNestedInput
    simActions?: SimActionUpdateManyWithoutRequestedByNestedInput
    siteLocUpdates?: SiteUpdateManyWithoutLocationUpdatedByNestedInput
  }

  export type UserUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    status?: EnumUserStatusFieldUpdateOperationsInput | $Enums.UserStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    memberships?: MembershipUncheckedUpdateManyWithoutUserNestedInput
    commands?: CommandUncheckedUpdateManyWithoutRequestedByNestedInput
    otaJobs?: OtaJobUncheckedUpdateManyWithoutCreatedByNestedInput
    simActions?: SimActionUncheckedUpdateManyWithoutRequestedByNestedInput
    siteLocUpdates?: SiteUncheckedUpdateManyWithoutLocationUpdatedByNestedInput
  }

  export type UserCreateManyInput = {
    id?: string
    email: string
    passwordHash: string
    name: string
    status?: $Enums.UserStatus
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    status?: EnumUserStatusFieldUpdateOperationsInput | $Enums.UserStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    status?: EnumUserStatusFieldUpdateOperationsInput | $Enums.UserStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MembershipCreateInput = {
    id?: string
    role: $Enums.MembershipRole
    createdAt?: Date | string
    user: UserCreateNestedOneWithoutMembershipsInput
    tenant: TenantCreateNestedOneWithoutMembershipsInput
  }

  export type MembershipUncheckedCreateInput = {
    id?: string
    userId: string
    tenantId: string
    role: $Enums.MembershipRole
    createdAt?: Date | string
  }

  export type MembershipUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    role?: EnumMembershipRoleFieldUpdateOperationsInput | $Enums.MembershipRole
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutMembershipsNestedInput
    tenant?: TenantUpdateOneRequiredWithoutMembershipsNestedInput
  }

  export type MembershipUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    role?: EnumMembershipRoleFieldUpdateOperationsInput | $Enums.MembershipRole
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MembershipCreateManyInput = {
    id?: string
    userId: string
    tenantId: string
    role: $Enums.MembershipRole
    createdAt?: Date | string
  }

  export type MembershipUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    role?: EnumMembershipRoleFieldUpdateOperationsInput | $Enums.MembershipRole
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MembershipUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    role?: EnumMembershipRoleFieldUpdateOperationsInput | $Enums.MembershipRole
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SiteCreateInput = {
    id?: string
    name: string
    addressLine1?: string | null
    addressLine2?: string | null
    city?: string | null
    region?: string | null
    postalCode?: string | null
    country?: string | null
    lat?: number | null
    lon?: number | null
    locationSource?: $Enums.LocationSource | null
    locationAccuracyM?: number | null
    locationConfidence?: number | null
    locationUpdatedAt?: Date | string | null
    locationLock?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    tenant: TenantCreateNestedOneWithoutSitesInput
    locationUpdatedBy?: UserCreateNestedOneWithoutSiteLocUpdatesInput
    devices?: DeviceCreateNestedManyWithoutSiteInput
    weatherData?: WeatherDataCreateNestedManyWithoutSiteInput
  }

  export type SiteUncheckedCreateInput = {
    id?: string
    tenantId: string
    name: string
    addressLine1?: string | null
    addressLine2?: string | null
    city?: string | null
    region?: string | null
    postalCode?: string | null
    country?: string | null
    lat?: number | null
    lon?: number | null
    locationSource?: $Enums.LocationSource | null
    locationAccuracyM?: number | null
    locationConfidence?: number | null
    locationUpdatedAt?: Date | string | null
    locationUpdatedByUserId?: string | null
    locationLock?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    devices?: DeviceUncheckedCreateNestedManyWithoutSiteInput
    weatherData?: WeatherDataUncheckedCreateNestedManyWithoutSiteInput
  }

  export type SiteUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    addressLine1?: NullableStringFieldUpdateOperationsInput | string | null
    addressLine2?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    region?: NullableStringFieldUpdateOperationsInput | string | null
    postalCode?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    lat?: NullableFloatFieldUpdateOperationsInput | number | null
    lon?: NullableFloatFieldUpdateOperationsInput | number | null
    locationSource?: NullableEnumLocationSourceFieldUpdateOperationsInput | $Enums.LocationSource | null
    locationAccuracyM?: NullableFloatFieldUpdateOperationsInput | number | null
    locationConfidence?: NullableFloatFieldUpdateOperationsInput | number | null
    locationUpdatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    locationLock?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tenant?: TenantUpdateOneRequiredWithoutSitesNestedInput
    locationUpdatedBy?: UserUpdateOneWithoutSiteLocUpdatesNestedInput
    devices?: DeviceUpdateManyWithoutSiteNestedInput
    weatherData?: WeatherDataUpdateManyWithoutSiteNestedInput
  }

  export type SiteUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    addressLine1?: NullableStringFieldUpdateOperationsInput | string | null
    addressLine2?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    region?: NullableStringFieldUpdateOperationsInput | string | null
    postalCode?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    lat?: NullableFloatFieldUpdateOperationsInput | number | null
    lon?: NullableFloatFieldUpdateOperationsInput | number | null
    locationSource?: NullableEnumLocationSourceFieldUpdateOperationsInput | $Enums.LocationSource | null
    locationAccuracyM?: NullableFloatFieldUpdateOperationsInput | number | null
    locationConfidence?: NullableFloatFieldUpdateOperationsInput | number | null
    locationUpdatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    locationUpdatedByUserId?: NullableStringFieldUpdateOperationsInput | string | null
    locationLock?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    devices?: DeviceUncheckedUpdateManyWithoutSiteNestedInput
    weatherData?: WeatherDataUncheckedUpdateManyWithoutSiteNestedInput
  }

  export type SiteCreateManyInput = {
    id?: string
    tenantId: string
    name: string
    addressLine1?: string | null
    addressLine2?: string | null
    city?: string | null
    region?: string | null
    postalCode?: string | null
    country?: string | null
    lat?: number | null
    lon?: number | null
    locationSource?: $Enums.LocationSource | null
    locationAccuracyM?: number | null
    locationConfidence?: number | null
    locationUpdatedAt?: Date | string | null
    locationUpdatedByUserId?: string | null
    locationLock?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SiteUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    addressLine1?: NullableStringFieldUpdateOperationsInput | string | null
    addressLine2?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    region?: NullableStringFieldUpdateOperationsInput | string | null
    postalCode?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    lat?: NullableFloatFieldUpdateOperationsInput | number | null
    lon?: NullableFloatFieldUpdateOperationsInput | number | null
    locationSource?: NullableEnumLocationSourceFieldUpdateOperationsInput | $Enums.LocationSource | null
    locationAccuracyM?: NullableFloatFieldUpdateOperationsInput | number | null
    locationConfidence?: NullableFloatFieldUpdateOperationsInput | number | null
    locationUpdatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    locationLock?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SiteUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    addressLine1?: NullableStringFieldUpdateOperationsInput | string | null
    addressLine2?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    region?: NullableStringFieldUpdateOperationsInput | string | null
    postalCode?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    lat?: NullableFloatFieldUpdateOperationsInput | number | null
    lon?: NullableFloatFieldUpdateOperationsInput | number | null
    locationSource?: NullableEnumLocationSourceFieldUpdateOperationsInput | $Enums.LocationSource | null
    locationAccuracyM?: NullableFloatFieldUpdateOperationsInput | number | null
    locationConfidence?: NullableFloatFieldUpdateOperationsInput | number | null
    locationUpdatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    locationUpdatedByUserId?: NullableStringFieldUpdateOperationsInput | string | null
    locationLock?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DeviceCreateInput = {
    id?: string
    ownerUserId?: string | null
    model: string
    serialNumber: string
    name?: string | null
    notes?: string | null
    tags?: NullableJsonNullValueInput | InputJsonValue
    status?: $Enums.DeviceStatus
    lastSeenAt?: Date | string | null
    firmwareVersion?: string | null
    deviceLat?: number | null
    deviceLon?: number | null
    deviceLocationTs?: Date | string | null
    deviceLocationSource?: $Enums.DeviceLocationSource | null
    deviceLocationAccuracyM?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    tenant: TenantCreateNestedOneWithoutDevicesInput
    site?: SiteCreateNestedOneWithoutDevicesInput
    sim?: SimInfoCreateNestedOneWithoutDevicesInput
    secret?: DeviceSecretCreateNestedOneWithoutDeviceInput
    twin?: DeviceTwinCreateNestedOneWithoutDeviceInput
    telemetry?: TelemetryCreateNestedManyWithoutDeviceInput
    commands?: CommandCreateNestedManyWithoutDeviceInput
    alertEvents?: AlertEventCreateNestedManyWithoutDeviceInput
    dailyRollups?: DailyRollupCreateNestedManyWithoutDeviceInput
    entitlements?: EntitlementCreateNestedManyWithoutDeviceInput
  }

  export type DeviceUncheckedCreateInput = {
    id?: string
    tenantId: string
    siteId?: string | null
    ownerUserId?: string | null
    model: string
    serialNumber: string
    name?: string | null
    notes?: string | null
    tags?: NullableJsonNullValueInput | InputJsonValue
    status?: $Enums.DeviceStatus
    lastSeenAt?: Date | string | null
    firmwareVersion?: string | null
    simIccid?: string | null
    deviceLat?: number | null
    deviceLon?: number | null
    deviceLocationTs?: Date | string | null
    deviceLocationSource?: $Enums.DeviceLocationSource | null
    deviceLocationAccuracyM?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    secret?: DeviceSecretUncheckedCreateNestedOneWithoutDeviceInput
    twin?: DeviceTwinUncheckedCreateNestedOneWithoutDeviceInput
    telemetry?: TelemetryUncheckedCreateNestedManyWithoutDeviceInput
    commands?: CommandUncheckedCreateNestedManyWithoutDeviceInput
    alertEvents?: AlertEventUncheckedCreateNestedManyWithoutDeviceInput
    dailyRollups?: DailyRollupUncheckedCreateNestedManyWithoutDeviceInput
    entitlements?: EntitlementUncheckedCreateNestedManyWithoutDeviceInput
  }

  export type DeviceUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    ownerUserId?: NullableStringFieldUpdateOperationsInput | string | null
    model?: StringFieldUpdateOperationsInput | string
    serialNumber?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: NullableJsonNullValueInput | InputJsonValue
    status?: EnumDeviceStatusFieldUpdateOperationsInput | $Enums.DeviceStatus
    lastSeenAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    firmwareVersion?: NullableStringFieldUpdateOperationsInput | string | null
    deviceLat?: NullableFloatFieldUpdateOperationsInput | number | null
    deviceLon?: NullableFloatFieldUpdateOperationsInput | number | null
    deviceLocationTs?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deviceLocationSource?: NullableEnumDeviceLocationSourceFieldUpdateOperationsInput | $Enums.DeviceLocationSource | null
    deviceLocationAccuracyM?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tenant?: TenantUpdateOneRequiredWithoutDevicesNestedInput
    site?: SiteUpdateOneWithoutDevicesNestedInput
    sim?: SimInfoUpdateOneWithoutDevicesNestedInput
    secret?: DeviceSecretUpdateOneWithoutDeviceNestedInput
    twin?: DeviceTwinUpdateOneWithoutDeviceNestedInput
    telemetry?: TelemetryUpdateManyWithoutDeviceNestedInput
    commands?: CommandUpdateManyWithoutDeviceNestedInput
    alertEvents?: AlertEventUpdateManyWithoutDeviceNestedInput
    dailyRollups?: DailyRollupUpdateManyWithoutDeviceNestedInput
    entitlements?: EntitlementUpdateManyWithoutDeviceNestedInput
  }

  export type DeviceUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    siteId?: NullableStringFieldUpdateOperationsInput | string | null
    ownerUserId?: NullableStringFieldUpdateOperationsInput | string | null
    model?: StringFieldUpdateOperationsInput | string
    serialNumber?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: NullableJsonNullValueInput | InputJsonValue
    status?: EnumDeviceStatusFieldUpdateOperationsInput | $Enums.DeviceStatus
    lastSeenAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    firmwareVersion?: NullableStringFieldUpdateOperationsInput | string | null
    simIccid?: NullableStringFieldUpdateOperationsInput | string | null
    deviceLat?: NullableFloatFieldUpdateOperationsInput | number | null
    deviceLon?: NullableFloatFieldUpdateOperationsInput | number | null
    deviceLocationTs?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deviceLocationSource?: NullableEnumDeviceLocationSourceFieldUpdateOperationsInput | $Enums.DeviceLocationSource | null
    deviceLocationAccuracyM?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    secret?: DeviceSecretUncheckedUpdateOneWithoutDeviceNestedInput
    twin?: DeviceTwinUncheckedUpdateOneWithoutDeviceNestedInput
    telemetry?: TelemetryUncheckedUpdateManyWithoutDeviceNestedInput
    commands?: CommandUncheckedUpdateManyWithoutDeviceNestedInput
    alertEvents?: AlertEventUncheckedUpdateManyWithoutDeviceNestedInput
    dailyRollups?: DailyRollupUncheckedUpdateManyWithoutDeviceNestedInput
    entitlements?: EntitlementUncheckedUpdateManyWithoutDeviceNestedInput
  }

  export type DeviceCreateManyInput = {
    id?: string
    tenantId: string
    siteId?: string | null
    ownerUserId?: string | null
    model: string
    serialNumber: string
    name?: string | null
    notes?: string | null
    tags?: NullableJsonNullValueInput | InputJsonValue
    status?: $Enums.DeviceStatus
    lastSeenAt?: Date | string | null
    firmwareVersion?: string | null
    simIccid?: string | null
    deviceLat?: number | null
    deviceLon?: number | null
    deviceLocationTs?: Date | string | null
    deviceLocationSource?: $Enums.DeviceLocationSource | null
    deviceLocationAccuracyM?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type DeviceUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    ownerUserId?: NullableStringFieldUpdateOperationsInput | string | null
    model?: StringFieldUpdateOperationsInput | string
    serialNumber?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: NullableJsonNullValueInput | InputJsonValue
    status?: EnumDeviceStatusFieldUpdateOperationsInput | $Enums.DeviceStatus
    lastSeenAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    firmwareVersion?: NullableStringFieldUpdateOperationsInput | string | null
    deviceLat?: NullableFloatFieldUpdateOperationsInput | number | null
    deviceLon?: NullableFloatFieldUpdateOperationsInput | number | null
    deviceLocationTs?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deviceLocationSource?: NullableEnumDeviceLocationSourceFieldUpdateOperationsInput | $Enums.DeviceLocationSource | null
    deviceLocationAccuracyM?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DeviceUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    siteId?: NullableStringFieldUpdateOperationsInput | string | null
    ownerUserId?: NullableStringFieldUpdateOperationsInput | string | null
    model?: StringFieldUpdateOperationsInput | string
    serialNumber?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: NullableJsonNullValueInput | InputJsonValue
    status?: EnumDeviceStatusFieldUpdateOperationsInput | $Enums.DeviceStatus
    lastSeenAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    firmwareVersion?: NullableStringFieldUpdateOperationsInput | string | null
    simIccid?: NullableStringFieldUpdateOperationsInput | string | null
    deviceLat?: NullableFloatFieldUpdateOperationsInput | number | null
    deviceLon?: NullableFloatFieldUpdateOperationsInput | number | null
    deviceLocationTs?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deviceLocationSource?: NullableEnumDeviceLocationSourceFieldUpdateOperationsInput | $Enums.DeviceLocationSource | null
    deviceLocationAccuracyM?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DeviceSecretCreateInput = {
    id?: string
    secretHash: string
    publicKey?: string | null
    rotatedAt?: Date | string
    device: DeviceCreateNestedOneWithoutSecretInput
  }

  export type DeviceSecretUncheckedCreateInput = {
    id?: string
    deviceId: string
    secretHash: string
    publicKey?: string | null
    rotatedAt?: Date | string
  }

  export type DeviceSecretUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    secretHash?: StringFieldUpdateOperationsInput | string
    publicKey?: NullableStringFieldUpdateOperationsInput | string | null
    rotatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    device?: DeviceUpdateOneRequiredWithoutSecretNestedInput
  }

  export type DeviceSecretUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    deviceId?: StringFieldUpdateOperationsInput | string
    secretHash?: StringFieldUpdateOperationsInput | string
    publicKey?: NullableStringFieldUpdateOperationsInput | string | null
    rotatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DeviceSecretCreateManyInput = {
    id?: string
    deviceId: string
    secretHash: string
    publicKey?: string | null
    rotatedAt?: Date | string
  }

  export type DeviceSecretUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    secretHash?: StringFieldUpdateOperationsInput | string
    publicKey?: NullableStringFieldUpdateOperationsInput | string | null
    rotatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DeviceSecretUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    deviceId?: StringFieldUpdateOperationsInput | string
    secretHash?: StringFieldUpdateOperationsInput | string
    publicKey?: NullableStringFieldUpdateOperationsInput | string | null
    rotatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TelemetryCreateInput = {
    id?: string
    ts: Date | string
    metrics: JsonNullValueInput | InputJsonValue
    geo?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    device: DeviceCreateNestedOneWithoutTelemetryInput
  }

  export type TelemetryUncheckedCreateInput = {
    id?: string
    deviceId: string
    ts: Date | string
    metrics: JsonNullValueInput | InputJsonValue
    geo?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type TelemetryUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    ts?: DateTimeFieldUpdateOperationsInput | Date | string
    metrics?: JsonNullValueInput | InputJsonValue
    geo?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    device?: DeviceUpdateOneRequiredWithoutTelemetryNestedInput
  }

  export type TelemetryUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    deviceId?: StringFieldUpdateOperationsInput | string
    ts?: DateTimeFieldUpdateOperationsInput | Date | string
    metrics?: JsonNullValueInput | InputJsonValue
    geo?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TelemetryCreateManyInput = {
    id?: string
    deviceId: string
    ts: Date | string
    metrics: JsonNullValueInput | InputJsonValue
    geo?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type TelemetryUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    ts?: DateTimeFieldUpdateOperationsInput | Date | string
    metrics?: JsonNullValueInput | InputJsonValue
    geo?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TelemetryUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    deviceId?: StringFieldUpdateOperationsInput | string
    ts?: DateTimeFieldUpdateOperationsInput | Date | string
    metrics?: JsonNullValueInput | InputJsonValue
    geo?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DeviceTwinCreateInput = {
    id?: string
    lastTs?: Date | string | null
    derivedState?: JsonNullValueInput | InputJsonValue
    updatedAt?: Date | string
    device: DeviceCreateNestedOneWithoutTwinInput
  }

  export type DeviceTwinUncheckedCreateInput = {
    id?: string
    deviceId: string
    lastTs?: Date | string | null
    derivedState?: JsonNullValueInput | InputJsonValue
    updatedAt?: Date | string
  }

  export type DeviceTwinUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    lastTs?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    derivedState?: JsonNullValueInput | InputJsonValue
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    device?: DeviceUpdateOneRequiredWithoutTwinNestedInput
  }

  export type DeviceTwinUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    deviceId?: StringFieldUpdateOperationsInput | string
    lastTs?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    derivedState?: JsonNullValueInput | InputJsonValue
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DeviceTwinCreateManyInput = {
    id?: string
    deviceId: string
    lastTs?: Date | string | null
    derivedState?: JsonNullValueInput | InputJsonValue
    updatedAt?: Date | string
  }

  export type DeviceTwinUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    lastTs?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    derivedState?: JsonNullValueInput | InputJsonValue
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DeviceTwinUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    deviceId?: StringFieldUpdateOperationsInput | string
    lastTs?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    derivedState?: JsonNullValueInput | InputJsonValue
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CommandCreateInput = {
    id?: string
    type: $Enums.CommandType
    payload: JsonNullValueInput | InputJsonValue
    status?: $Enums.CommandStatus
    requestedAt?: Date | string
    deliveredAt?: Date | string | null
    ackAt?: Date | string | null
    errorMsg?: string | null
    device: DeviceCreateNestedOneWithoutCommandsInput
    requestedBy?: UserCreateNestedOneWithoutCommandsInput
  }

  export type CommandUncheckedCreateInput = {
    id?: string
    deviceId: string
    type: $Enums.CommandType
    payload: JsonNullValueInput | InputJsonValue
    status?: $Enums.CommandStatus
    requestedByUserId?: string | null
    requestedAt?: Date | string
    deliveredAt?: Date | string | null
    ackAt?: Date | string | null
    errorMsg?: string | null
  }

  export type CommandUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumCommandTypeFieldUpdateOperationsInput | $Enums.CommandType
    payload?: JsonNullValueInput | InputJsonValue
    status?: EnumCommandStatusFieldUpdateOperationsInput | $Enums.CommandStatus
    requestedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deliveredAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ackAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    errorMsg?: NullableStringFieldUpdateOperationsInput | string | null
    device?: DeviceUpdateOneRequiredWithoutCommandsNestedInput
    requestedBy?: UserUpdateOneWithoutCommandsNestedInput
  }

  export type CommandUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    deviceId?: StringFieldUpdateOperationsInput | string
    type?: EnumCommandTypeFieldUpdateOperationsInput | $Enums.CommandType
    payload?: JsonNullValueInput | InputJsonValue
    status?: EnumCommandStatusFieldUpdateOperationsInput | $Enums.CommandStatus
    requestedByUserId?: NullableStringFieldUpdateOperationsInput | string | null
    requestedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deliveredAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ackAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    errorMsg?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type CommandCreateManyInput = {
    id?: string
    deviceId: string
    type: $Enums.CommandType
    payload: JsonNullValueInput | InputJsonValue
    status?: $Enums.CommandStatus
    requestedByUserId?: string | null
    requestedAt?: Date | string
    deliveredAt?: Date | string | null
    ackAt?: Date | string | null
    errorMsg?: string | null
  }

  export type CommandUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumCommandTypeFieldUpdateOperationsInput | $Enums.CommandType
    payload?: JsonNullValueInput | InputJsonValue
    status?: EnumCommandStatusFieldUpdateOperationsInput | $Enums.CommandStatus
    requestedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deliveredAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ackAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    errorMsg?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type CommandUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    deviceId?: StringFieldUpdateOperationsInput | string
    type?: EnumCommandTypeFieldUpdateOperationsInput | $Enums.CommandType
    payload?: JsonNullValueInput | InputJsonValue
    status?: EnumCommandStatusFieldUpdateOperationsInput | $Enums.CommandStatus
    requestedByUserId?: NullableStringFieldUpdateOperationsInput | string | null
    requestedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deliveredAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ackAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    errorMsg?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type FirmwarePackageCreateInput = {
    id?: string
    version: string
    fileUrl: string
    checksum: string
    releaseNotes?: string | null
    createdAt?: Date | string
    otaJobs?: OtaJobCreateNestedManyWithoutFirmwarePackageInput
  }

  export type FirmwarePackageUncheckedCreateInput = {
    id?: string
    version: string
    fileUrl: string
    checksum: string
    releaseNotes?: string | null
    createdAt?: Date | string
    otaJobs?: OtaJobUncheckedCreateNestedManyWithoutFirmwarePackageInput
  }

  export type FirmwarePackageUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    version?: StringFieldUpdateOperationsInput | string
    fileUrl?: StringFieldUpdateOperationsInput | string
    checksum?: StringFieldUpdateOperationsInput | string
    releaseNotes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    otaJobs?: OtaJobUpdateManyWithoutFirmwarePackageNestedInput
  }

  export type FirmwarePackageUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    version?: StringFieldUpdateOperationsInput | string
    fileUrl?: StringFieldUpdateOperationsInput | string
    checksum?: StringFieldUpdateOperationsInput | string
    releaseNotes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    otaJobs?: OtaJobUncheckedUpdateManyWithoutFirmwarePackageNestedInput
  }

  export type FirmwarePackageCreateManyInput = {
    id?: string
    version: string
    fileUrl: string
    checksum: string
    releaseNotes?: string | null
    createdAt?: Date | string
  }

  export type FirmwarePackageUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    version?: StringFieldUpdateOperationsInput | string
    fileUrl?: StringFieldUpdateOperationsInput | string
    checksum?: StringFieldUpdateOperationsInput | string
    releaseNotes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FirmwarePackageUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    version?: StringFieldUpdateOperationsInput | string
    fileUrl?: StringFieldUpdateOperationsInput | string
    checksum?: StringFieldUpdateOperationsInput | string
    releaseNotes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OtaJobCreateInput = {
    id?: string
    targetType: $Enums.OtaTargetType
    deviceId?: string | null
    groupFilter?: NullableJsonNullValueInput | InputJsonValue
    status?: $Enums.OtaJobStatus
    scheduledAt: Date | string
    startedAt?: Date | string | null
    finishedAt?: Date | string | null
    progress?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    tenant: TenantCreateNestedOneWithoutOtaJobsInput
    firmwarePackage: FirmwarePackageCreateNestedOneWithoutOtaJobsInput
    createdBy?: UserCreateNestedOneWithoutOtaJobsInput
  }

  export type OtaJobUncheckedCreateInput = {
    id?: string
    tenantId: string
    targetType: $Enums.OtaTargetType
    deviceId?: string | null
    groupFilter?: NullableJsonNullValueInput | InputJsonValue
    firmwarePackageId: string
    status?: $Enums.OtaJobStatus
    scheduledAt: Date | string
    startedAt?: Date | string | null
    finishedAt?: Date | string | null
    createdByUserId?: string | null
    progress?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type OtaJobUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    targetType?: EnumOtaTargetTypeFieldUpdateOperationsInput | $Enums.OtaTargetType
    deviceId?: NullableStringFieldUpdateOperationsInput | string | null
    groupFilter?: NullableJsonNullValueInput | InputJsonValue
    status?: EnumOtaJobStatusFieldUpdateOperationsInput | $Enums.OtaJobStatus
    scheduledAt?: DateTimeFieldUpdateOperationsInput | Date | string
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    finishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    progress?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tenant?: TenantUpdateOneRequiredWithoutOtaJobsNestedInput
    firmwarePackage?: FirmwarePackageUpdateOneRequiredWithoutOtaJobsNestedInput
    createdBy?: UserUpdateOneWithoutOtaJobsNestedInput
  }

  export type OtaJobUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    targetType?: EnumOtaTargetTypeFieldUpdateOperationsInput | $Enums.OtaTargetType
    deviceId?: NullableStringFieldUpdateOperationsInput | string | null
    groupFilter?: NullableJsonNullValueInput | InputJsonValue
    firmwarePackageId?: StringFieldUpdateOperationsInput | string
    status?: EnumOtaJobStatusFieldUpdateOperationsInput | $Enums.OtaJobStatus
    scheduledAt?: DateTimeFieldUpdateOperationsInput | Date | string
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    finishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdByUserId?: NullableStringFieldUpdateOperationsInput | string | null
    progress?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OtaJobCreateManyInput = {
    id?: string
    tenantId: string
    targetType: $Enums.OtaTargetType
    deviceId?: string | null
    groupFilter?: NullableJsonNullValueInput | InputJsonValue
    firmwarePackageId: string
    status?: $Enums.OtaJobStatus
    scheduledAt: Date | string
    startedAt?: Date | string | null
    finishedAt?: Date | string | null
    createdByUserId?: string | null
    progress?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type OtaJobUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    targetType?: EnumOtaTargetTypeFieldUpdateOperationsInput | $Enums.OtaTargetType
    deviceId?: NullableStringFieldUpdateOperationsInput | string | null
    groupFilter?: NullableJsonNullValueInput | InputJsonValue
    status?: EnumOtaJobStatusFieldUpdateOperationsInput | $Enums.OtaJobStatus
    scheduledAt?: DateTimeFieldUpdateOperationsInput | Date | string
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    finishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    progress?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OtaJobUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    targetType?: EnumOtaTargetTypeFieldUpdateOperationsInput | $Enums.OtaTargetType
    deviceId?: NullableStringFieldUpdateOperationsInput | string | null
    groupFilter?: NullableJsonNullValueInput | InputJsonValue
    firmwarePackageId?: StringFieldUpdateOperationsInput | string
    status?: EnumOtaJobStatusFieldUpdateOperationsInput | $Enums.OtaJobStatus
    scheduledAt?: DateTimeFieldUpdateOperationsInput | Date | string
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    finishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdByUserId?: NullableStringFieldUpdateOperationsInput | string | null
    progress?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SimInfoCreateInput = {
    iccid: string
    carrier?: string | null
    planName?: string | null
    status?: $Enums.SimStatus
    lastSyncAt?: Date | string | null
    dataUsageMb?: number | null
    msisdn?: string | null
    imsi?: string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    devices?: DeviceCreateNestedManyWithoutSimInput
    simActions?: SimActionCreateNestedManyWithoutSimInput
  }

  export type SimInfoUncheckedCreateInput = {
    iccid: string
    carrier?: string | null
    planName?: string | null
    status?: $Enums.SimStatus
    lastSyncAt?: Date | string | null
    dataUsageMb?: number | null
    msisdn?: string | null
    imsi?: string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    devices?: DeviceUncheckedCreateNestedManyWithoutSimInput
    simActions?: SimActionUncheckedCreateNestedManyWithoutSimInput
  }

  export type SimInfoUpdateInput = {
    iccid?: StringFieldUpdateOperationsInput | string
    carrier?: NullableStringFieldUpdateOperationsInput | string | null
    planName?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumSimStatusFieldUpdateOperationsInput | $Enums.SimStatus
    lastSyncAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dataUsageMb?: NullableFloatFieldUpdateOperationsInput | number | null
    msisdn?: NullableStringFieldUpdateOperationsInput | string | null
    imsi?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    devices?: DeviceUpdateManyWithoutSimNestedInput
    simActions?: SimActionUpdateManyWithoutSimNestedInput
  }

  export type SimInfoUncheckedUpdateInput = {
    iccid?: StringFieldUpdateOperationsInput | string
    carrier?: NullableStringFieldUpdateOperationsInput | string | null
    planName?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumSimStatusFieldUpdateOperationsInput | $Enums.SimStatus
    lastSyncAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dataUsageMb?: NullableFloatFieldUpdateOperationsInput | number | null
    msisdn?: NullableStringFieldUpdateOperationsInput | string | null
    imsi?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    devices?: DeviceUncheckedUpdateManyWithoutSimNestedInput
    simActions?: SimActionUncheckedUpdateManyWithoutSimNestedInput
  }

  export type SimInfoCreateManyInput = {
    iccid: string
    carrier?: string | null
    planName?: string | null
    status?: $Enums.SimStatus
    lastSyncAt?: Date | string | null
    dataUsageMb?: number | null
    msisdn?: string | null
    imsi?: string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SimInfoUpdateManyMutationInput = {
    iccid?: StringFieldUpdateOperationsInput | string
    carrier?: NullableStringFieldUpdateOperationsInput | string | null
    planName?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumSimStatusFieldUpdateOperationsInput | $Enums.SimStatus
    lastSyncAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dataUsageMb?: NullableFloatFieldUpdateOperationsInput | number | null
    msisdn?: NullableStringFieldUpdateOperationsInput | string | null
    imsi?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SimInfoUncheckedUpdateManyInput = {
    iccid?: StringFieldUpdateOperationsInput | string
    carrier?: NullableStringFieldUpdateOperationsInput | string | null
    planName?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumSimStatusFieldUpdateOperationsInput | $Enums.SimStatus
    lastSyncAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dataUsageMb?: NullableFloatFieldUpdateOperationsInput | number | null
    msisdn?: NullableStringFieldUpdateOperationsInput | string | null
    imsi?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SimActionCreateInput = {
    id?: string
    action: $Enums.SimActionType
    requestedAt?: Date | string
    status?: $Enums.SimActionStatus
    providerRef?: string | null
    errorMsg?: string | null
    sim: SimInfoCreateNestedOneWithoutSimActionsInput
    requestedBy?: UserCreateNestedOneWithoutSimActionsInput
  }

  export type SimActionUncheckedCreateInput = {
    id?: string
    iccid: string
    action: $Enums.SimActionType
    requestedByUserId?: string | null
    requestedAt?: Date | string
    status?: $Enums.SimActionStatus
    providerRef?: string | null
    errorMsg?: string | null
  }

  export type SimActionUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    action?: EnumSimActionTypeFieldUpdateOperationsInput | $Enums.SimActionType
    requestedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumSimActionStatusFieldUpdateOperationsInput | $Enums.SimActionStatus
    providerRef?: NullableStringFieldUpdateOperationsInput | string | null
    errorMsg?: NullableStringFieldUpdateOperationsInput | string | null
    sim?: SimInfoUpdateOneRequiredWithoutSimActionsNestedInput
    requestedBy?: UserUpdateOneWithoutSimActionsNestedInput
  }

  export type SimActionUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    iccid?: StringFieldUpdateOperationsInput | string
    action?: EnumSimActionTypeFieldUpdateOperationsInput | $Enums.SimActionType
    requestedByUserId?: NullableStringFieldUpdateOperationsInput | string | null
    requestedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumSimActionStatusFieldUpdateOperationsInput | $Enums.SimActionStatus
    providerRef?: NullableStringFieldUpdateOperationsInput | string | null
    errorMsg?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type SimActionCreateManyInput = {
    id?: string
    iccid: string
    action: $Enums.SimActionType
    requestedByUserId?: string | null
    requestedAt?: Date | string
    status?: $Enums.SimActionStatus
    providerRef?: string | null
    errorMsg?: string | null
  }

  export type SimActionUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    action?: EnumSimActionTypeFieldUpdateOperationsInput | $Enums.SimActionType
    requestedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumSimActionStatusFieldUpdateOperationsInput | $Enums.SimActionStatus
    providerRef?: NullableStringFieldUpdateOperationsInput | string | null
    errorMsg?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type SimActionUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    iccid?: StringFieldUpdateOperationsInput | string
    action?: EnumSimActionTypeFieldUpdateOperationsInput | $Enums.SimActionType
    requestedByUserId?: NullableStringFieldUpdateOperationsInput | string | null
    requestedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumSimActionStatusFieldUpdateOperationsInput | $Enums.SimActionStatus
    providerRef?: NullableStringFieldUpdateOperationsInput | string | null
    errorMsg?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type AlertRuleCreateInput = {
    id?: string
    name: string
    enabled?: boolean
    type: $Enums.AlertRuleType
    params: JsonNullValueInput | InputJsonValue
    severity?: $Enums.AlertSeverity
    createdAt?: Date | string
    updatedAt?: Date | string
    tenant: TenantCreateNestedOneWithoutAlertRulesInput
    alertEvents?: AlertEventCreateNestedManyWithoutRuleInput
  }

  export type AlertRuleUncheckedCreateInput = {
    id?: string
    tenantId: string
    name: string
    enabled?: boolean
    type: $Enums.AlertRuleType
    params: JsonNullValueInput | InputJsonValue
    severity?: $Enums.AlertSeverity
    createdAt?: Date | string
    updatedAt?: Date | string
    alertEvents?: AlertEventUncheckedCreateNestedManyWithoutRuleInput
  }

  export type AlertRuleUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    enabled?: BoolFieldUpdateOperationsInput | boolean
    type?: EnumAlertRuleTypeFieldUpdateOperationsInput | $Enums.AlertRuleType
    params?: JsonNullValueInput | InputJsonValue
    severity?: EnumAlertSeverityFieldUpdateOperationsInput | $Enums.AlertSeverity
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tenant?: TenantUpdateOneRequiredWithoutAlertRulesNestedInput
    alertEvents?: AlertEventUpdateManyWithoutRuleNestedInput
  }

  export type AlertRuleUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    enabled?: BoolFieldUpdateOperationsInput | boolean
    type?: EnumAlertRuleTypeFieldUpdateOperationsInput | $Enums.AlertRuleType
    params?: JsonNullValueInput | InputJsonValue
    severity?: EnumAlertSeverityFieldUpdateOperationsInput | $Enums.AlertSeverity
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    alertEvents?: AlertEventUncheckedUpdateManyWithoutRuleNestedInput
  }

  export type AlertRuleCreateManyInput = {
    id?: string
    tenantId: string
    name: string
    enabled?: boolean
    type: $Enums.AlertRuleType
    params: JsonNullValueInput | InputJsonValue
    severity?: $Enums.AlertSeverity
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AlertRuleUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    enabled?: BoolFieldUpdateOperationsInput | boolean
    type?: EnumAlertRuleTypeFieldUpdateOperationsInput | $Enums.AlertRuleType
    params?: JsonNullValueInput | InputJsonValue
    severity?: EnumAlertSeverityFieldUpdateOperationsInput | $Enums.AlertSeverity
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AlertRuleUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    enabled?: BoolFieldUpdateOperationsInput | boolean
    type?: EnumAlertRuleTypeFieldUpdateOperationsInput | $Enums.AlertRuleType
    params?: JsonNullValueInput | InputJsonValue
    severity?: EnumAlertSeverityFieldUpdateOperationsInput | $Enums.AlertSeverity
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AlertEventCreateInput = {
    id?: string
    severity: $Enums.AlertSeverity
    status?: $Enums.AlertEventStatus
    openedAt?: Date | string
    acknowledgedAt?: Date | string | null
    closedAt?: Date | string | null
    details?: NullableJsonNullValueInput | InputJsonValue
    dedupeKey?: string | null
    tenant: TenantCreateNestedOneWithoutAlertEventsInput
    device: DeviceCreateNestedOneWithoutAlertEventsInput
    rule: AlertRuleCreateNestedOneWithoutAlertEventsInput
    notificationEvents?: NotificationEventCreateNestedManyWithoutAlertEventInput
  }

  export type AlertEventUncheckedCreateInput = {
    id?: string
    tenantId: string
    deviceId: string
    ruleId: string
    severity: $Enums.AlertSeverity
    status?: $Enums.AlertEventStatus
    openedAt?: Date | string
    acknowledgedAt?: Date | string | null
    closedAt?: Date | string | null
    details?: NullableJsonNullValueInput | InputJsonValue
    dedupeKey?: string | null
    notificationEvents?: NotificationEventUncheckedCreateNestedManyWithoutAlertEventInput
  }

  export type AlertEventUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    severity?: EnumAlertSeverityFieldUpdateOperationsInput | $Enums.AlertSeverity
    status?: EnumAlertEventStatusFieldUpdateOperationsInput | $Enums.AlertEventStatus
    openedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    acknowledgedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    closedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    details?: NullableJsonNullValueInput | InputJsonValue
    dedupeKey?: NullableStringFieldUpdateOperationsInput | string | null
    tenant?: TenantUpdateOneRequiredWithoutAlertEventsNestedInput
    device?: DeviceUpdateOneRequiredWithoutAlertEventsNestedInput
    rule?: AlertRuleUpdateOneRequiredWithoutAlertEventsNestedInput
    notificationEvents?: NotificationEventUpdateManyWithoutAlertEventNestedInput
  }

  export type AlertEventUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    deviceId?: StringFieldUpdateOperationsInput | string
    ruleId?: StringFieldUpdateOperationsInput | string
    severity?: EnumAlertSeverityFieldUpdateOperationsInput | $Enums.AlertSeverity
    status?: EnumAlertEventStatusFieldUpdateOperationsInput | $Enums.AlertEventStatus
    openedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    acknowledgedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    closedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    details?: NullableJsonNullValueInput | InputJsonValue
    dedupeKey?: NullableStringFieldUpdateOperationsInput | string | null
    notificationEvents?: NotificationEventUncheckedUpdateManyWithoutAlertEventNestedInput
  }

  export type AlertEventCreateManyInput = {
    id?: string
    tenantId: string
    deviceId: string
    ruleId: string
    severity: $Enums.AlertSeverity
    status?: $Enums.AlertEventStatus
    openedAt?: Date | string
    acknowledgedAt?: Date | string | null
    closedAt?: Date | string | null
    details?: NullableJsonNullValueInput | InputJsonValue
    dedupeKey?: string | null
  }

  export type AlertEventUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    severity?: EnumAlertSeverityFieldUpdateOperationsInput | $Enums.AlertSeverity
    status?: EnumAlertEventStatusFieldUpdateOperationsInput | $Enums.AlertEventStatus
    openedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    acknowledgedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    closedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    details?: NullableJsonNullValueInput | InputJsonValue
    dedupeKey?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type AlertEventUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    deviceId?: StringFieldUpdateOperationsInput | string
    ruleId?: StringFieldUpdateOperationsInput | string
    severity?: EnumAlertSeverityFieldUpdateOperationsInput | $Enums.AlertSeverity
    status?: EnumAlertEventStatusFieldUpdateOperationsInput | $Enums.AlertEventStatus
    openedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    acknowledgedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    closedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    details?: NullableJsonNullValueInput | InputJsonValue
    dedupeKey?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type NotificationChannelCreateInput = {
    id?: string
    type: $Enums.NotificationChannelType
    config: JsonNullValueInput | InputJsonValue
    enabled?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    tenant: TenantCreateNestedOneWithoutNotificationChannelsInput
    notificationEvents?: NotificationEventCreateNestedManyWithoutChannelInput
  }

  export type NotificationChannelUncheckedCreateInput = {
    id?: string
    tenantId: string
    type: $Enums.NotificationChannelType
    config: JsonNullValueInput | InputJsonValue
    enabled?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    notificationEvents?: NotificationEventUncheckedCreateNestedManyWithoutChannelInput
  }

  export type NotificationChannelUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumNotificationChannelTypeFieldUpdateOperationsInput | $Enums.NotificationChannelType
    config?: JsonNullValueInput | InputJsonValue
    enabled?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tenant?: TenantUpdateOneRequiredWithoutNotificationChannelsNestedInput
    notificationEvents?: NotificationEventUpdateManyWithoutChannelNestedInput
  }

  export type NotificationChannelUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    type?: EnumNotificationChannelTypeFieldUpdateOperationsInput | $Enums.NotificationChannelType
    config?: JsonNullValueInput | InputJsonValue
    enabled?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    notificationEvents?: NotificationEventUncheckedUpdateManyWithoutChannelNestedInput
  }

  export type NotificationChannelCreateManyInput = {
    id?: string
    tenantId: string
    type: $Enums.NotificationChannelType
    config: JsonNullValueInput | InputJsonValue
    enabled?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type NotificationChannelUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumNotificationChannelTypeFieldUpdateOperationsInput | $Enums.NotificationChannelType
    config?: JsonNullValueInput | InputJsonValue
    enabled?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationChannelUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    type?: EnumNotificationChannelTypeFieldUpdateOperationsInput | $Enums.NotificationChannelType
    config?: JsonNullValueInput | InputJsonValue
    enabled?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationEventCreateInput = {
    id?: string
    status?: $Enums.NotificationEventStatus
    payload: JsonNullValueInput | InputJsonValue
    sentAt?: Date | string | null
    errorMsg?: string | null
    createdAt?: Date | string
    tenant: TenantCreateNestedOneWithoutNotificationEventsInput
    channel: NotificationChannelCreateNestedOneWithoutNotificationEventsInput
    alertEvent?: AlertEventCreateNestedOneWithoutNotificationEventsInput
  }

  export type NotificationEventUncheckedCreateInput = {
    id?: string
    tenantId: string
    channelId: string
    alertEventId?: string | null
    status?: $Enums.NotificationEventStatus
    payload: JsonNullValueInput | InputJsonValue
    sentAt?: Date | string | null
    errorMsg?: string | null
    createdAt?: Date | string
  }

  export type NotificationEventUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: EnumNotificationEventStatusFieldUpdateOperationsInput | $Enums.NotificationEventStatus
    payload?: JsonNullValueInput | InputJsonValue
    sentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    errorMsg?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tenant?: TenantUpdateOneRequiredWithoutNotificationEventsNestedInput
    channel?: NotificationChannelUpdateOneRequiredWithoutNotificationEventsNestedInput
    alertEvent?: AlertEventUpdateOneWithoutNotificationEventsNestedInput
  }

  export type NotificationEventUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    channelId?: StringFieldUpdateOperationsInput | string
    alertEventId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumNotificationEventStatusFieldUpdateOperationsInput | $Enums.NotificationEventStatus
    payload?: JsonNullValueInput | InputJsonValue
    sentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    errorMsg?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationEventCreateManyInput = {
    id?: string
    tenantId: string
    channelId: string
    alertEventId?: string | null
    status?: $Enums.NotificationEventStatus
    payload: JsonNullValueInput | InputJsonValue
    sentAt?: Date | string | null
    errorMsg?: string | null
    createdAt?: Date | string
  }

  export type NotificationEventUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: EnumNotificationEventStatusFieldUpdateOperationsInput | $Enums.NotificationEventStatus
    payload?: JsonNullValueInput | InputJsonValue
    sentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    errorMsg?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationEventUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    channelId?: StringFieldUpdateOperationsInput | string
    alertEventId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumNotificationEventStatusFieldUpdateOperationsInput | $Enums.NotificationEventStatus
    payload?: JsonNullValueInput | InputJsonValue
    sentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    errorMsg?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DailyRollupCreateInput = {
    id?: string
    dayDate: Date | string
    energyKwhDay?: number | null
    hotWaterUsageLitersDay?: number | null
    heaterOnMinutesDay?: number | null
    tankTempMinC?: number | null
    tankTempMaxC?: number | null
    ambientTempAvgC?: number | null
    createdAt?: Date | string
    tenant: TenantCreateNestedOneWithoutDailyRollupsInput
    device: DeviceCreateNestedOneWithoutDailyRollupsInput
  }

  export type DailyRollupUncheckedCreateInput = {
    id?: string
    tenantId: string
    deviceId: string
    dayDate: Date | string
    energyKwhDay?: number | null
    hotWaterUsageLitersDay?: number | null
    heaterOnMinutesDay?: number | null
    tankTempMinC?: number | null
    tankTempMaxC?: number | null
    ambientTempAvgC?: number | null
    createdAt?: Date | string
  }

  export type DailyRollupUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    dayDate?: DateTimeFieldUpdateOperationsInput | Date | string
    energyKwhDay?: NullableFloatFieldUpdateOperationsInput | number | null
    hotWaterUsageLitersDay?: NullableFloatFieldUpdateOperationsInput | number | null
    heaterOnMinutesDay?: NullableFloatFieldUpdateOperationsInput | number | null
    tankTempMinC?: NullableFloatFieldUpdateOperationsInput | number | null
    tankTempMaxC?: NullableFloatFieldUpdateOperationsInput | number | null
    ambientTempAvgC?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tenant?: TenantUpdateOneRequiredWithoutDailyRollupsNestedInput
    device?: DeviceUpdateOneRequiredWithoutDailyRollupsNestedInput
  }

  export type DailyRollupUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    deviceId?: StringFieldUpdateOperationsInput | string
    dayDate?: DateTimeFieldUpdateOperationsInput | Date | string
    energyKwhDay?: NullableFloatFieldUpdateOperationsInput | number | null
    hotWaterUsageLitersDay?: NullableFloatFieldUpdateOperationsInput | number | null
    heaterOnMinutesDay?: NullableFloatFieldUpdateOperationsInput | number | null
    tankTempMinC?: NullableFloatFieldUpdateOperationsInput | number | null
    tankTempMaxC?: NullableFloatFieldUpdateOperationsInput | number | null
    ambientTempAvgC?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DailyRollupCreateManyInput = {
    id?: string
    tenantId: string
    deviceId: string
    dayDate: Date | string
    energyKwhDay?: number | null
    hotWaterUsageLitersDay?: number | null
    heaterOnMinutesDay?: number | null
    tankTempMinC?: number | null
    tankTempMaxC?: number | null
    ambientTempAvgC?: number | null
    createdAt?: Date | string
  }

  export type DailyRollupUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    dayDate?: DateTimeFieldUpdateOperationsInput | Date | string
    energyKwhDay?: NullableFloatFieldUpdateOperationsInput | number | null
    hotWaterUsageLitersDay?: NullableFloatFieldUpdateOperationsInput | number | null
    heaterOnMinutesDay?: NullableFloatFieldUpdateOperationsInput | number | null
    tankTempMinC?: NullableFloatFieldUpdateOperationsInput | number | null
    tankTempMaxC?: NullableFloatFieldUpdateOperationsInput | number | null
    ambientTempAvgC?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DailyRollupUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    deviceId?: StringFieldUpdateOperationsInput | string
    dayDate?: DateTimeFieldUpdateOperationsInput | Date | string
    energyKwhDay?: NullableFloatFieldUpdateOperationsInput | number | null
    hotWaterUsageLitersDay?: NullableFloatFieldUpdateOperationsInput | number | null
    heaterOnMinutesDay?: NullableFloatFieldUpdateOperationsInput | number | null
    tankTempMinC?: NullableFloatFieldUpdateOperationsInput | number | null
    tankTempMaxC?: NullableFloatFieldUpdateOperationsInput | number | null
    ambientTempAvgC?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EntitlementCreateInput = {
    id?: string
    scope: $Enums.EntitlementScope
    key: $Enums.EntitlementKey
    enabled?: boolean
    updatedAt?: Date | string
    tenant: TenantCreateNestedOneWithoutEntitlementsInput
    device?: DeviceCreateNestedOneWithoutEntitlementsInput
  }

  export type EntitlementUncheckedCreateInput = {
    id?: string
    tenantId: string
    scope: $Enums.EntitlementScope
    deviceId?: string | null
    key: $Enums.EntitlementKey
    enabled?: boolean
    updatedAt?: Date | string
  }

  export type EntitlementUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    scope?: EnumEntitlementScopeFieldUpdateOperationsInput | $Enums.EntitlementScope
    key?: EnumEntitlementKeyFieldUpdateOperationsInput | $Enums.EntitlementKey
    enabled?: BoolFieldUpdateOperationsInput | boolean
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tenant?: TenantUpdateOneRequiredWithoutEntitlementsNestedInput
    device?: DeviceUpdateOneWithoutEntitlementsNestedInput
  }

  export type EntitlementUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    scope?: EnumEntitlementScopeFieldUpdateOperationsInput | $Enums.EntitlementScope
    deviceId?: NullableStringFieldUpdateOperationsInput | string | null
    key?: EnumEntitlementKeyFieldUpdateOperationsInput | $Enums.EntitlementKey
    enabled?: BoolFieldUpdateOperationsInput | boolean
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EntitlementCreateManyInput = {
    id?: string
    tenantId: string
    scope: $Enums.EntitlementScope
    deviceId?: string | null
    key: $Enums.EntitlementKey
    enabled?: boolean
    updatedAt?: Date | string
  }

  export type EntitlementUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    scope?: EnumEntitlementScopeFieldUpdateOperationsInput | $Enums.EntitlementScope
    key?: EnumEntitlementKeyFieldUpdateOperationsInput | $Enums.EntitlementKey
    enabled?: BoolFieldUpdateOperationsInput | boolean
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EntitlementUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    scope?: EnumEntitlementScopeFieldUpdateOperationsInput | $Enums.EntitlementScope
    deviceId?: NullableStringFieldUpdateOperationsInput | string | null
    key?: EnumEntitlementKeyFieldUpdateOperationsInput | $Enums.EntitlementKey
    enabled?: BoolFieldUpdateOperationsInput | boolean
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AuditLogCreateInput = {
    id?: string
    actorUserId?: string | null
    actorType?: $Enums.ActorType
    action: string
    entityType: string
    entityId: string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    tenant?: TenantCreateNestedOneWithoutAuditLogsInput
  }

  export type AuditLogUncheckedCreateInput = {
    id?: string
    tenantId?: string | null
    actorUserId?: string | null
    actorType?: $Enums.ActorType
    action: string
    entityType: string
    entityId: string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type AuditLogUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    actorUserId?: NullableStringFieldUpdateOperationsInput | string | null
    actorType?: EnumActorTypeFieldUpdateOperationsInput | $Enums.ActorType
    action?: StringFieldUpdateOperationsInput | string
    entityType?: StringFieldUpdateOperationsInput | string
    entityId?: StringFieldUpdateOperationsInput | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tenant?: TenantUpdateOneWithoutAuditLogsNestedInput
  }

  export type AuditLogUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: NullableStringFieldUpdateOperationsInput | string | null
    actorUserId?: NullableStringFieldUpdateOperationsInput | string | null
    actorType?: EnumActorTypeFieldUpdateOperationsInput | $Enums.ActorType
    action?: StringFieldUpdateOperationsInput | string
    entityType?: StringFieldUpdateOperationsInput | string
    entityId?: StringFieldUpdateOperationsInput | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AuditLogCreateManyInput = {
    id?: string
    tenantId?: string | null
    actorUserId?: string | null
    actorType?: $Enums.ActorType
    action: string
    entityType: string
    entityId: string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type AuditLogUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    actorUserId?: NullableStringFieldUpdateOperationsInput | string | null
    actorType?: EnumActorTypeFieldUpdateOperationsInput | $Enums.ActorType
    action?: StringFieldUpdateOperationsInput | string
    entityType?: StringFieldUpdateOperationsInput | string
    entityId?: StringFieldUpdateOperationsInput | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AuditLogUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: NullableStringFieldUpdateOperationsInput | string | null
    actorUserId?: NullableStringFieldUpdateOperationsInput | string | null
    actorType?: EnumActorTypeFieldUpdateOperationsInput | $Enums.ActorType
    action?: StringFieldUpdateOperationsInput | string
    entityType?: StringFieldUpdateOperationsInput | string
    entityId?: StringFieldUpdateOperationsInput | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WeatherDataCreateInput = {
    id?: string
    date: Date | string
    summary: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    tenant: TenantCreateNestedOneWithoutWeatherDataInput
    site: SiteCreateNestedOneWithoutWeatherDataInput
  }

  export type WeatherDataUncheckedCreateInput = {
    id?: string
    tenantId: string
    siteId: string
    date: Date | string
    summary: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type WeatherDataUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    summary?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tenant?: TenantUpdateOneRequiredWithoutWeatherDataNestedInput
    site?: SiteUpdateOneRequiredWithoutWeatherDataNestedInput
  }

  export type WeatherDataUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    siteId?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    summary?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WeatherDataCreateManyInput = {
    id?: string
    tenantId: string
    siteId: string
    date: Date | string
    summary: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type WeatherDataUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    summary?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WeatherDataUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    siteId?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    summary?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type EnumTenantTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.TenantType | EnumTenantTypeFieldRefInput<$PrismaModel>
    in?: $Enums.TenantType[] | ListEnumTenantTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.TenantType[] | ListEnumTenantTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumTenantTypeFilter<$PrismaModel> | $Enums.TenantType
  }

  export type EnumTenantStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.TenantStatus | EnumTenantStatusFieldRefInput<$PrismaModel>
    in?: $Enums.TenantStatus[] | ListEnumTenantStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.TenantStatus[] | ListEnumTenantStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumTenantStatusFilter<$PrismaModel> | $Enums.TenantStatus
  }
  export type JsonNullableFilter<$PrismaModel = never> = 
    | PatchUndefined<
        Either<Required<JsonNullableFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonNullableFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonNullableFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonNullableFilterBase<$PrismaModel>>, 'path'>>

  export type JsonNullableFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type DateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type MembershipListRelationFilter = {
    every?: MembershipWhereInput
    some?: MembershipWhereInput
    none?: MembershipWhereInput
  }

  export type SiteListRelationFilter = {
    every?: SiteWhereInput
    some?: SiteWhereInput
    none?: SiteWhereInput
  }

  export type DeviceListRelationFilter = {
    every?: DeviceWhereInput
    some?: DeviceWhereInput
    none?: DeviceWhereInput
  }

  export type AlertRuleListRelationFilter = {
    every?: AlertRuleWhereInput
    some?: AlertRuleWhereInput
    none?: AlertRuleWhereInput
  }

  export type AlertEventListRelationFilter = {
    every?: AlertEventWhereInput
    some?: AlertEventWhereInput
    none?: AlertEventWhereInput
  }

  export type NotificationChannelListRelationFilter = {
    every?: NotificationChannelWhereInput
    some?: NotificationChannelWhereInput
    none?: NotificationChannelWhereInput
  }

  export type NotificationEventListRelationFilter = {
    every?: NotificationEventWhereInput
    some?: NotificationEventWhereInput
    none?: NotificationEventWhereInput
  }

  export type DailyRollupListRelationFilter = {
    every?: DailyRollupWhereInput
    some?: DailyRollupWhereInput
    none?: DailyRollupWhereInput
  }

  export type EntitlementListRelationFilter = {
    every?: EntitlementWhereInput
    some?: EntitlementWhereInput
    none?: EntitlementWhereInput
  }

  export type AuditLogListRelationFilter = {
    every?: AuditLogWhereInput
    some?: AuditLogWhereInput
    none?: AuditLogWhereInput
  }

  export type OtaJobListRelationFilter = {
    every?: OtaJobWhereInput
    some?: OtaJobWhereInput
    none?: OtaJobWhereInput
  }

  export type WeatherDataListRelationFilter = {
    every?: WeatherDataWhereInput
    some?: WeatherDataWhereInput
    none?: WeatherDataWhereInput
  }

  export type SortOrderInput = {
    sort: SortOrder
    nulls?: NullsOrder
  }

  export type MembershipOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type SiteOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type DeviceOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type AlertRuleOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type AlertEventOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type NotificationChannelOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type NotificationEventOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type DailyRollupOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type EntitlementOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type AuditLogOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type OtaJobOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type WeatherDataOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type TenantCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    type?: SortOrder
    status?: SortOrder
    settings?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TenantMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    type?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TenantMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    type?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type StringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type EnumTenantTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.TenantType | EnumTenantTypeFieldRefInput<$PrismaModel>
    in?: $Enums.TenantType[] | ListEnumTenantTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.TenantType[] | ListEnumTenantTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumTenantTypeWithAggregatesFilter<$PrismaModel> | $Enums.TenantType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumTenantTypeFilter<$PrismaModel>
    _max?: NestedEnumTenantTypeFilter<$PrismaModel>
  }

  export type EnumTenantStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.TenantStatus | EnumTenantStatusFieldRefInput<$PrismaModel>
    in?: $Enums.TenantStatus[] | ListEnumTenantStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.TenantStatus[] | ListEnumTenantStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumTenantStatusWithAggregatesFilter<$PrismaModel> | $Enums.TenantStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumTenantStatusFilter<$PrismaModel>
    _max?: NestedEnumTenantStatusFilter<$PrismaModel>
  }
  export type JsonNullableWithAggregatesFilter<$PrismaModel = never> = 
    | PatchUndefined<
        Either<Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, 'path'>>

  export type JsonNullableWithAggregatesFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedJsonNullableFilter<$PrismaModel>
    _max?: NestedJsonNullableFilter<$PrismaModel>
  }

  export type DateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type EnumUserStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.UserStatus | EnumUserStatusFieldRefInput<$PrismaModel>
    in?: $Enums.UserStatus[] | ListEnumUserStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.UserStatus[] | ListEnumUserStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumUserStatusFilter<$PrismaModel> | $Enums.UserStatus
  }

  export type CommandListRelationFilter = {
    every?: CommandWhereInput
    some?: CommandWhereInput
    none?: CommandWhereInput
  }

  export type SimActionListRelationFilter = {
    every?: SimActionWhereInput
    some?: SimActionWhereInput
    none?: SimActionWhereInput
  }

  export type CommandOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type SimActionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UserCountOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    passwordHash?: SortOrder
    name?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserMaxOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    passwordHash?: SortOrder
    name?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserMinOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    passwordHash?: SortOrder
    name?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EnumUserStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.UserStatus | EnumUserStatusFieldRefInput<$PrismaModel>
    in?: $Enums.UserStatus[] | ListEnumUserStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.UserStatus[] | ListEnumUserStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumUserStatusWithAggregatesFilter<$PrismaModel> | $Enums.UserStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumUserStatusFilter<$PrismaModel>
    _max?: NestedEnumUserStatusFilter<$PrismaModel>
  }

  export type EnumMembershipRoleFilter<$PrismaModel = never> = {
    equals?: $Enums.MembershipRole | EnumMembershipRoleFieldRefInput<$PrismaModel>
    in?: $Enums.MembershipRole[] | ListEnumMembershipRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.MembershipRole[] | ListEnumMembershipRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumMembershipRoleFilter<$PrismaModel> | $Enums.MembershipRole
  }

  export type UserRelationFilter = {
    is?: UserWhereInput
    isNot?: UserWhereInput
  }

  export type TenantRelationFilter = {
    is?: TenantWhereInput
    isNot?: TenantWhereInput
  }

  export type MembershipUserIdTenantIdCompoundUniqueInput = {
    userId: string
    tenantId: string
  }

  export type MembershipCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    tenantId?: SortOrder
    role?: SortOrder
    createdAt?: SortOrder
  }

  export type MembershipMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    tenantId?: SortOrder
    role?: SortOrder
    createdAt?: SortOrder
  }

  export type MembershipMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    tenantId?: SortOrder
    role?: SortOrder
    createdAt?: SortOrder
  }

  export type EnumMembershipRoleWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.MembershipRole | EnumMembershipRoleFieldRefInput<$PrismaModel>
    in?: $Enums.MembershipRole[] | ListEnumMembershipRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.MembershipRole[] | ListEnumMembershipRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumMembershipRoleWithAggregatesFilter<$PrismaModel> | $Enums.MembershipRole
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumMembershipRoleFilter<$PrismaModel>
    _max?: NestedEnumMembershipRoleFilter<$PrismaModel>
  }

  export type StringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type FloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type EnumLocationSourceNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.LocationSource | EnumLocationSourceFieldRefInput<$PrismaModel> | null
    in?: $Enums.LocationSource[] | ListEnumLocationSourceFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.LocationSource[] | ListEnumLocationSourceFieldRefInput<$PrismaModel> | null
    not?: NestedEnumLocationSourceNullableFilter<$PrismaModel> | $Enums.LocationSource | null
  }

  export type DateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type BoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type UserNullableRelationFilter = {
    is?: UserWhereInput | null
    isNot?: UserWhereInput | null
  }

  export type SiteCountOrderByAggregateInput = {
    id?: SortOrder
    tenantId?: SortOrder
    name?: SortOrder
    addressLine1?: SortOrder
    addressLine2?: SortOrder
    city?: SortOrder
    region?: SortOrder
    postalCode?: SortOrder
    country?: SortOrder
    lat?: SortOrder
    lon?: SortOrder
    locationSource?: SortOrder
    locationAccuracyM?: SortOrder
    locationConfidence?: SortOrder
    locationUpdatedAt?: SortOrder
    locationUpdatedByUserId?: SortOrder
    locationLock?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SiteAvgOrderByAggregateInput = {
    lat?: SortOrder
    lon?: SortOrder
    locationAccuracyM?: SortOrder
    locationConfidence?: SortOrder
  }

  export type SiteMaxOrderByAggregateInput = {
    id?: SortOrder
    tenantId?: SortOrder
    name?: SortOrder
    addressLine1?: SortOrder
    addressLine2?: SortOrder
    city?: SortOrder
    region?: SortOrder
    postalCode?: SortOrder
    country?: SortOrder
    lat?: SortOrder
    lon?: SortOrder
    locationSource?: SortOrder
    locationAccuracyM?: SortOrder
    locationConfidence?: SortOrder
    locationUpdatedAt?: SortOrder
    locationUpdatedByUserId?: SortOrder
    locationLock?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SiteMinOrderByAggregateInput = {
    id?: SortOrder
    tenantId?: SortOrder
    name?: SortOrder
    addressLine1?: SortOrder
    addressLine2?: SortOrder
    city?: SortOrder
    region?: SortOrder
    postalCode?: SortOrder
    country?: SortOrder
    lat?: SortOrder
    lon?: SortOrder
    locationSource?: SortOrder
    locationAccuracyM?: SortOrder
    locationConfidence?: SortOrder
    locationUpdatedAt?: SortOrder
    locationUpdatedByUserId?: SortOrder
    locationLock?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SiteSumOrderByAggregateInput = {
    lat?: SortOrder
    lon?: SortOrder
    locationAccuracyM?: SortOrder
    locationConfidence?: SortOrder
  }

  export type StringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type FloatNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedFloatNullableFilter<$PrismaModel>
    _min?: NestedFloatNullableFilter<$PrismaModel>
    _max?: NestedFloatNullableFilter<$PrismaModel>
  }

  export type EnumLocationSourceNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.LocationSource | EnumLocationSourceFieldRefInput<$PrismaModel> | null
    in?: $Enums.LocationSource[] | ListEnumLocationSourceFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.LocationSource[] | ListEnumLocationSourceFieldRefInput<$PrismaModel> | null
    not?: NestedEnumLocationSourceNullableWithAggregatesFilter<$PrismaModel> | $Enums.LocationSource | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumLocationSourceNullableFilter<$PrismaModel>
    _max?: NestedEnumLocationSourceNullableFilter<$PrismaModel>
  }

  export type DateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type BoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type EnumDeviceStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.DeviceStatus | EnumDeviceStatusFieldRefInput<$PrismaModel>
    in?: $Enums.DeviceStatus[] | ListEnumDeviceStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.DeviceStatus[] | ListEnumDeviceStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumDeviceStatusFilter<$PrismaModel> | $Enums.DeviceStatus
  }

  export type EnumDeviceLocationSourceNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.DeviceLocationSource | EnumDeviceLocationSourceFieldRefInput<$PrismaModel> | null
    in?: $Enums.DeviceLocationSource[] | ListEnumDeviceLocationSourceFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.DeviceLocationSource[] | ListEnumDeviceLocationSourceFieldRefInput<$PrismaModel> | null
    not?: NestedEnumDeviceLocationSourceNullableFilter<$PrismaModel> | $Enums.DeviceLocationSource | null
  }

  export type SiteNullableRelationFilter = {
    is?: SiteWhereInput | null
    isNot?: SiteWhereInput | null
  }

  export type SimInfoNullableRelationFilter = {
    is?: SimInfoWhereInput | null
    isNot?: SimInfoWhereInput | null
  }

  export type DeviceSecretNullableRelationFilter = {
    is?: DeviceSecretWhereInput | null
    isNot?: DeviceSecretWhereInput | null
  }

  export type DeviceTwinNullableRelationFilter = {
    is?: DeviceTwinWhereInput | null
    isNot?: DeviceTwinWhereInput | null
  }

  export type TelemetryListRelationFilter = {
    every?: TelemetryWhereInput
    some?: TelemetryWhereInput
    none?: TelemetryWhereInput
  }

  export type TelemetryOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type DeviceTenantIdSerialNumberCompoundUniqueInput = {
    tenantId: string
    serialNumber: string
  }

  export type DeviceCountOrderByAggregateInput = {
    id?: SortOrder
    tenantId?: SortOrder
    siteId?: SortOrder
    ownerUserId?: SortOrder
    model?: SortOrder
    serialNumber?: SortOrder
    name?: SortOrder
    notes?: SortOrder
    tags?: SortOrder
    status?: SortOrder
    lastSeenAt?: SortOrder
    firmwareVersion?: SortOrder
    simIccid?: SortOrder
    deviceLat?: SortOrder
    deviceLon?: SortOrder
    deviceLocationTs?: SortOrder
    deviceLocationSource?: SortOrder
    deviceLocationAccuracyM?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type DeviceAvgOrderByAggregateInput = {
    deviceLat?: SortOrder
    deviceLon?: SortOrder
    deviceLocationAccuracyM?: SortOrder
  }

  export type DeviceMaxOrderByAggregateInput = {
    id?: SortOrder
    tenantId?: SortOrder
    siteId?: SortOrder
    ownerUserId?: SortOrder
    model?: SortOrder
    serialNumber?: SortOrder
    name?: SortOrder
    notes?: SortOrder
    status?: SortOrder
    lastSeenAt?: SortOrder
    firmwareVersion?: SortOrder
    simIccid?: SortOrder
    deviceLat?: SortOrder
    deviceLon?: SortOrder
    deviceLocationTs?: SortOrder
    deviceLocationSource?: SortOrder
    deviceLocationAccuracyM?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type DeviceMinOrderByAggregateInput = {
    id?: SortOrder
    tenantId?: SortOrder
    siteId?: SortOrder
    ownerUserId?: SortOrder
    model?: SortOrder
    serialNumber?: SortOrder
    name?: SortOrder
    notes?: SortOrder
    status?: SortOrder
    lastSeenAt?: SortOrder
    firmwareVersion?: SortOrder
    simIccid?: SortOrder
    deviceLat?: SortOrder
    deviceLon?: SortOrder
    deviceLocationTs?: SortOrder
    deviceLocationSource?: SortOrder
    deviceLocationAccuracyM?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type DeviceSumOrderByAggregateInput = {
    deviceLat?: SortOrder
    deviceLon?: SortOrder
    deviceLocationAccuracyM?: SortOrder
  }

  export type EnumDeviceStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.DeviceStatus | EnumDeviceStatusFieldRefInput<$PrismaModel>
    in?: $Enums.DeviceStatus[] | ListEnumDeviceStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.DeviceStatus[] | ListEnumDeviceStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumDeviceStatusWithAggregatesFilter<$PrismaModel> | $Enums.DeviceStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumDeviceStatusFilter<$PrismaModel>
    _max?: NestedEnumDeviceStatusFilter<$PrismaModel>
  }

  export type EnumDeviceLocationSourceNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.DeviceLocationSource | EnumDeviceLocationSourceFieldRefInput<$PrismaModel> | null
    in?: $Enums.DeviceLocationSource[] | ListEnumDeviceLocationSourceFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.DeviceLocationSource[] | ListEnumDeviceLocationSourceFieldRefInput<$PrismaModel> | null
    not?: NestedEnumDeviceLocationSourceNullableWithAggregatesFilter<$PrismaModel> | $Enums.DeviceLocationSource | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumDeviceLocationSourceNullableFilter<$PrismaModel>
    _max?: NestedEnumDeviceLocationSourceNullableFilter<$PrismaModel>
  }

  export type DeviceRelationFilter = {
    is?: DeviceWhereInput
    isNot?: DeviceWhereInput
  }

  export type DeviceSecretCountOrderByAggregateInput = {
    id?: SortOrder
    deviceId?: SortOrder
    secretHash?: SortOrder
    publicKey?: SortOrder
    rotatedAt?: SortOrder
  }

  export type DeviceSecretMaxOrderByAggregateInput = {
    id?: SortOrder
    deviceId?: SortOrder
    secretHash?: SortOrder
    publicKey?: SortOrder
    rotatedAt?: SortOrder
  }

  export type DeviceSecretMinOrderByAggregateInput = {
    id?: SortOrder
    deviceId?: SortOrder
    secretHash?: SortOrder
    publicKey?: SortOrder
    rotatedAt?: SortOrder
  }
  export type JsonFilter<$PrismaModel = never> = 
    | PatchUndefined<
        Either<Required<JsonFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonFilterBase<$PrismaModel>>, 'path'>>

  export type JsonFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type TelemetryCountOrderByAggregateInput = {
    id?: SortOrder
    deviceId?: SortOrder
    ts?: SortOrder
    metrics?: SortOrder
    geo?: SortOrder
    createdAt?: SortOrder
  }

  export type TelemetryMaxOrderByAggregateInput = {
    id?: SortOrder
    deviceId?: SortOrder
    ts?: SortOrder
    createdAt?: SortOrder
  }

  export type TelemetryMinOrderByAggregateInput = {
    id?: SortOrder
    deviceId?: SortOrder
    ts?: SortOrder
    createdAt?: SortOrder
  }
  export type JsonWithAggregatesFilter<$PrismaModel = never> = 
    | PatchUndefined<
        Either<Required<JsonWithAggregatesFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonWithAggregatesFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonWithAggregatesFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonWithAggregatesFilterBase<$PrismaModel>>, 'path'>>

  export type JsonWithAggregatesFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedJsonFilter<$PrismaModel>
    _max?: NestedJsonFilter<$PrismaModel>
  }

  export type DeviceTwinCountOrderByAggregateInput = {
    id?: SortOrder
    deviceId?: SortOrder
    lastTs?: SortOrder
    derivedState?: SortOrder
    updatedAt?: SortOrder
  }

  export type DeviceTwinMaxOrderByAggregateInput = {
    id?: SortOrder
    deviceId?: SortOrder
    lastTs?: SortOrder
    updatedAt?: SortOrder
  }

  export type DeviceTwinMinOrderByAggregateInput = {
    id?: SortOrder
    deviceId?: SortOrder
    lastTs?: SortOrder
    updatedAt?: SortOrder
  }

  export type EnumCommandTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.CommandType | EnumCommandTypeFieldRefInput<$PrismaModel>
    in?: $Enums.CommandType[] | ListEnumCommandTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.CommandType[] | ListEnumCommandTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumCommandTypeFilter<$PrismaModel> | $Enums.CommandType
  }

  export type EnumCommandStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.CommandStatus | EnumCommandStatusFieldRefInput<$PrismaModel>
    in?: $Enums.CommandStatus[] | ListEnumCommandStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.CommandStatus[] | ListEnumCommandStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumCommandStatusFilter<$PrismaModel> | $Enums.CommandStatus
  }

  export type CommandCountOrderByAggregateInput = {
    id?: SortOrder
    deviceId?: SortOrder
    type?: SortOrder
    payload?: SortOrder
    status?: SortOrder
    requestedByUserId?: SortOrder
    requestedAt?: SortOrder
    deliveredAt?: SortOrder
    ackAt?: SortOrder
    errorMsg?: SortOrder
  }

  export type CommandMaxOrderByAggregateInput = {
    id?: SortOrder
    deviceId?: SortOrder
    type?: SortOrder
    status?: SortOrder
    requestedByUserId?: SortOrder
    requestedAt?: SortOrder
    deliveredAt?: SortOrder
    ackAt?: SortOrder
    errorMsg?: SortOrder
  }

  export type CommandMinOrderByAggregateInput = {
    id?: SortOrder
    deviceId?: SortOrder
    type?: SortOrder
    status?: SortOrder
    requestedByUserId?: SortOrder
    requestedAt?: SortOrder
    deliveredAt?: SortOrder
    ackAt?: SortOrder
    errorMsg?: SortOrder
  }

  export type EnumCommandTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.CommandType | EnumCommandTypeFieldRefInput<$PrismaModel>
    in?: $Enums.CommandType[] | ListEnumCommandTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.CommandType[] | ListEnumCommandTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumCommandTypeWithAggregatesFilter<$PrismaModel> | $Enums.CommandType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumCommandTypeFilter<$PrismaModel>
    _max?: NestedEnumCommandTypeFilter<$PrismaModel>
  }

  export type EnumCommandStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.CommandStatus | EnumCommandStatusFieldRefInput<$PrismaModel>
    in?: $Enums.CommandStatus[] | ListEnumCommandStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.CommandStatus[] | ListEnumCommandStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumCommandStatusWithAggregatesFilter<$PrismaModel> | $Enums.CommandStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumCommandStatusFilter<$PrismaModel>
    _max?: NestedEnumCommandStatusFilter<$PrismaModel>
  }

  export type FirmwarePackageCountOrderByAggregateInput = {
    id?: SortOrder
    version?: SortOrder
    fileUrl?: SortOrder
    checksum?: SortOrder
    releaseNotes?: SortOrder
    createdAt?: SortOrder
  }

  export type FirmwarePackageMaxOrderByAggregateInput = {
    id?: SortOrder
    version?: SortOrder
    fileUrl?: SortOrder
    checksum?: SortOrder
    releaseNotes?: SortOrder
    createdAt?: SortOrder
  }

  export type FirmwarePackageMinOrderByAggregateInput = {
    id?: SortOrder
    version?: SortOrder
    fileUrl?: SortOrder
    checksum?: SortOrder
    releaseNotes?: SortOrder
    createdAt?: SortOrder
  }

  export type EnumOtaTargetTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.OtaTargetType | EnumOtaTargetTypeFieldRefInput<$PrismaModel>
    in?: $Enums.OtaTargetType[] | ListEnumOtaTargetTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.OtaTargetType[] | ListEnumOtaTargetTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumOtaTargetTypeFilter<$PrismaModel> | $Enums.OtaTargetType
  }

  export type EnumOtaJobStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.OtaJobStatus | EnumOtaJobStatusFieldRefInput<$PrismaModel>
    in?: $Enums.OtaJobStatus[] | ListEnumOtaJobStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.OtaJobStatus[] | ListEnumOtaJobStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumOtaJobStatusFilter<$PrismaModel> | $Enums.OtaJobStatus
  }

  export type FirmwarePackageRelationFilter = {
    is?: FirmwarePackageWhereInput
    isNot?: FirmwarePackageWhereInput
  }

  export type OtaJobCountOrderByAggregateInput = {
    id?: SortOrder
    tenantId?: SortOrder
    targetType?: SortOrder
    deviceId?: SortOrder
    groupFilter?: SortOrder
    firmwarePackageId?: SortOrder
    status?: SortOrder
    scheduledAt?: SortOrder
    startedAt?: SortOrder
    finishedAt?: SortOrder
    createdByUserId?: SortOrder
    progress?: SortOrder
    createdAt?: SortOrder
  }

  export type OtaJobMaxOrderByAggregateInput = {
    id?: SortOrder
    tenantId?: SortOrder
    targetType?: SortOrder
    deviceId?: SortOrder
    firmwarePackageId?: SortOrder
    status?: SortOrder
    scheduledAt?: SortOrder
    startedAt?: SortOrder
    finishedAt?: SortOrder
    createdByUserId?: SortOrder
    createdAt?: SortOrder
  }

  export type OtaJobMinOrderByAggregateInput = {
    id?: SortOrder
    tenantId?: SortOrder
    targetType?: SortOrder
    deviceId?: SortOrder
    firmwarePackageId?: SortOrder
    status?: SortOrder
    scheduledAt?: SortOrder
    startedAt?: SortOrder
    finishedAt?: SortOrder
    createdByUserId?: SortOrder
    createdAt?: SortOrder
  }

  export type EnumOtaTargetTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.OtaTargetType | EnumOtaTargetTypeFieldRefInput<$PrismaModel>
    in?: $Enums.OtaTargetType[] | ListEnumOtaTargetTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.OtaTargetType[] | ListEnumOtaTargetTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumOtaTargetTypeWithAggregatesFilter<$PrismaModel> | $Enums.OtaTargetType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumOtaTargetTypeFilter<$PrismaModel>
    _max?: NestedEnumOtaTargetTypeFilter<$PrismaModel>
  }

  export type EnumOtaJobStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.OtaJobStatus | EnumOtaJobStatusFieldRefInput<$PrismaModel>
    in?: $Enums.OtaJobStatus[] | ListEnumOtaJobStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.OtaJobStatus[] | ListEnumOtaJobStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumOtaJobStatusWithAggregatesFilter<$PrismaModel> | $Enums.OtaJobStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumOtaJobStatusFilter<$PrismaModel>
    _max?: NestedEnumOtaJobStatusFilter<$PrismaModel>
  }

  export type EnumSimStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.SimStatus | EnumSimStatusFieldRefInput<$PrismaModel>
    in?: $Enums.SimStatus[] | ListEnumSimStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.SimStatus[] | ListEnumSimStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumSimStatusFilter<$PrismaModel> | $Enums.SimStatus
  }

  export type SimInfoCountOrderByAggregateInput = {
    iccid?: SortOrder
    carrier?: SortOrder
    planName?: SortOrder
    status?: SortOrder
    lastSyncAt?: SortOrder
    dataUsageMb?: SortOrder
    msisdn?: SortOrder
    imsi?: SortOrder
    notes?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SimInfoAvgOrderByAggregateInput = {
    dataUsageMb?: SortOrder
  }

  export type SimInfoMaxOrderByAggregateInput = {
    iccid?: SortOrder
    carrier?: SortOrder
    planName?: SortOrder
    status?: SortOrder
    lastSyncAt?: SortOrder
    dataUsageMb?: SortOrder
    msisdn?: SortOrder
    imsi?: SortOrder
    notes?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SimInfoMinOrderByAggregateInput = {
    iccid?: SortOrder
    carrier?: SortOrder
    planName?: SortOrder
    status?: SortOrder
    lastSyncAt?: SortOrder
    dataUsageMb?: SortOrder
    msisdn?: SortOrder
    imsi?: SortOrder
    notes?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SimInfoSumOrderByAggregateInput = {
    dataUsageMb?: SortOrder
  }

  export type EnumSimStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.SimStatus | EnumSimStatusFieldRefInput<$PrismaModel>
    in?: $Enums.SimStatus[] | ListEnumSimStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.SimStatus[] | ListEnumSimStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumSimStatusWithAggregatesFilter<$PrismaModel> | $Enums.SimStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumSimStatusFilter<$PrismaModel>
    _max?: NestedEnumSimStatusFilter<$PrismaModel>
  }

  export type EnumSimActionTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.SimActionType | EnumSimActionTypeFieldRefInput<$PrismaModel>
    in?: $Enums.SimActionType[] | ListEnumSimActionTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.SimActionType[] | ListEnumSimActionTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumSimActionTypeFilter<$PrismaModel> | $Enums.SimActionType
  }

  export type EnumSimActionStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.SimActionStatus | EnumSimActionStatusFieldRefInput<$PrismaModel>
    in?: $Enums.SimActionStatus[] | ListEnumSimActionStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.SimActionStatus[] | ListEnumSimActionStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumSimActionStatusFilter<$PrismaModel> | $Enums.SimActionStatus
  }

  export type SimInfoRelationFilter = {
    is?: SimInfoWhereInput
    isNot?: SimInfoWhereInput
  }

  export type SimActionCountOrderByAggregateInput = {
    id?: SortOrder
    iccid?: SortOrder
    action?: SortOrder
    requestedByUserId?: SortOrder
    requestedAt?: SortOrder
    status?: SortOrder
    providerRef?: SortOrder
    errorMsg?: SortOrder
  }

  export type SimActionMaxOrderByAggregateInput = {
    id?: SortOrder
    iccid?: SortOrder
    action?: SortOrder
    requestedByUserId?: SortOrder
    requestedAt?: SortOrder
    status?: SortOrder
    providerRef?: SortOrder
    errorMsg?: SortOrder
  }

  export type SimActionMinOrderByAggregateInput = {
    id?: SortOrder
    iccid?: SortOrder
    action?: SortOrder
    requestedByUserId?: SortOrder
    requestedAt?: SortOrder
    status?: SortOrder
    providerRef?: SortOrder
    errorMsg?: SortOrder
  }

  export type EnumSimActionTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.SimActionType | EnumSimActionTypeFieldRefInput<$PrismaModel>
    in?: $Enums.SimActionType[] | ListEnumSimActionTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.SimActionType[] | ListEnumSimActionTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumSimActionTypeWithAggregatesFilter<$PrismaModel> | $Enums.SimActionType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumSimActionTypeFilter<$PrismaModel>
    _max?: NestedEnumSimActionTypeFilter<$PrismaModel>
  }

  export type EnumSimActionStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.SimActionStatus | EnumSimActionStatusFieldRefInput<$PrismaModel>
    in?: $Enums.SimActionStatus[] | ListEnumSimActionStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.SimActionStatus[] | ListEnumSimActionStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumSimActionStatusWithAggregatesFilter<$PrismaModel> | $Enums.SimActionStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumSimActionStatusFilter<$PrismaModel>
    _max?: NestedEnumSimActionStatusFilter<$PrismaModel>
  }

  export type EnumAlertRuleTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.AlertRuleType | EnumAlertRuleTypeFieldRefInput<$PrismaModel>
    in?: $Enums.AlertRuleType[] | ListEnumAlertRuleTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.AlertRuleType[] | ListEnumAlertRuleTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumAlertRuleTypeFilter<$PrismaModel> | $Enums.AlertRuleType
  }

  export type EnumAlertSeverityFilter<$PrismaModel = never> = {
    equals?: $Enums.AlertSeverity | EnumAlertSeverityFieldRefInput<$PrismaModel>
    in?: $Enums.AlertSeverity[] | ListEnumAlertSeverityFieldRefInput<$PrismaModel>
    notIn?: $Enums.AlertSeverity[] | ListEnumAlertSeverityFieldRefInput<$PrismaModel>
    not?: NestedEnumAlertSeverityFilter<$PrismaModel> | $Enums.AlertSeverity
  }

  export type AlertRuleCountOrderByAggregateInput = {
    id?: SortOrder
    tenantId?: SortOrder
    name?: SortOrder
    enabled?: SortOrder
    type?: SortOrder
    params?: SortOrder
    severity?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AlertRuleMaxOrderByAggregateInput = {
    id?: SortOrder
    tenantId?: SortOrder
    name?: SortOrder
    enabled?: SortOrder
    type?: SortOrder
    severity?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AlertRuleMinOrderByAggregateInput = {
    id?: SortOrder
    tenantId?: SortOrder
    name?: SortOrder
    enabled?: SortOrder
    type?: SortOrder
    severity?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EnumAlertRuleTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.AlertRuleType | EnumAlertRuleTypeFieldRefInput<$PrismaModel>
    in?: $Enums.AlertRuleType[] | ListEnumAlertRuleTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.AlertRuleType[] | ListEnumAlertRuleTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumAlertRuleTypeWithAggregatesFilter<$PrismaModel> | $Enums.AlertRuleType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumAlertRuleTypeFilter<$PrismaModel>
    _max?: NestedEnumAlertRuleTypeFilter<$PrismaModel>
  }

  export type EnumAlertSeverityWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.AlertSeverity | EnumAlertSeverityFieldRefInput<$PrismaModel>
    in?: $Enums.AlertSeverity[] | ListEnumAlertSeverityFieldRefInput<$PrismaModel>
    notIn?: $Enums.AlertSeverity[] | ListEnumAlertSeverityFieldRefInput<$PrismaModel>
    not?: NestedEnumAlertSeverityWithAggregatesFilter<$PrismaModel> | $Enums.AlertSeverity
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumAlertSeverityFilter<$PrismaModel>
    _max?: NestedEnumAlertSeverityFilter<$PrismaModel>
  }

  export type EnumAlertEventStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.AlertEventStatus | EnumAlertEventStatusFieldRefInput<$PrismaModel>
    in?: $Enums.AlertEventStatus[] | ListEnumAlertEventStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.AlertEventStatus[] | ListEnumAlertEventStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumAlertEventStatusFilter<$PrismaModel> | $Enums.AlertEventStatus
  }

  export type AlertRuleRelationFilter = {
    is?: AlertRuleWhereInput
    isNot?: AlertRuleWhereInput
  }

  export type AlertEventCountOrderByAggregateInput = {
    id?: SortOrder
    tenantId?: SortOrder
    deviceId?: SortOrder
    ruleId?: SortOrder
    severity?: SortOrder
    status?: SortOrder
    openedAt?: SortOrder
    acknowledgedAt?: SortOrder
    closedAt?: SortOrder
    details?: SortOrder
    dedupeKey?: SortOrder
  }

  export type AlertEventMaxOrderByAggregateInput = {
    id?: SortOrder
    tenantId?: SortOrder
    deviceId?: SortOrder
    ruleId?: SortOrder
    severity?: SortOrder
    status?: SortOrder
    openedAt?: SortOrder
    acknowledgedAt?: SortOrder
    closedAt?: SortOrder
    dedupeKey?: SortOrder
  }

  export type AlertEventMinOrderByAggregateInput = {
    id?: SortOrder
    tenantId?: SortOrder
    deviceId?: SortOrder
    ruleId?: SortOrder
    severity?: SortOrder
    status?: SortOrder
    openedAt?: SortOrder
    acknowledgedAt?: SortOrder
    closedAt?: SortOrder
    dedupeKey?: SortOrder
  }

  export type EnumAlertEventStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.AlertEventStatus | EnumAlertEventStatusFieldRefInput<$PrismaModel>
    in?: $Enums.AlertEventStatus[] | ListEnumAlertEventStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.AlertEventStatus[] | ListEnumAlertEventStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumAlertEventStatusWithAggregatesFilter<$PrismaModel> | $Enums.AlertEventStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumAlertEventStatusFilter<$PrismaModel>
    _max?: NestedEnumAlertEventStatusFilter<$PrismaModel>
  }

  export type EnumNotificationChannelTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.NotificationChannelType | EnumNotificationChannelTypeFieldRefInput<$PrismaModel>
    in?: $Enums.NotificationChannelType[] | ListEnumNotificationChannelTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.NotificationChannelType[] | ListEnumNotificationChannelTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumNotificationChannelTypeFilter<$PrismaModel> | $Enums.NotificationChannelType
  }

  export type NotificationChannelCountOrderByAggregateInput = {
    id?: SortOrder
    tenantId?: SortOrder
    type?: SortOrder
    config?: SortOrder
    enabled?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type NotificationChannelMaxOrderByAggregateInput = {
    id?: SortOrder
    tenantId?: SortOrder
    type?: SortOrder
    enabled?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type NotificationChannelMinOrderByAggregateInput = {
    id?: SortOrder
    tenantId?: SortOrder
    type?: SortOrder
    enabled?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EnumNotificationChannelTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.NotificationChannelType | EnumNotificationChannelTypeFieldRefInput<$PrismaModel>
    in?: $Enums.NotificationChannelType[] | ListEnumNotificationChannelTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.NotificationChannelType[] | ListEnumNotificationChannelTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumNotificationChannelTypeWithAggregatesFilter<$PrismaModel> | $Enums.NotificationChannelType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumNotificationChannelTypeFilter<$PrismaModel>
    _max?: NestedEnumNotificationChannelTypeFilter<$PrismaModel>
  }

  export type EnumNotificationEventStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.NotificationEventStatus | EnumNotificationEventStatusFieldRefInput<$PrismaModel>
    in?: $Enums.NotificationEventStatus[] | ListEnumNotificationEventStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.NotificationEventStatus[] | ListEnumNotificationEventStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumNotificationEventStatusFilter<$PrismaModel> | $Enums.NotificationEventStatus
  }

  export type NotificationChannelRelationFilter = {
    is?: NotificationChannelWhereInput
    isNot?: NotificationChannelWhereInput
  }

  export type AlertEventNullableRelationFilter = {
    is?: AlertEventWhereInput | null
    isNot?: AlertEventWhereInput | null
  }

  export type NotificationEventCountOrderByAggregateInput = {
    id?: SortOrder
    tenantId?: SortOrder
    channelId?: SortOrder
    alertEventId?: SortOrder
    status?: SortOrder
    payload?: SortOrder
    sentAt?: SortOrder
    errorMsg?: SortOrder
    createdAt?: SortOrder
  }

  export type NotificationEventMaxOrderByAggregateInput = {
    id?: SortOrder
    tenantId?: SortOrder
    channelId?: SortOrder
    alertEventId?: SortOrder
    status?: SortOrder
    sentAt?: SortOrder
    errorMsg?: SortOrder
    createdAt?: SortOrder
  }

  export type NotificationEventMinOrderByAggregateInput = {
    id?: SortOrder
    tenantId?: SortOrder
    channelId?: SortOrder
    alertEventId?: SortOrder
    status?: SortOrder
    sentAt?: SortOrder
    errorMsg?: SortOrder
    createdAt?: SortOrder
  }

  export type EnumNotificationEventStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.NotificationEventStatus | EnumNotificationEventStatusFieldRefInput<$PrismaModel>
    in?: $Enums.NotificationEventStatus[] | ListEnumNotificationEventStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.NotificationEventStatus[] | ListEnumNotificationEventStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumNotificationEventStatusWithAggregatesFilter<$PrismaModel> | $Enums.NotificationEventStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumNotificationEventStatusFilter<$PrismaModel>
    _max?: NestedEnumNotificationEventStatusFilter<$PrismaModel>
  }

  export type DailyRollupDeviceIdDayDateCompoundUniqueInput = {
    deviceId: string
    dayDate: Date | string
  }

  export type DailyRollupCountOrderByAggregateInput = {
    id?: SortOrder
    tenantId?: SortOrder
    deviceId?: SortOrder
    dayDate?: SortOrder
    energyKwhDay?: SortOrder
    hotWaterUsageLitersDay?: SortOrder
    heaterOnMinutesDay?: SortOrder
    tankTempMinC?: SortOrder
    tankTempMaxC?: SortOrder
    ambientTempAvgC?: SortOrder
    createdAt?: SortOrder
  }

  export type DailyRollupAvgOrderByAggregateInput = {
    energyKwhDay?: SortOrder
    hotWaterUsageLitersDay?: SortOrder
    heaterOnMinutesDay?: SortOrder
    tankTempMinC?: SortOrder
    tankTempMaxC?: SortOrder
    ambientTempAvgC?: SortOrder
  }

  export type DailyRollupMaxOrderByAggregateInput = {
    id?: SortOrder
    tenantId?: SortOrder
    deviceId?: SortOrder
    dayDate?: SortOrder
    energyKwhDay?: SortOrder
    hotWaterUsageLitersDay?: SortOrder
    heaterOnMinutesDay?: SortOrder
    tankTempMinC?: SortOrder
    tankTempMaxC?: SortOrder
    ambientTempAvgC?: SortOrder
    createdAt?: SortOrder
  }

  export type DailyRollupMinOrderByAggregateInput = {
    id?: SortOrder
    tenantId?: SortOrder
    deviceId?: SortOrder
    dayDate?: SortOrder
    energyKwhDay?: SortOrder
    hotWaterUsageLitersDay?: SortOrder
    heaterOnMinutesDay?: SortOrder
    tankTempMinC?: SortOrder
    tankTempMaxC?: SortOrder
    ambientTempAvgC?: SortOrder
    createdAt?: SortOrder
  }

  export type DailyRollupSumOrderByAggregateInput = {
    energyKwhDay?: SortOrder
    hotWaterUsageLitersDay?: SortOrder
    heaterOnMinutesDay?: SortOrder
    tankTempMinC?: SortOrder
    tankTempMaxC?: SortOrder
    ambientTempAvgC?: SortOrder
  }

  export type EnumEntitlementScopeFilter<$PrismaModel = never> = {
    equals?: $Enums.EntitlementScope | EnumEntitlementScopeFieldRefInput<$PrismaModel>
    in?: $Enums.EntitlementScope[] | ListEnumEntitlementScopeFieldRefInput<$PrismaModel>
    notIn?: $Enums.EntitlementScope[] | ListEnumEntitlementScopeFieldRefInput<$PrismaModel>
    not?: NestedEnumEntitlementScopeFilter<$PrismaModel> | $Enums.EntitlementScope
  }

  export type EnumEntitlementKeyFilter<$PrismaModel = never> = {
    equals?: $Enums.EntitlementKey | EnumEntitlementKeyFieldRefInput<$PrismaModel>
    in?: $Enums.EntitlementKey[] | ListEnumEntitlementKeyFieldRefInput<$PrismaModel>
    notIn?: $Enums.EntitlementKey[] | ListEnumEntitlementKeyFieldRefInput<$PrismaModel>
    not?: NestedEnumEntitlementKeyFilter<$PrismaModel> | $Enums.EntitlementKey
  }

  export type DeviceNullableRelationFilter = {
    is?: DeviceWhereInput | null
    isNot?: DeviceWhereInput | null
  }

  export type EntitlementTenantIdKeyDeviceIdCompoundUniqueInput = {
    tenantId: string
    key: $Enums.EntitlementKey
    deviceId: string
  }

  export type EntitlementCountOrderByAggregateInput = {
    id?: SortOrder
    tenantId?: SortOrder
    scope?: SortOrder
    deviceId?: SortOrder
    key?: SortOrder
    enabled?: SortOrder
    updatedAt?: SortOrder
  }

  export type EntitlementMaxOrderByAggregateInput = {
    id?: SortOrder
    tenantId?: SortOrder
    scope?: SortOrder
    deviceId?: SortOrder
    key?: SortOrder
    enabled?: SortOrder
    updatedAt?: SortOrder
  }

  export type EntitlementMinOrderByAggregateInput = {
    id?: SortOrder
    tenantId?: SortOrder
    scope?: SortOrder
    deviceId?: SortOrder
    key?: SortOrder
    enabled?: SortOrder
    updatedAt?: SortOrder
  }

  export type EnumEntitlementScopeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.EntitlementScope | EnumEntitlementScopeFieldRefInput<$PrismaModel>
    in?: $Enums.EntitlementScope[] | ListEnumEntitlementScopeFieldRefInput<$PrismaModel>
    notIn?: $Enums.EntitlementScope[] | ListEnumEntitlementScopeFieldRefInput<$PrismaModel>
    not?: NestedEnumEntitlementScopeWithAggregatesFilter<$PrismaModel> | $Enums.EntitlementScope
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumEntitlementScopeFilter<$PrismaModel>
    _max?: NestedEnumEntitlementScopeFilter<$PrismaModel>
  }

  export type EnumEntitlementKeyWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.EntitlementKey | EnumEntitlementKeyFieldRefInput<$PrismaModel>
    in?: $Enums.EntitlementKey[] | ListEnumEntitlementKeyFieldRefInput<$PrismaModel>
    notIn?: $Enums.EntitlementKey[] | ListEnumEntitlementKeyFieldRefInput<$PrismaModel>
    not?: NestedEnumEntitlementKeyWithAggregatesFilter<$PrismaModel> | $Enums.EntitlementKey
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumEntitlementKeyFilter<$PrismaModel>
    _max?: NestedEnumEntitlementKeyFilter<$PrismaModel>
  }

  export type EnumActorTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.ActorType | EnumActorTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ActorType[] | ListEnumActorTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.ActorType[] | ListEnumActorTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumActorTypeFilter<$PrismaModel> | $Enums.ActorType
  }

  export type TenantNullableRelationFilter = {
    is?: TenantWhereInput | null
    isNot?: TenantWhereInput | null
  }

  export type AuditLogCountOrderByAggregateInput = {
    id?: SortOrder
    tenantId?: SortOrder
    actorUserId?: SortOrder
    actorType?: SortOrder
    action?: SortOrder
    entityType?: SortOrder
    entityId?: SortOrder
    metadata?: SortOrder
    createdAt?: SortOrder
  }

  export type AuditLogMaxOrderByAggregateInput = {
    id?: SortOrder
    tenantId?: SortOrder
    actorUserId?: SortOrder
    actorType?: SortOrder
    action?: SortOrder
    entityType?: SortOrder
    entityId?: SortOrder
    createdAt?: SortOrder
  }

  export type AuditLogMinOrderByAggregateInput = {
    id?: SortOrder
    tenantId?: SortOrder
    actorUserId?: SortOrder
    actorType?: SortOrder
    action?: SortOrder
    entityType?: SortOrder
    entityId?: SortOrder
    createdAt?: SortOrder
  }

  export type EnumActorTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ActorType | EnumActorTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ActorType[] | ListEnumActorTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.ActorType[] | ListEnumActorTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumActorTypeWithAggregatesFilter<$PrismaModel> | $Enums.ActorType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumActorTypeFilter<$PrismaModel>
    _max?: NestedEnumActorTypeFilter<$PrismaModel>
  }

  export type SiteRelationFilter = {
    is?: SiteWhereInput
    isNot?: SiteWhereInput
  }

  export type WeatherDataSiteIdDateCompoundUniqueInput = {
    siteId: string
    date: Date | string
  }

  export type WeatherDataCountOrderByAggregateInput = {
    id?: SortOrder
    tenantId?: SortOrder
    siteId?: SortOrder
    date?: SortOrder
    summary?: SortOrder
    createdAt?: SortOrder
  }

  export type WeatherDataMaxOrderByAggregateInput = {
    id?: SortOrder
    tenantId?: SortOrder
    siteId?: SortOrder
    date?: SortOrder
    createdAt?: SortOrder
  }

  export type WeatherDataMinOrderByAggregateInput = {
    id?: SortOrder
    tenantId?: SortOrder
    siteId?: SortOrder
    date?: SortOrder
    createdAt?: SortOrder
  }

  export type MembershipCreateNestedManyWithoutTenantInput = {
    create?: XOR<MembershipCreateWithoutTenantInput, MembershipUncheckedCreateWithoutTenantInput> | MembershipCreateWithoutTenantInput[] | MembershipUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: MembershipCreateOrConnectWithoutTenantInput | MembershipCreateOrConnectWithoutTenantInput[]
    createMany?: MembershipCreateManyTenantInputEnvelope
    connect?: MembershipWhereUniqueInput | MembershipWhereUniqueInput[]
  }

  export type SiteCreateNestedManyWithoutTenantInput = {
    create?: XOR<SiteCreateWithoutTenantInput, SiteUncheckedCreateWithoutTenantInput> | SiteCreateWithoutTenantInput[] | SiteUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: SiteCreateOrConnectWithoutTenantInput | SiteCreateOrConnectWithoutTenantInput[]
    createMany?: SiteCreateManyTenantInputEnvelope
    connect?: SiteWhereUniqueInput | SiteWhereUniqueInput[]
  }

  export type DeviceCreateNestedManyWithoutTenantInput = {
    create?: XOR<DeviceCreateWithoutTenantInput, DeviceUncheckedCreateWithoutTenantInput> | DeviceCreateWithoutTenantInput[] | DeviceUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: DeviceCreateOrConnectWithoutTenantInput | DeviceCreateOrConnectWithoutTenantInput[]
    createMany?: DeviceCreateManyTenantInputEnvelope
    connect?: DeviceWhereUniqueInput | DeviceWhereUniqueInput[]
  }

  export type AlertRuleCreateNestedManyWithoutTenantInput = {
    create?: XOR<AlertRuleCreateWithoutTenantInput, AlertRuleUncheckedCreateWithoutTenantInput> | AlertRuleCreateWithoutTenantInput[] | AlertRuleUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: AlertRuleCreateOrConnectWithoutTenantInput | AlertRuleCreateOrConnectWithoutTenantInput[]
    createMany?: AlertRuleCreateManyTenantInputEnvelope
    connect?: AlertRuleWhereUniqueInput | AlertRuleWhereUniqueInput[]
  }

  export type AlertEventCreateNestedManyWithoutTenantInput = {
    create?: XOR<AlertEventCreateWithoutTenantInput, AlertEventUncheckedCreateWithoutTenantInput> | AlertEventCreateWithoutTenantInput[] | AlertEventUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: AlertEventCreateOrConnectWithoutTenantInput | AlertEventCreateOrConnectWithoutTenantInput[]
    createMany?: AlertEventCreateManyTenantInputEnvelope
    connect?: AlertEventWhereUniqueInput | AlertEventWhereUniqueInput[]
  }

  export type NotificationChannelCreateNestedManyWithoutTenantInput = {
    create?: XOR<NotificationChannelCreateWithoutTenantInput, NotificationChannelUncheckedCreateWithoutTenantInput> | NotificationChannelCreateWithoutTenantInput[] | NotificationChannelUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: NotificationChannelCreateOrConnectWithoutTenantInput | NotificationChannelCreateOrConnectWithoutTenantInput[]
    createMany?: NotificationChannelCreateManyTenantInputEnvelope
    connect?: NotificationChannelWhereUniqueInput | NotificationChannelWhereUniqueInput[]
  }

  export type NotificationEventCreateNestedManyWithoutTenantInput = {
    create?: XOR<NotificationEventCreateWithoutTenantInput, NotificationEventUncheckedCreateWithoutTenantInput> | NotificationEventCreateWithoutTenantInput[] | NotificationEventUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: NotificationEventCreateOrConnectWithoutTenantInput | NotificationEventCreateOrConnectWithoutTenantInput[]
    createMany?: NotificationEventCreateManyTenantInputEnvelope
    connect?: NotificationEventWhereUniqueInput | NotificationEventWhereUniqueInput[]
  }

  export type DailyRollupCreateNestedManyWithoutTenantInput = {
    create?: XOR<DailyRollupCreateWithoutTenantInput, DailyRollupUncheckedCreateWithoutTenantInput> | DailyRollupCreateWithoutTenantInput[] | DailyRollupUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: DailyRollupCreateOrConnectWithoutTenantInput | DailyRollupCreateOrConnectWithoutTenantInput[]
    createMany?: DailyRollupCreateManyTenantInputEnvelope
    connect?: DailyRollupWhereUniqueInput | DailyRollupWhereUniqueInput[]
  }

  export type EntitlementCreateNestedManyWithoutTenantInput = {
    create?: XOR<EntitlementCreateWithoutTenantInput, EntitlementUncheckedCreateWithoutTenantInput> | EntitlementCreateWithoutTenantInput[] | EntitlementUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: EntitlementCreateOrConnectWithoutTenantInput | EntitlementCreateOrConnectWithoutTenantInput[]
    createMany?: EntitlementCreateManyTenantInputEnvelope
    connect?: EntitlementWhereUniqueInput | EntitlementWhereUniqueInput[]
  }

  export type AuditLogCreateNestedManyWithoutTenantInput = {
    create?: XOR<AuditLogCreateWithoutTenantInput, AuditLogUncheckedCreateWithoutTenantInput> | AuditLogCreateWithoutTenantInput[] | AuditLogUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: AuditLogCreateOrConnectWithoutTenantInput | AuditLogCreateOrConnectWithoutTenantInput[]
    createMany?: AuditLogCreateManyTenantInputEnvelope
    connect?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
  }

  export type OtaJobCreateNestedManyWithoutTenantInput = {
    create?: XOR<OtaJobCreateWithoutTenantInput, OtaJobUncheckedCreateWithoutTenantInput> | OtaJobCreateWithoutTenantInput[] | OtaJobUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: OtaJobCreateOrConnectWithoutTenantInput | OtaJobCreateOrConnectWithoutTenantInput[]
    createMany?: OtaJobCreateManyTenantInputEnvelope
    connect?: OtaJobWhereUniqueInput | OtaJobWhereUniqueInput[]
  }

  export type WeatherDataCreateNestedManyWithoutTenantInput = {
    create?: XOR<WeatherDataCreateWithoutTenantInput, WeatherDataUncheckedCreateWithoutTenantInput> | WeatherDataCreateWithoutTenantInput[] | WeatherDataUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: WeatherDataCreateOrConnectWithoutTenantInput | WeatherDataCreateOrConnectWithoutTenantInput[]
    createMany?: WeatherDataCreateManyTenantInputEnvelope
    connect?: WeatherDataWhereUniqueInput | WeatherDataWhereUniqueInput[]
  }

  export type MembershipUncheckedCreateNestedManyWithoutTenantInput = {
    create?: XOR<MembershipCreateWithoutTenantInput, MembershipUncheckedCreateWithoutTenantInput> | MembershipCreateWithoutTenantInput[] | MembershipUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: MembershipCreateOrConnectWithoutTenantInput | MembershipCreateOrConnectWithoutTenantInput[]
    createMany?: MembershipCreateManyTenantInputEnvelope
    connect?: MembershipWhereUniqueInput | MembershipWhereUniqueInput[]
  }

  export type SiteUncheckedCreateNestedManyWithoutTenantInput = {
    create?: XOR<SiteCreateWithoutTenantInput, SiteUncheckedCreateWithoutTenantInput> | SiteCreateWithoutTenantInput[] | SiteUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: SiteCreateOrConnectWithoutTenantInput | SiteCreateOrConnectWithoutTenantInput[]
    createMany?: SiteCreateManyTenantInputEnvelope
    connect?: SiteWhereUniqueInput | SiteWhereUniqueInput[]
  }

  export type DeviceUncheckedCreateNestedManyWithoutTenantInput = {
    create?: XOR<DeviceCreateWithoutTenantInput, DeviceUncheckedCreateWithoutTenantInput> | DeviceCreateWithoutTenantInput[] | DeviceUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: DeviceCreateOrConnectWithoutTenantInput | DeviceCreateOrConnectWithoutTenantInput[]
    createMany?: DeviceCreateManyTenantInputEnvelope
    connect?: DeviceWhereUniqueInput | DeviceWhereUniqueInput[]
  }

  export type AlertRuleUncheckedCreateNestedManyWithoutTenantInput = {
    create?: XOR<AlertRuleCreateWithoutTenantInput, AlertRuleUncheckedCreateWithoutTenantInput> | AlertRuleCreateWithoutTenantInput[] | AlertRuleUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: AlertRuleCreateOrConnectWithoutTenantInput | AlertRuleCreateOrConnectWithoutTenantInput[]
    createMany?: AlertRuleCreateManyTenantInputEnvelope
    connect?: AlertRuleWhereUniqueInput | AlertRuleWhereUniqueInput[]
  }

  export type AlertEventUncheckedCreateNestedManyWithoutTenantInput = {
    create?: XOR<AlertEventCreateWithoutTenantInput, AlertEventUncheckedCreateWithoutTenantInput> | AlertEventCreateWithoutTenantInput[] | AlertEventUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: AlertEventCreateOrConnectWithoutTenantInput | AlertEventCreateOrConnectWithoutTenantInput[]
    createMany?: AlertEventCreateManyTenantInputEnvelope
    connect?: AlertEventWhereUniqueInput | AlertEventWhereUniqueInput[]
  }

  export type NotificationChannelUncheckedCreateNestedManyWithoutTenantInput = {
    create?: XOR<NotificationChannelCreateWithoutTenantInput, NotificationChannelUncheckedCreateWithoutTenantInput> | NotificationChannelCreateWithoutTenantInput[] | NotificationChannelUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: NotificationChannelCreateOrConnectWithoutTenantInput | NotificationChannelCreateOrConnectWithoutTenantInput[]
    createMany?: NotificationChannelCreateManyTenantInputEnvelope
    connect?: NotificationChannelWhereUniqueInput | NotificationChannelWhereUniqueInput[]
  }

  export type NotificationEventUncheckedCreateNestedManyWithoutTenantInput = {
    create?: XOR<NotificationEventCreateWithoutTenantInput, NotificationEventUncheckedCreateWithoutTenantInput> | NotificationEventCreateWithoutTenantInput[] | NotificationEventUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: NotificationEventCreateOrConnectWithoutTenantInput | NotificationEventCreateOrConnectWithoutTenantInput[]
    createMany?: NotificationEventCreateManyTenantInputEnvelope
    connect?: NotificationEventWhereUniqueInput | NotificationEventWhereUniqueInput[]
  }

  export type DailyRollupUncheckedCreateNestedManyWithoutTenantInput = {
    create?: XOR<DailyRollupCreateWithoutTenantInput, DailyRollupUncheckedCreateWithoutTenantInput> | DailyRollupCreateWithoutTenantInput[] | DailyRollupUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: DailyRollupCreateOrConnectWithoutTenantInput | DailyRollupCreateOrConnectWithoutTenantInput[]
    createMany?: DailyRollupCreateManyTenantInputEnvelope
    connect?: DailyRollupWhereUniqueInput | DailyRollupWhereUniqueInput[]
  }

  export type EntitlementUncheckedCreateNestedManyWithoutTenantInput = {
    create?: XOR<EntitlementCreateWithoutTenantInput, EntitlementUncheckedCreateWithoutTenantInput> | EntitlementCreateWithoutTenantInput[] | EntitlementUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: EntitlementCreateOrConnectWithoutTenantInput | EntitlementCreateOrConnectWithoutTenantInput[]
    createMany?: EntitlementCreateManyTenantInputEnvelope
    connect?: EntitlementWhereUniqueInput | EntitlementWhereUniqueInput[]
  }

  export type AuditLogUncheckedCreateNestedManyWithoutTenantInput = {
    create?: XOR<AuditLogCreateWithoutTenantInput, AuditLogUncheckedCreateWithoutTenantInput> | AuditLogCreateWithoutTenantInput[] | AuditLogUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: AuditLogCreateOrConnectWithoutTenantInput | AuditLogCreateOrConnectWithoutTenantInput[]
    createMany?: AuditLogCreateManyTenantInputEnvelope
    connect?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
  }

  export type OtaJobUncheckedCreateNestedManyWithoutTenantInput = {
    create?: XOR<OtaJobCreateWithoutTenantInput, OtaJobUncheckedCreateWithoutTenantInput> | OtaJobCreateWithoutTenantInput[] | OtaJobUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: OtaJobCreateOrConnectWithoutTenantInput | OtaJobCreateOrConnectWithoutTenantInput[]
    createMany?: OtaJobCreateManyTenantInputEnvelope
    connect?: OtaJobWhereUniqueInput | OtaJobWhereUniqueInput[]
  }

  export type WeatherDataUncheckedCreateNestedManyWithoutTenantInput = {
    create?: XOR<WeatherDataCreateWithoutTenantInput, WeatherDataUncheckedCreateWithoutTenantInput> | WeatherDataCreateWithoutTenantInput[] | WeatherDataUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: WeatherDataCreateOrConnectWithoutTenantInput | WeatherDataCreateOrConnectWithoutTenantInput[]
    createMany?: WeatherDataCreateManyTenantInputEnvelope
    connect?: WeatherDataWhereUniqueInput | WeatherDataWhereUniqueInput[]
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type EnumTenantTypeFieldUpdateOperationsInput = {
    set?: $Enums.TenantType
  }

  export type EnumTenantStatusFieldUpdateOperationsInput = {
    set?: $Enums.TenantStatus
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type MembershipUpdateManyWithoutTenantNestedInput = {
    create?: XOR<MembershipCreateWithoutTenantInput, MembershipUncheckedCreateWithoutTenantInput> | MembershipCreateWithoutTenantInput[] | MembershipUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: MembershipCreateOrConnectWithoutTenantInput | MembershipCreateOrConnectWithoutTenantInput[]
    upsert?: MembershipUpsertWithWhereUniqueWithoutTenantInput | MembershipUpsertWithWhereUniqueWithoutTenantInput[]
    createMany?: MembershipCreateManyTenantInputEnvelope
    set?: MembershipWhereUniqueInput | MembershipWhereUniqueInput[]
    disconnect?: MembershipWhereUniqueInput | MembershipWhereUniqueInput[]
    delete?: MembershipWhereUniqueInput | MembershipWhereUniqueInput[]
    connect?: MembershipWhereUniqueInput | MembershipWhereUniqueInput[]
    update?: MembershipUpdateWithWhereUniqueWithoutTenantInput | MembershipUpdateWithWhereUniqueWithoutTenantInput[]
    updateMany?: MembershipUpdateManyWithWhereWithoutTenantInput | MembershipUpdateManyWithWhereWithoutTenantInput[]
    deleteMany?: MembershipScalarWhereInput | MembershipScalarWhereInput[]
  }

  export type SiteUpdateManyWithoutTenantNestedInput = {
    create?: XOR<SiteCreateWithoutTenantInput, SiteUncheckedCreateWithoutTenantInput> | SiteCreateWithoutTenantInput[] | SiteUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: SiteCreateOrConnectWithoutTenantInput | SiteCreateOrConnectWithoutTenantInput[]
    upsert?: SiteUpsertWithWhereUniqueWithoutTenantInput | SiteUpsertWithWhereUniqueWithoutTenantInput[]
    createMany?: SiteCreateManyTenantInputEnvelope
    set?: SiteWhereUniqueInput | SiteWhereUniqueInput[]
    disconnect?: SiteWhereUniqueInput | SiteWhereUniqueInput[]
    delete?: SiteWhereUniqueInput | SiteWhereUniqueInput[]
    connect?: SiteWhereUniqueInput | SiteWhereUniqueInput[]
    update?: SiteUpdateWithWhereUniqueWithoutTenantInput | SiteUpdateWithWhereUniqueWithoutTenantInput[]
    updateMany?: SiteUpdateManyWithWhereWithoutTenantInput | SiteUpdateManyWithWhereWithoutTenantInput[]
    deleteMany?: SiteScalarWhereInput | SiteScalarWhereInput[]
  }

  export type DeviceUpdateManyWithoutTenantNestedInput = {
    create?: XOR<DeviceCreateWithoutTenantInput, DeviceUncheckedCreateWithoutTenantInput> | DeviceCreateWithoutTenantInput[] | DeviceUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: DeviceCreateOrConnectWithoutTenantInput | DeviceCreateOrConnectWithoutTenantInput[]
    upsert?: DeviceUpsertWithWhereUniqueWithoutTenantInput | DeviceUpsertWithWhereUniqueWithoutTenantInput[]
    createMany?: DeviceCreateManyTenantInputEnvelope
    set?: DeviceWhereUniqueInput | DeviceWhereUniqueInput[]
    disconnect?: DeviceWhereUniqueInput | DeviceWhereUniqueInput[]
    delete?: DeviceWhereUniqueInput | DeviceWhereUniqueInput[]
    connect?: DeviceWhereUniqueInput | DeviceWhereUniqueInput[]
    update?: DeviceUpdateWithWhereUniqueWithoutTenantInput | DeviceUpdateWithWhereUniqueWithoutTenantInput[]
    updateMany?: DeviceUpdateManyWithWhereWithoutTenantInput | DeviceUpdateManyWithWhereWithoutTenantInput[]
    deleteMany?: DeviceScalarWhereInput | DeviceScalarWhereInput[]
  }

  export type AlertRuleUpdateManyWithoutTenantNestedInput = {
    create?: XOR<AlertRuleCreateWithoutTenantInput, AlertRuleUncheckedCreateWithoutTenantInput> | AlertRuleCreateWithoutTenantInput[] | AlertRuleUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: AlertRuleCreateOrConnectWithoutTenantInput | AlertRuleCreateOrConnectWithoutTenantInput[]
    upsert?: AlertRuleUpsertWithWhereUniqueWithoutTenantInput | AlertRuleUpsertWithWhereUniqueWithoutTenantInput[]
    createMany?: AlertRuleCreateManyTenantInputEnvelope
    set?: AlertRuleWhereUniqueInput | AlertRuleWhereUniqueInput[]
    disconnect?: AlertRuleWhereUniqueInput | AlertRuleWhereUniqueInput[]
    delete?: AlertRuleWhereUniqueInput | AlertRuleWhereUniqueInput[]
    connect?: AlertRuleWhereUniqueInput | AlertRuleWhereUniqueInput[]
    update?: AlertRuleUpdateWithWhereUniqueWithoutTenantInput | AlertRuleUpdateWithWhereUniqueWithoutTenantInput[]
    updateMany?: AlertRuleUpdateManyWithWhereWithoutTenantInput | AlertRuleUpdateManyWithWhereWithoutTenantInput[]
    deleteMany?: AlertRuleScalarWhereInput | AlertRuleScalarWhereInput[]
  }

  export type AlertEventUpdateManyWithoutTenantNestedInput = {
    create?: XOR<AlertEventCreateWithoutTenantInput, AlertEventUncheckedCreateWithoutTenantInput> | AlertEventCreateWithoutTenantInput[] | AlertEventUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: AlertEventCreateOrConnectWithoutTenantInput | AlertEventCreateOrConnectWithoutTenantInput[]
    upsert?: AlertEventUpsertWithWhereUniqueWithoutTenantInput | AlertEventUpsertWithWhereUniqueWithoutTenantInput[]
    createMany?: AlertEventCreateManyTenantInputEnvelope
    set?: AlertEventWhereUniqueInput | AlertEventWhereUniqueInput[]
    disconnect?: AlertEventWhereUniqueInput | AlertEventWhereUniqueInput[]
    delete?: AlertEventWhereUniqueInput | AlertEventWhereUniqueInput[]
    connect?: AlertEventWhereUniqueInput | AlertEventWhereUniqueInput[]
    update?: AlertEventUpdateWithWhereUniqueWithoutTenantInput | AlertEventUpdateWithWhereUniqueWithoutTenantInput[]
    updateMany?: AlertEventUpdateManyWithWhereWithoutTenantInput | AlertEventUpdateManyWithWhereWithoutTenantInput[]
    deleteMany?: AlertEventScalarWhereInput | AlertEventScalarWhereInput[]
  }

  export type NotificationChannelUpdateManyWithoutTenantNestedInput = {
    create?: XOR<NotificationChannelCreateWithoutTenantInput, NotificationChannelUncheckedCreateWithoutTenantInput> | NotificationChannelCreateWithoutTenantInput[] | NotificationChannelUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: NotificationChannelCreateOrConnectWithoutTenantInput | NotificationChannelCreateOrConnectWithoutTenantInput[]
    upsert?: NotificationChannelUpsertWithWhereUniqueWithoutTenantInput | NotificationChannelUpsertWithWhereUniqueWithoutTenantInput[]
    createMany?: NotificationChannelCreateManyTenantInputEnvelope
    set?: NotificationChannelWhereUniqueInput | NotificationChannelWhereUniqueInput[]
    disconnect?: NotificationChannelWhereUniqueInput | NotificationChannelWhereUniqueInput[]
    delete?: NotificationChannelWhereUniqueInput | NotificationChannelWhereUniqueInput[]
    connect?: NotificationChannelWhereUniqueInput | NotificationChannelWhereUniqueInput[]
    update?: NotificationChannelUpdateWithWhereUniqueWithoutTenantInput | NotificationChannelUpdateWithWhereUniqueWithoutTenantInput[]
    updateMany?: NotificationChannelUpdateManyWithWhereWithoutTenantInput | NotificationChannelUpdateManyWithWhereWithoutTenantInput[]
    deleteMany?: NotificationChannelScalarWhereInput | NotificationChannelScalarWhereInput[]
  }

  export type NotificationEventUpdateManyWithoutTenantNestedInput = {
    create?: XOR<NotificationEventCreateWithoutTenantInput, NotificationEventUncheckedCreateWithoutTenantInput> | NotificationEventCreateWithoutTenantInput[] | NotificationEventUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: NotificationEventCreateOrConnectWithoutTenantInput | NotificationEventCreateOrConnectWithoutTenantInput[]
    upsert?: NotificationEventUpsertWithWhereUniqueWithoutTenantInput | NotificationEventUpsertWithWhereUniqueWithoutTenantInput[]
    createMany?: NotificationEventCreateManyTenantInputEnvelope
    set?: NotificationEventWhereUniqueInput | NotificationEventWhereUniqueInput[]
    disconnect?: NotificationEventWhereUniqueInput | NotificationEventWhereUniqueInput[]
    delete?: NotificationEventWhereUniqueInput | NotificationEventWhereUniqueInput[]
    connect?: NotificationEventWhereUniqueInput | NotificationEventWhereUniqueInput[]
    update?: NotificationEventUpdateWithWhereUniqueWithoutTenantInput | NotificationEventUpdateWithWhereUniqueWithoutTenantInput[]
    updateMany?: NotificationEventUpdateManyWithWhereWithoutTenantInput | NotificationEventUpdateManyWithWhereWithoutTenantInput[]
    deleteMany?: NotificationEventScalarWhereInput | NotificationEventScalarWhereInput[]
  }

  export type DailyRollupUpdateManyWithoutTenantNestedInput = {
    create?: XOR<DailyRollupCreateWithoutTenantInput, DailyRollupUncheckedCreateWithoutTenantInput> | DailyRollupCreateWithoutTenantInput[] | DailyRollupUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: DailyRollupCreateOrConnectWithoutTenantInput | DailyRollupCreateOrConnectWithoutTenantInput[]
    upsert?: DailyRollupUpsertWithWhereUniqueWithoutTenantInput | DailyRollupUpsertWithWhereUniqueWithoutTenantInput[]
    createMany?: DailyRollupCreateManyTenantInputEnvelope
    set?: DailyRollupWhereUniqueInput | DailyRollupWhereUniqueInput[]
    disconnect?: DailyRollupWhereUniqueInput | DailyRollupWhereUniqueInput[]
    delete?: DailyRollupWhereUniqueInput | DailyRollupWhereUniqueInput[]
    connect?: DailyRollupWhereUniqueInput | DailyRollupWhereUniqueInput[]
    update?: DailyRollupUpdateWithWhereUniqueWithoutTenantInput | DailyRollupUpdateWithWhereUniqueWithoutTenantInput[]
    updateMany?: DailyRollupUpdateManyWithWhereWithoutTenantInput | DailyRollupUpdateManyWithWhereWithoutTenantInput[]
    deleteMany?: DailyRollupScalarWhereInput | DailyRollupScalarWhereInput[]
  }

  export type EntitlementUpdateManyWithoutTenantNestedInput = {
    create?: XOR<EntitlementCreateWithoutTenantInput, EntitlementUncheckedCreateWithoutTenantInput> | EntitlementCreateWithoutTenantInput[] | EntitlementUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: EntitlementCreateOrConnectWithoutTenantInput | EntitlementCreateOrConnectWithoutTenantInput[]
    upsert?: EntitlementUpsertWithWhereUniqueWithoutTenantInput | EntitlementUpsertWithWhereUniqueWithoutTenantInput[]
    createMany?: EntitlementCreateManyTenantInputEnvelope
    set?: EntitlementWhereUniqueInput | EntitlementWhereUniqueInput[]
    disconnect?: EntitlementWhereUniqueInput | EntitlementWhereUniqueInput[]
    delete?: EntitlementWhereUniqueInput | EntitlementWhereUniqueInput[]
    connect?: EntitlementWhereUniqueInput | EntitlementWhereUniqueInput[]
    update?: EntitlementUpdateWithWhereUniqueWithoutTenantInput | EntitlementUpdateWithWhereUniqueWithoutTenantInput[]
    updateMany?: EntitlementUpdateManyWithWhereWithoutTenantInput | EntitlementUpdateManyWithWhereWithoutTenantInput[]
    deleteMany?: EntitlementScalarWhereInput | EntitlementScalarWhereInput[]
  }

  export type AuditLogUpdateManyWithoutTenantNestedInput = {
    create?: XOR<AuditLogCreateWithoutTenantInput, AuditLogUncheckedCreateWithoutTenantInput> | AuditLogCreateWithoutTenantInput[] | AuditLogUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: AuditLogCreateOrConnectWithoutTenantInput | AuditLogCreateOrConnectWithoutTenantInput[]
    upsert?: AuditLogUpsertWithWhereUniqueWithoutTenantInput | AuditLogUpsertWithWhereUniqueWithoutTenantInput[]
    createMany?: AuditLogCreateManyTenantInputEnvelope
    set?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    disconnect?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    delete?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    connect?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    update?: AuditLogUpdateWithWhereUniqueWithoutTenantInput | AuditLogUpdateWithWhereUniqueWithoutTenantInput[]
    updateMany?: AuditLogUpdateManyWithWhereWithoutTenantInput | AuditLogUpdateManyWithWhereWithoutTenantInput[]
    deleteMany?: AuditLogScalarWhereInput | AuditLogScalarWhereInput[]
  }

  export type OtaJobUpdateManyWithoutTenantNestedInput = {
    create?: XOR<OtaJobCreateWithoutTenantInput, OtaJobUncheckedCreateWithoutTenantInput> | OtaJobCreateWithoutTenantInput[] | OtaJobUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: OtaJobCreateOrConnectWithoutTenantInput | OtaJobCreateOrConnectWithoutTenantInput[]
    upsert?: OtaJobUpsertWithWhereUniqueWithoutTenantInput | OtaJobUpsertWithWhereUniqueWithoutTenantInput[]
    createMany?: OtaJobCreateManyTenantInputEnvelope
    set?: OtaJobWhereUniqueInput | OtaJobWhereUniqueInput[]
    disconnect?: OtaJobWhereUniqueInput | OtaJobWhereUniqueInput[]
    delete?: OtaJobWhereUniqueInput | OtaJobWhereUniqueInput[]
    connect?: OtaJobWhereUniqueInput | OtaJobWhereUniqueInput[]
    update?: OtaJobUpdateWithWhereUniqueWithoutTenantInput | OtaJobUpdateWithWhereUniqueWithoutTenantInput[]
    updateMany?: OtaJobUpdateManyWithWhereWithoutTenantInput | OtaJobUpdateManyWithWhereWithoutTenantInput[]
    deleteMany?: OtaJobScalarWhereInput | OtaJobScalarWhereInput[]
  }

  export type WeatherDataUpdateManyWithoutTenantNestedInput = {
    create?: XOR<WeatherDataCreateWithoutTenantInput, WeatherDataUncheckedCreateWithoutTenantInput> | WeatherDataCreateWithoutTenantInput[] | WeatherDataUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: WeatherDataCreateOrConnectWithoutTenantInput | WeatherDataCreateOrConnectWithoutTenantInput[]
    upsert?: WeatherDataUpsertWithWhereUniqueWithoutTenantInput | WeatherDataUpsertWithWhereUniqueWithoutTenantInput[]
    createMany?: WeatherDataCreateManyTenantInputEnvelope
    set?: WeatherDataWhereUniqueInput | WeatherDataWhereUniqueInput[]
    disconnect?: WeatherDataWhereUniqueInput | WeatherDataWhereUniqueInput[]
    delete?: WeatherDataWhereUniqueInput | WeatherDataWhereUniqueInput[]
    connect?: WeatherDataWhereUniqueInput | WeatherDataWhereUniqueInput[]
    update?: WeatherDataUpdateWithWhereUniqueWithoutTenantInput | WeatherDataUpdateWithWhereUniqueWithoutTenantInput[]
    updateMany?: WeatherDataUpdateManyWithWhereWithoutTenantInput | WeatherDataUpdateManyWithWhereWithoutTenantInput[]
    deleteMany?: WeatherDataScalarWhereInput | WeatherDataScalarWhereInput[]
  }

  export type MembershipUncheckedUpdateManyWithoutTenantNestedInput = {
    create?: XOR<MembershipCreateWithoutTenantInput, MembershipUncheckedCreateWithoutTenantInput> | MembershipCreateWithoutTenantInput[] | MembershipUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: MembershipCreateOrConnectWithoutTenantInput | MembershipCreateOrConnectWithoutTenantInput[]
    upsert?: MembershipUpsertWithWhereUniqueWithoutTenantInput | MembershipUpsertWithWhereUniqueWithoutTenantInput[]
    createMany?: MembershipCreateManyTenantInputEnvelope
    set?: MembershipWhereUniqueInput | MembershipWhereUniqueInput[]
    disconnect?: MembershipWhereUniqueInput | MembershipWhereUniqueInput[]
    delete?: MembershipWhereUniqueInput | MembershipWhereUniqueInput[]
    connect?: MembershipWhereUniqueInput | MembershipWhereUniqueInput[]
    update?: MembershipUpdateWithWhereUniqueWithoutTenantInput | MembershipUpdateWithWhereUniqueWithoutTenantInput[]
    updateMany?: MembershipUpdateManyWithWhereWithoutTenantInput | MembershipUpdateManyWithWhereWithoutTenantInput[]
    deleteMany?: MembershipScalarWhereInput | MembershipScalarWhereInput[]
  }

  export type SiteUncheckedUpdateManyWithoutTenantNestedInput = {
    create?: XOR<SiteCreateWithoutTenantInput, SiteUncheckedCreateWithoutTenantInput> | SiteCreateWithoutTenantInput[] | SiteUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: SiteCreateOrConnectWithoutTenantInput | SiteCreateOrConnectWithoutTenantInput[]
    upsert?: SiteUpsertWithWhereUniqueWithoutTenantInput | SiteUpsertWithWhereUniqueWithoutTenantInput[]
    createMany?: SiteCreateManyTenantInputEnvelope
    set?: SiteWhereUniqueInput | SiteWhereUniqueInput[]
    disconnect?: SiteWhereUniqueInput | SiteWhereUniqueInput[]
    delete?: SiteWhereUniqueInput | SiteWhereUniqueInput[]
    connect?: SiteWhereUniqueInput | SiteWhereUniqueInput[]
    update?: SiteUpdateWithWhereUniqueWithoutTenantInput | SiteUpdateWithWhereUniqueWithoutTenantInput[]
    updateMany?: SiteUpdateManyWithWhereWithoutTenantInput | SiteUpdateManyWithWhereWithoutTenantInput[]
    deleteMany?: SiteScalarWhereInput | SiteScalarWhereInput[]
  }

  export type DeviceUncheckedUpdateManyWithoutTenantNestedInput = {
    create?: XOR<DeviceCreateWithoutTenantInput, DeviceUncheckedCreateWithoutTenantInput> | DeviceCreateWithoutTenantInput[] | DeviceUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: DeviceCreateOrConnectWithoutTenantInput | DeviceCreateOrConnectWithoutTenantInput[]
    upsert?: DeviceUpsertWithWhereUniqueWithoutTenantInput | DeviceUpsertWithWhereUniqueWithoutTenantInput[]
    createMany?: DeviceCreateManyTenantInputEnvelope
    set?: DeviceWhereUniqueInput | DeviceWhereUniqueInput[]
    disconnect?: DeviceWhereUniqueInput | DeviceWhereUniqueInput[]
    delete?: DeviceWhereUniqueInput | DeviceWhereUniqueInput[]
    connect?: DeviceWhereUniqueInput | DeviceWhereUniqueInput[]
    update?: DeviceUpdateWithWhereUniqueWithoutTenantInput | DeviceUpdateWithWhereUniqueWithoutTenantInput[]
    updateMany?: DeviceUpdateManyWithWhereWithoutTenantInput | DeviceUpdateManyWithWhereWithoutTenantInput[]
    deleteMany?: DeviceScalarWhereInput | DeviceScalarWhereInput[]
  }

  export type AlertRuleUncheckedUpdateManyWithoutTenantNestedInput = {
    create?: XOR<AlertRuleCreateWithoutTenantInput, AlertRuleUncheckedCreateWithoutTenantInput> | AlertRuleCreateWithoutTenantInput[] | AlertRuleUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: AlertRuleCreateOrConnectWithoutTenantInput | AlertRuleCreateOrConnectWithoutTenantInput[]
    upsert?: AlertRuleUpsertWithWhereUniqueWithoutTenantInput | AlertRuleUpsertWithWhereUniqueWithoutTenantInput[]
    createMany?: AlertRuleCreateManyTenantInputEnvelope
    set?: AlertRuleWhereUniqueInput | AlertRuleWhereUniqueInput[]
    disconnect?: AlertRuleWhereUniqueInput | AlertRuleWhereUniqueInput[]
    delete?: AlertRuleWhereUniqueInput | AlertRuleWhereUniqueInput[]
    connect?: AlertRuleWhereUniqueInput | AlertRuleWhereUniqueInput[]
    update?: AlertRuleUpdateWithWhereUniqueWithoutTenantInput | AlertRuleUpdateWithWhereUniqueWithoutTenantInput[]
    updateMany?: AlertRuleUpdateManyWithWhereWithoutTenantInput | AlertRuleUpdateManyWithWhereWithoutTenantInput[]
    deleteMany?: AlertRuleScalarWhereInput | AlertRuleScalarWhereInput[]
  }

  export type AlertEventUncheckedUpdateManyWithoutTenantNestedInput = {
    create?: XOR<AlertEventCreateWithoutTenantInput, AlertEventUncheckedCreateWithoutTenantInput> | AlertEventCreateWithoutTenantInput[] | AlertEventUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: AlertEventCreateOrConnectWithoutTenantInput | AlertEventCreateOrConnectWithoutTenantInput[]
    upsert?: AlertEventUpsertWithWhereUniqueWithoutTenantInput | AlertEventUpsertWithWhereUniqueWithoutTenantInput[]
    createMany?: AlertEventCreateManyTenantInputEnvelope
    set?: AlertEventWhereUniqueInput | AlertEventWhereUniqueInput[]
    disconnect?: AlertEventWhereUniqueInput | AlertEventWhereUniqueInput[]
    delete?: AlertEventWhereUniqueInput | AlertEventWhereUniqueInput[]
    connect?: AlertEventWhereUniqueInput | AlertEventWhereUniqueInput[]
    update?: AlertEventUpdateWithWhereUniqueWithoutTenantInput | AlertEventUpdateWithWhereUniqueWithoutTenantInput[]
    updateMany?: AlertEventUpdateManyWithWhereWithoutTenantInput | AlertEventUpdateManyWithWhereWithoutTenantInput[]
    deleteMany?: AlertEventScalarWhereInput | AlertEventScalarWhereInput[]
  }

  export type NotificationChannelUncheckedUpdateManyWithoutTenantNestedInput = {
    create?: XOR<NotificationChannelCreateWithoutTenantInput, NotificationChannelUncheckedCreateWithoutTenantInput> | NotificationChannelCreateWithoutTenantInput[] | NotificationChannelUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: NotificationChannelCreateOrConnectWithoutTenantInput | NotificationChannelCreateOrConnectWithoutTenantInput[]
    upsert?: NotificationChannelUpsertWithWhereUniqueWithoutTenantInput | NotificationChannelUpsertWithWhereUniqueWithoutTenantInput[]
    createMany?: NotificationChannelCreateManyTenantInputEnvelope
    set?: NotificationChannelWhereUniqueInput | NotificationChannelWhereUniqueInput[]
    disconnect?: NotificationChannelWhereUniqueInput | NotificationChannelWhereUniqueInput[]
    delete?: NotificationChannelWhereUniqueInput | NotificationChannelWhereUniqueInput[]
    connect?: NotificationChannelWhereUniqueInput | NotificationChannelWhereUniqueInput[]
    update?: NotificationChannelUpdateWithWhereUniqueWithoutTenantInput | NotificationChannelUpdateWithWhereUniqueWithoutTenantInput[]
    updateMany?: NotificationChannelUpdateManyWithWhereWithoutTenantInput | NotificationChannelUpdateManyWithWhereWithoutTenantInput[]
    deleteMany?: NotificationChannelScalarWhereInput | NotificationChannelScalarWhereInput[]
  }

  export type NotificationEventUncheckedUpdateManyWithoutTenantNestedInput = {
    create?: XOR<NotificationEventCreateWithoutTenantInput, NotificationEventUncheckedCreateWithoutTenantInput> | NotificationEventCreateWithoutTenantInput[] | NotificationEventUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: NotificationEventCreateOrConnectWithoutTenantInput | NotificationEventCreateOrConnectWithoutTenantInput[]
    upsert?: NotificationEventUpsertWithWhereUniqueWithoutTenantInput | NotificationEventUpsertWithWhereUniqueWithoutTenantInput[]
    createMany?: NotificationEventCreateManyTenantInputEnvelope
    set?: NotificationEventWhereUniqueInput | NotificationEventWhereUniqueInput[]
    disconnect?: NotificationEventWhereUniqueInput | NotificationEventWhereUniqueInput[]
    delete?: NotificationEventWhereUniqueInput | NotificationEventWhereUniqueInput[]
    connect?: NotificationEventWhereUniqueInput | NotificationEventWhereUniqueInput[]
    update?: NotificationEventUpdateWithWhereUniqueWithoutTenantInput | NotificationEventUpdateWithWhereUniqueWithoutTenantInput[]
    updateMany?: NotificationEventUpdateManyWithWhereWithoutTenantInput | NotificationEventUpdateManyWithWhereWithoutTenantInput[]
    deleteMany?: NotificationEventScalarWhereInput | NotificationEventScalarWhereInput[]
  }

  export type DailyRollupUncheckedUpdateManyWithoutTenantNestedInput = {
    create?: XOR<DailyRollupCreateWithoutTenantInput, DailyRollupUncheckedCreateWithoutTenantInput> | DailyRollupCreateWithoutTenantInput[] | DailyRollupUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: DailyRollupCreateOrConnectWithoutTenantInput | DailyRollupCreateOrConnectWithoutTenantInput[]
    upsert?: DailyRollupUpsertWithWhereUniqueWithoutTenantInput | DailyRollupUpsertWithWhereUniqueWithoutTenantInput[]
    createMany?: DailyRollupCreateManyTenantInputEnvelope
    set?: DailyRollupWhereUniqueInput | DailyRollupWhereUniqueInput[]
    disconnect?: DailyRollupWhereUniqueInput | DailyRollupWhereUniqueInput[]
    delete?: DailyRollupWhereUniqueInput | DailyRollupWhereUniqueInput[]
    connect?: DailyRollupWhereUniqueInput | DailyRollupWhereUniqueInput[]
    update?: DailyRollupUpdateWithWhereUniqueWithoutTenantInput | DailyRollupUpdateWithWhereUniqueWithoutTenantInput[]
    updateMany?: DailyRollupUpdateManyWithWhereWithoutTenantInput | DailyRollupUpdateManyWithWhereWithoutTenantInput[]
    deleteMany?: DailyRollupScalarWhereInput | DailyRollupScalarWhereInput[]
  }

  export type EntitlementUncheckedUpdateManyWithoutTenantNestedInput = {
    create?: XOR<EntitlementCreateWithoutTenantInput, EntitlementUncheckedCreateWithoutTenantInput> | EntitlementCreateWithoutTenantInput[] | EntitlementUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: EntitlementCreateOrConnectWithoutTenantInput | EntitlementCreateOrConnectWithoutTenantInput[]
    upsert?: EntitlementUpsertWithWhereUniqueWithoutTenantInput | EntitlementUpsertWithWhereUniqueWithoutTenantInput[]
    createMany?: EntitlementCreateManyTenantInputEnvelope
    set?: EntitlementWhereUniqueInput | EntitlementWhereUniqueInput[]
    disconnect?: EntitlementWhereUniqueInput | EntitlementWhereUniqueInput[]
    delete?: EntitlementWhereUniqueInput | EntitlementWhereUniqueInput[]
    connect?: EntitlementWhereUniqueInput | EntitlementWhereUniqueInput[]
    update?: EntitlementUpdateWithWhereUniqueWithoutTenantInput | EntitlementUpdateWithWhereUniqueWithoutTenantInput[]
    updateMany?: EntitlementUpdateManyWithWhereWithoutTenantInput | EntitlementUpdateManyWithWhereWithoutTenantInput[]
    deleteMany?: EntitlementScalarWhereInput | EntitlementScalarWhereInput[]
  }

  export type AuditLogUncheckedUpdateManyWithoutTenantNestedInput = {
    create?: XOR<AuditLogCreateWithoutTenantInput, AuditLogUncheckedCreateWithoutTenantInput> | AuditLogCreateWithoutTenantInput[] | AuditLogUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: AuditLogCreateOrConnectWithoutTenantInput | AuditLogCreateOrConnectWithoutTenantInput[]
    upsert?: AuditLogUpsertWithWhereUniqueWithoutTenantInput | AuditLogUpsertWithWhereUniqueWithoutTenantInput[]
    createMany?: AuditLogCreateManyTenantInputEnvelope
    set?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    disconnect?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    delete?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    connect?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    update?: AuditLogUpdateWithWhereUniqueWithoutTenantInput | AuditLogUpdateWithWhereUniqueWithoutTenantInput[]
    updateMany?: AuditLogUpdateManyWithWhereWithoutTenantInput | AuditLogUpdateManyWithWhereWithoutTenantInput[]
    deleteMany?: AuditLogScalarWhereInput | AuditLogScalarWhereInput[]
  }

  export type OtaJobUncheckedUpdateManyWithoutTenantNestedInput = {
    create?: XOR<OtaJobCreateWithoutTenantInput, OtaJobUncheckedCreateWithoutTenantInput> | OtaJobCreateWithoutTenantInput[] | OtaJobUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: OtaJobCreateOrConnectWithoutTenantInput | OtaJobCreateOrConnectWithoutTenantInput[]
    upsert?: OtaJobUpsertWithWhereUniqueWithoutTenantInput | OtaJobUpsertWithWhereUniqueWithoutTenantInput[]
    createMany?: OtaJobCreateManyTenantInputEnvelope
    set?: OtaJobWhereUniqueInput | OtaJobWhereUniqueInput[]
    disconnect?: OtaJobWhereUniqueInput | OtaJobWhereUniqueInput[]
    delete?: OtaJobWhereUniqueInput | OtaJobWhereUniqueInput[]
    connect?: OtaJobWhereUniqueInput | OtaJobWhereUniqueInput[]
    update?: OtaJobUpdateWithWhereUniqueWithoutTenantInput | OtaJobUpdateWithWhereUniqueWithoutTenantInput[]
    updateMany?: OtaJobUpdateManyWithWhereWithoutTenantInput | OtaJobUpdateManyWithWhereWithoutTenantInput[]
    deleteMany?: OtaJobScalarWhereInput | OtaJobScalarWhereInput[]
  }

  export type WeatherDataUncheckedUpdateManyWithoutTenantNestedInput = {
    create?: XOR<WeatherDataCreateWithoutTenantInput, WeatherDataUncheckedCreateWithoutTenantInput> | WeatherDataCreateWithoutTenantInput[] | WeatherDataUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: WeatherDataCreateOrConnectWithoutTenantInput | WeatherDataCreateOrConnectWithoutTenantInput[]
    upsert?: WeatherDataUpsertWithWhereUniqueWithoutTenantInput | WeatherDataUpsertWithWhereUniqueWithoutTenantInput[]
    createMany?: WeatherDataCreateManyTenantInputEnvelope
    set?: WeatherDataWhereUniqueInput | WeatherDataWhereUniqueInput[]
    disconnect?: WeatherDataWhereUniqueInput | WeatherDataWhereUniqueInput[]
    delete?: WeatherDataWhereUniqueInput | WeatherDataWhereUniqueInput[]
    connect?: WeatherDataWhereUniqueInput | WeatherDataWhereUniqueInput[]
    update?: WeatherDataUpdateWithWhereUniqueWithoutTenantInput | WeatherDataUpdateWithWhereUniqueWithoutTenantInput[]
    updateMany?: WeatherDataUpdateManyWithWhereWithoutTenantInput | WeatherDataUpdateManyWithWhereWithoutTenantInput[]
    deleteMany?: WeatherDataScalarWhereInput | WeatherDataScalarWhereInput[]
  }

  export type MembershipCreateNestedManyWithoutUserInput = {
    create?: XOR<MembershipCreateWithoutUserInput, MembershipUncheckedCreateWithoutUserInput> | MembershipCreateWithoutUserInput[] | MembershipUncheckedCreateWithoutUserInput[]
    connectOrCreate?: MembershipCreateOrConnectWithoutUserInput | MembershipCreateOrConnectWithoutUserInput[]
    createMany?: MembershipCreateManyUserInputEnvelope
    connect?: MembershipWhereUniqueInput | MembershipWhereUniqueInput[]
  }

  export type CommandCreateNestedManyWithoutRequestedByInput = {
    create?: XOR<CommandCreateWithoutRequestedByInput, CommandUncheckedCreateWithoutRequestedByInput> | CommandCreateWithoutRequestedByInput[] | CommandUncheckedCreateWithoutRequestedByInput[]
    connectOrCreate?: CommandCreateOrConnectWithoutRequestedByInput | CommandCreateOrConnectWithoutRequestedByInput[]
    createMany?: CommandCreateManyRequestedByInputEnvelope
    connect?: CommandWhereUniqueInput | CommandWhereUniqueInput[]
  }

  export type OtaJobCreateNestedManyWithoutCreatedByInput = {
    create?: XOR<OtaJobCreateWithoutCreatedByInput, OtaJobUncheckedCreateWithoutCreatedByInput> | OtaJobCreateWithoutCreatedByInput[] | OtaJobUncheckedCreateWithoutCreatedByInput[]
    connectOrCreate?: OtaJobCreateOrConnectWithoutCreatedByInput | OtaJobCreateOrConnectWithoutCreatedByInput[]
    createMany?: OtaJobCreateManyCreatedByInputEnvelope
    connect?: OtaJobWhereUniqueInput | OtaJobWhereUniqueInput[]
  }

  export type SimActionCreateNestedManyWithoutRequestedByInput = {
    create?: XOR<SimActionCreateWithoutRequestedByInput, SimActionUncheckedCreateWithoutRequestedByInput> | SimActionCreateWithoutRequestedByInput[] | SimActionUncheckedCreateWithoutRequestedByInput[]
    connectOrCreate?: SimActionCreateOrConnectWithoutRequestedByInput | SimActionCreateOrConnectWithoutRequestedByInput[]
    createMany?: SimActionCreateManyRequestedByInputEnvelope
    connect?: SimActionWhereUniqueInput | SimActionWhereUniqueInput[]
  }

  export type SiteCreateNestedManyWithoutLocationUpdatedByInput = {
    create?: XOR<SiteCreateWithoutLocationUpdatedByInput, SiteUncheckedCreateWithoutLocationUpdatedByInput> | SiteCreateWithoutLocationUpdatedByInput[] | SiteUncheckedCreateWithoutLocationUpdatedByInput[]
    connectOrCreate?: SiteCreateOrConnectWithoutLocationUpdatedByInput | SiteCreateOrConnectWithoutLocationUpdatedByInput[]
    createMany?: SiteCreateManyLocationUpdatedByInputEnvelope
    connect?: SiteWhereUniqueInput | SiteWhereUniqueInput[]
  }

  export type MembershipUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<MembershipCreateWithoutUserInput, MembershipUncheckedCreateWithoutUserInput> | MembershipCreateWithoutUserInput[] | MembershipUncheckedCreateWithoutUserInput[]
    connectOrCreate?: MembershipCreateOrConnectWithoutUserInput | MembershipCreateOrConnectWithoutUserInput[]
    createMany?: MembershipCreateManyUserInputEnvelope
    connect?: MembershipWhereUniqueInput | MembershipWhereUniqueInput[]
  }

  export type CommandUncheckedCreateNestedManyWithoutRequestedByInput = {
    create?: XOR<CommandCreateWithoutRequestedByInput, CommandUncheckedCreateWithoutRequestedByInput> | CommandCreateWithoutRequestedByInput[] | CommandUncheckedCreateWithoutRequestedByInput[]
    connectOrCreate?: CommandCreateOrConnectWithoutRequestedByInput | CommandCreateOrConnectWithoutRequestedByInput[]
    createMany?: CommandCreateManyRequestedByInputEnvelope
    connect?: CommandWhereUniqueInput | CommandWhereUniqueInput[]
  }

  export type OtaJobUncheckedCreateNestedManyWithoutCreatedByInput = {
    create?: XOR<OtaJobCreateWithoutCreatedByInput, OtaJobUncheckedCreateWithoutCreatedByInput> | OtaJobCreateWithoutCreatedByInput[] | OtaJobUncheckedCreateWithoutCreatedByInput[]
    connectOrCreate?: OtaJobCreateOrConnectWithoutCreatedByInput | OtaJobCreateOrConnectWithoutCreatedByInput[]
    createMany?: OtaJobCreateManyCreatedByInputEnvelope
    connect?: OtaJobWhereUniqueInput | OtaJobWhereUniqueInput[]
  }

  export type SimActionUncheckedCreateNestedManyWithoutRequestedByInput = {
    create?: XOR<SimActionCreateWithoutRequestedByInput, SimActionUncheckedCreateWithoutRequestedByInput> | SimActionCreateWithoutRequestedByInput[] | SimActionUncheckedCreateWithoutRequestedByInput[]
    connectOrCreate?: SimActionCreateOrConnectWithoutRequestedByInput | SimActionCreateOrConnectWithoutRequestedByInput[]
    createMany?: SimActionCreateManyRequestedByInputEnvelope
    connect?: SimActionWhereUniqueInput | SimActionWhereUniqueInput[]
  }

  export type SiteUncheckedCreateNestedManyWithoutLocationUpdatedByInput = {
    create?: XOR<SiteCreateWithoutLocationUpdatedByInput, SiteUncheckedCreateWithoutLocationUpdatedByInput> | SiteCreateWithoutLocationUpdatedByInput[] | SiteUncheckedCreateWithoutLocationUpdatedByInput[]
    connectOrCreate?: SiteCreateOrConnectWithoutLocationUpdatedByInput | SiteCreateOrConnectWithoutLocationUpdatedByInput[]
    createMany?: SiteCreateManyLocationUpdatedByInputEnvelope
    connect?: SiteWhereUniqueInput | SiteWhereUniqueInput[]
  }

  export type EnumUserStatusFieldUpdateOperationsInput = {
    set?: $Enums.UserStatus
  }

  export type MembershipUpdateManyWithoutUserNestedInput = {
    create?: XOR<MembershipCreateWithoutUserInput, MembershipUncheckedCreateWithoutUserInput> | MembershipCreateWithoutUserInput[] | MembershipUncheckedCreateWithoutUserInput[]
    connectOrCreate?: MembershipCreateOrConnectWithoutUserInput | MembershipCreateOrConnectWithoutUserInput[]
    upsert?: MembershipUpsertWithWhereUniqueWithoutUserInput | MembershipUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: MembershipCreateManyUserInputEnvelope
    set?: MembershipWhereUniqueInput | MembershipWhereUniqueInput[]
    disconnect?: MembershipWhereUniqueInput | MembershipWhereUniqueInput[]
    delete?: MembershipWhereUniqueInput | MembershipWhereUniqueInput[]
    connect?: MembershipWhereUniqueInput | MembershipWhereUniqueInput[]
    update?: MembershipUpdateWithWhereUniqueWithoutUserInput | MembershipUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: MembershipUpdateManyWithWhereWithoutUserInput | MembershipUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: MembershipScalarWhereInput | MembershipScalarWhereInput[]
  }

  export type CommandUpdateManyWithoutRequestedByNestedInput = {
    create?: XOR<CommandCreateWithoutRequestedByInput, CommandUncheckedCreateWithoutRequestedByInput> | CommandCreateWithoutRequestedByInput[] | CommandUncheckedCreateWithoutRequestedByInput[]
    connectOrCreate?: CommandCreateOrConnectWithoutRequestedByInput | CommandCreateOrConnectWithoutRequestedByInput[]
    upsert?: CommandUpsertWithWhereUniqueWithoutRequestedByInput | CommandUpsertWithWhereUniqueWithoutRequestedByInput[]
    createMany?: CommandCreateManyRequestedByInputEnvelope
    set?: CommandWhereUniqueInput | CommandWhereUniqueInput[]
    disconnect?: CommandWhereUniqueInput | CommandWhereUniqueInput[]
    delete?: CommandWhereUniqueInput | CommandWhereUniqueInput[]
    connect?: CommandWhereUniqueInput | CommandWhereUniqueInput[]
    update?: CommandUpdateWithWhereUniqueWithoutRequestedByInput | CommandUpdateWithWhereUniqueWithoutRequestedByInput[]
    updateMany?: CommandUpdateManyWithWhereWithoutRequestedByInput | CommandUpdateManyWithWhereWithoutRequestedByInput[]
    deleteMany?: CommandScalarWhereInput | CommandScalarWhereInput[]
  }

  export type OtaJobUpdateManyWithoutCreatedByNestedInput = {
    create?: XOR<OtaJobCreateWithoutCreatedByInput, OtaJobUncheckedCreateWithoutCreatedByInput> | OtaJobCreateWithoutCreatedByInput[] | OtaJobUncheckedCreateWithoutCreatedByInput[]
    connectOrCreate?: OtaJobCreateOrConnectWithoutCreatedByInput | OtaJobCreateOrConnectWithoutCreatedByInput[]
    upsert?: OtaJobUpsertWithWhereUniqueWithoutCreatedByInput | OtaJobUpsertWithWhereUniqueWithoutCreatedByInput[]
    createMany?: OtaJobCreateManyCreatedByInputEnvelope
    set?: OtaJobWhereUniqueInput | OtaJobWhereUniqueInput[]
    disconnect?: OtaJobWhereUniqueInput | OtaJobWhereUniqueInput[]
    delete?: OtaJobWhereUniqueInput | OtaJobWhereUniqueInput[]
    connect?: OtaJobWhereUniqueInput | OtaJobWhereUniqueInput[]
    update?: OtaJobUpdateWithWhereUniqueWithoutCreatedByInput | OtaJobUpdateWithWhereUniqueWithoutCreatedByInput[]
    updateMany?: OtaJobUpdateManyWithWhereWithoutCreatedByInput | OtaJobUpdateManyWithWhereWithoutCreatedByInput[]
    deleteMany?: OtaJobScalarWhereInput | OtaJobScalarWhereInput[]
  }

  export type SimActionUpdateManyWithoutRequestedByNestedInput = {
    create?: XOR<SimActionCreateWithoutRequestedByInput, SimActionUncheckedCreateWithoutRequestedByInput> | SimActionCreateWithoutRequestedByInput[] | SimActionUncheckedCreateWithoutRequestedByInput[]
    connectOrCreate?: SimActionCreateOrConnectWithoutRequestedByInput | SimActionCreateOrConnectWithoutRequestedByInput[]
    upsert?: SimActionUpsertWithWhereUniqueWithoutRequestedByInput | SimActionUpsertWithWhereUniqueWithoutRequestedByInput[]
    createMany?: SimActionCreateManyRequestedByInputEnvelope
    set?: SimActionWhereUniqueInput | SimActionWhereUniqueInput[]
    disconnect?: SimActionWhereUniqueInput | SimActionWhereUniqueInput[]
    delete?: SimActionWhereUniqueInput | SimActionWhereUniqueInput[]
    connect?: SimActionWhereUniqueInput | SimActionWhereUniqueInput[]
    update?: SimActionUpdateWithWhereUniqueWithoutRequestedByInput | SimActionUpdateWithWhereUniqueWithoutRequestedByInput[]
    updateMany?: SimActionUpdateManyWithWhereWithoutRequestedByInput | SimActionUpdateManyWithWhereWithoutRequestedByInput[]
    deleteMany?: SimActionScalarWhereInput | SimActionScalarWhereInput[]
  }

  export type SiteUpdateManyWithoutLocationUpdatedByNestedInput = {
    create?: XOR<SiteCreateWithoutLocationUpdatedByInput, SiteUncheckedCreateWithoutLocationUpdatedByInput> | SiteCreateWithoutLocationUpdatedByInput[] | SiteUncheckedCreateWithoutLocationUpdatedByInput[]
    connectOrCreate?: SiteCreateOrConnectWithoutLocationUpdatedByInput | SiteCreateOrConnectWithoutLocationUpdatedByInput[]
    upsert?: SiteUpsertWithWhereUniqueWithoutLocationUpdatedByInput | SiteUpsertWithWhereUniqueWithoutLocationUpdatedByInput[]
    createMany?: SiteCreateManyLocationUpdatedByInputEnvelope
    set?: SiteWhereUniqueInput | SiteWhereUniqueInput[]
    disconnect?: SiteWhereUniqueInput | SiteWhereUniqueInput[]
    delete?: SiteWhereUniqueInput | SiteWhereUniqueInput[]
    connect?: SiteWhereUniqueInput | SiteWhereUniqueInput[]
    update?: SiteUpdateWithWhereUniqueWithoutLocationUpdatedByInput | SiteUpdateWithWhereUniqueWithoutLocationUpdatedByInput[]
    updateMany?: SiteUpdateManyWithWhereWithoutLocationUpdatedByInput | SiteUpdateManyWithWhereWithoutLocationUpdatedByInput[]
    deleteMany?: SiteScalarWhereInput | SiteScalarWhereInput[]
  }

  export type MembershipUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<MembershipCreateWithoutUserInput, MembershipUncheckedCreateWithoutUserInput> | MembershipCreateWithoutUserInput[] | MembershipUncheckedCreateWithoutUserInput[]
    connectOrCreate?: MembershipCreateOrConnectWithoutUserInput | MembershipCreateOrConnectWithoutUserInput[]
    upsert?: MembershipUpsertWithWhereUniqueWithoutUserInput | MembershipUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: MembershipCreateManyUserInputEnvelope
    set?: MembershipWhereUniqueInput | MembershipWhereUniqueInput[]
    disconnect?: MembershipWhereUniqueInput | MembershipWhereUniqueInput[]
    delete?: MembershipWhereUniqueInput | MembershipWhereUniqueInput[]
    connect?: MembershipWhereUniqueInput | MembershipWhereUniqueInput[]
    update?: MembershipUpdateWithWhereUniqueWithoutUserInput | MembershipUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: MembershipUpdateManyWithWhereWithoutUserInput | MembershipUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: MembershipScalarWhereInput | MembershipScalarWhereInput[]
  }

  export type CommandUncheckedUpdateManyWithoutRequestedByNestedInput = {
    create?: XOR<CommandCreateWithoutRequestedByInput, CommandUncheckedCreateWithoutRequestedByInput> | CommandCreateWithoutRequestedByInput[] | CommandUncheckedCreateWithoutRequestedByInput[]
    connectOrCreate?: CommandCreateOrConnectWithoutRequestedByInput | CommandCreateOrConnectWithoutRequestedByInput[]
    upsert?: CommandUpsertWithWhereUniqueWithoutRequestedByInput | CommandUpsertWithWhereUniqueWithoutRequestedByInput[]
    createMany?: CommandCreateManyRequestedByInputEnvelope
    set?: CommandWhereUniqueInput | CommandWhereUniqueInput[]
    disconnect?: CommandWhereUniqueInput | CommandWhereUniqueInput[]
    delete?: CommandWhereUniqueInput | CommandWhereUniqueInput[]
    connect?: CommandWhereUniqueInput | CommandWhereUniqueInput[]
    update?: CommandUpdateWithWhereUniqueWithoutRequestedByInput | CommandUpdateWithWhereUniqueWithoutRequestedByInput[]
    updateMany?: CommandUpdateManyWithWhereWithoutRequestedByInput | CommandUpdateManyWithWhereWithoutRequestedByInput[]
    deleteMany?: CommandScalarWhereInput | CommandScalarWhereInput[]
  }

  export type OtaJobUncheckedUpdateManyWithoutCreatedByNestedInput = {
    create?: XOR<OtaJobCreateWithoutCreatedByInput, OtaJobUncheckedCreateWithoutCreatedByInput> | OtaJobCreateWithoutCreatedByInput[] | OtaJobUncheckedCreateWithoutCreatedByInput[]
    connectOrCreate?: OtaJobCreateOrConnectWithoutCreatedByInput | OtaJobCreateOrConnectWithoutCreatedByInput[]
    upsert?: OtaJobUpsertWithWhereUniqueWithoutCreatedByInput | OtaJobUpsertWithWhereUniqueWithoutCreatedByInput[]
    createMany?: OtaJobCreateManyCreatedByInputEnvelope
    set?: OtaJobWhereUniqueInput | OtaJobWhereUniqueInput[]
    disconnect?: OtaJobWhereUniqueInput | OtaJobWhereUniqueInput[]
    delete?: OtaJobWhereUniqueInput | OtaJobWhereUniqueInput[]
    connect?: OtaJobWhereUniqueInput | OtaJobWhereUniqueInput[]
    update?: OtaJobUpdateWithWhereUniqueWithoutCreatedByInput | OtaJobUpdateWithWhereUniqueWithoutCreatedByInput[]
    updateMany?: OtaJobUpdateManyWithWhereWithoutCreatedByInput | OtaJobUpdateManyWithWhereWithoutCreatedByInput[]
    deleteMany?: OtaJobScalarWhereInput | OtaJobScalarWhereInput[]
  }

  export type SimActionUncheckedUpdateManyWithoutRequestedByNestedInput = {
    create?: XOR<SimActionCreateWithoutRequestedByInput, SimActionUncheckedCreateWithoutRequestedByInput> | SimActionCreateWithoutRequestedByInput[] | SimActionUncheckedCreateWithoutRequestedByInput[]
    connectOrCreate?: SimActionCreateOrConnectWithoutRequestedByInput | SimActionCreateOrConnectWithoutRequestedByInput[]
    upsert?: SimActionUpsertWithWhereUniqueWithoutRequestedByInput | SimActionUpsertWithWhereUniqueWithoutRequestedByInput[]
    createMany?: SimActionCreateManyRequestedByInputEnvelope
    set?: SimActionWhereUniqueInput | SimActionWhereUniqueInput[]
    disconnect?: SimActionWhereUniqueInput | SimActionWhereUniqueInput[]
    delete?: SimActionWhereUniqueInput | SimActionWhereUniqueInput[]
    connect?: SimActionWhereUniqueInput | SimActionWhereUniqueInput[]
    update?: SimActionUpdateWithWhereUniqueWithoutRequestedByInput | SimActionUpdateWithWhereUniqueWithoutRequestedByInput[]
    updateMany?: SimActionUpdateManyWithWhereWithoutRequestedByInput | SimActionUpdateManyWithWhereWithoutRequestedByInput[]
    deleteMany?: SimActionScalarWhereInput | SimActionScalarWhereInput[]
  }

  export type SiteUncheckedUpdateManyWithoutLocationUpdatedByNestedInput = {
    create?: XOR<SiteCreateWithoutLocationUpdatedByInput, SiteUncheckedCreateWithoutLocationUpdatedByInput> | SiteCreateWithoutLocationUpdatedByInput[] | SiteUncheckedCreateWithoutLocationUpdatedByInput[]
    connectOrCreate?: SiteCreateOrConnectWithoutLocationUpdatedByInput | SiteCreateOrConnectWithoutLocationUpdatedByInput[]
    upsert?: SiteUpsertWithWhereUniqueWithoutLocationUpdatedByInput | SiteUpsertWithWhereUniqueWithoutLocationUpdatedByInput[]
    createMany?: SiteCreateManyLocationUpdatedByInputEnvelope
    set?: SiteWhereUniqueInput | SiteWhereUniqueInput[]
    disconnect?: SiteWhereUniqueInput | SiteWhereUniqueInput[]
    delete?: SiteWhereUniqueInput | SiteWhereUniqueInput[]
    connect?: SiteWhereUniqueInput | SiteWhereUniqueInput[]
    update?: SiteUpdateWithWhereUniqueWithoutLocationUpdatedByInput | SiteUpdateWithWhereUniqueWithoutLocationUpdatedByInput[]
    updateMany?: SiteUpdateManyWithWhereWithoutLocationUpdatedByInput | SiteUpdateManyWithWhereWithoutLocationUpdatedByInput[]
    deleteMany?: SiteScalarWhereInput | SiteScalarWhereInput[]
  }

  export type UserCreateNestedOneWithoutMembershipsInput = {
    create?: XOR<UserCreateWithoutMembershipsInput, UserUncheckedCreateWithoutMembershipsInput>
    connectOrCreate?: UserCreateOrConnectWithoutMembershipsInput
    connect?: UserWhereUniqueInput
  }

  export type TenantCreateNestedOneWithoutMembershipsInput = {
    create?: XOR<TenantCreateWithoutMembershipsInput, TenantUncheckedCreateWithoutMembershipsInput>
    connectOrCreate?: TenantCreateOrConnectWithoutMembershipsInput
    connect?: TenantWhereUniqueInput
  }

  export type EnumMembershipRoleFieldUpdateOperationsInput = {
    set?: $Enums.MembershipRole
  }

  export type UserUpdateOneRequiredWithoutMembershipsNestedInput = {
    create?: XOR<UserCreateWithoutMembershipsInput, UserUncheckedCreateWithoutMembershipsInput>
    connectOrCreate?: UserCreateOrConnectWithoutMembershipsInput
    upsert?: UserUpsertWithoutMembershipsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutMembershipsInput, UserUpdateWithoutMembershipsInput>, UserUncheckedUpdateWithoutMembershipsInput>
  }

  export type TenantUpdateOneRequiredWithoutMembershipsNestedInput = {
    create?: XOR<TenantCreateWithoutMembershipsInput, TenantUncheckedCreateWithoutMembershipsInput>
    connectOrCreate?: TenantCreateOrConnectWithoutMembershipsInput
    upsert?: TenantUpsertWithoutMembershipsInput
    connect?: TenantWhereUniqueInput
    update?: XOR<XOR<TenantUpdateToOneWithWhereWithoutMembershipsInput, TenantUpdateWithoutMembershipsInput>, TenantUncheckedUpdateWithoutMembershipsInput>
  }

  export type TenantCreateNestedOneWithoutSitesInput = {
    create?: XOR<TenantCreateWithoutSitesInput, TenantUncheckedCreateWithoutSitesInput>
    connectOrCreate?: TenantCreateOrConnectWithoutSitesInput
    connect?: TenantWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutSiteLocUpdatesInput = {
    create?: XOR<UserCreateWithoutSiteLocUpdatesInput, UserUncheckedCreateWithoutSiteLocUpdatesInput>
    connectOrCreate?: UserCreateOrConnectWithoutSiteLocUpdatesInput
    connect?: UserWhereUniqueInput
  }

  export type DeviceCreateNestedManyWithoutSiteInput = {
    create?: XOR<DeviceCreateWithoutSiteInput, DeviceUncheckedCreateWithoutSiteInput> | DeviceCreateWithoutSiteInput[] | DeviceUncheckedCreateWithoutSiteInput[]
    connectOrCreate?: DeviceCreateOrConnectWithoutSiteInput | DeviceCreateOrConnectWithoutSiteInput[]
    createMany?: DeviceCreateManySiteInputEnvelope
    connect?: DeviceWhereUniqueInput | DeviceWhereUniqueInput[]
  }

  export type WeatherDataCreateNestedManyWithoutSiteInput = {
    create?: XOR<WeatherDataCreateWithoutSiteInput, WeatherDataUncheckedCreateWithoutSiteInput> | WeatherDataCreateWithoutSiteInput[] | WeatherDataUncheckedCreateWithoutSiteInput[]
    connectOrCreate?: WeatherDataCreateOrConnectWithoutSiteInput | WeatherDataCreateOrConnectWithoutSiteInput[]
    createMany?: WeatherDataCreateManySiteInputEnvelope
    connect?: WeatherDataWhereUniqueInput | WeatherDataWhereUniqueInput[]
  }

  export type DeviceUncheckedCreateNestedManyWithoutSiteInput = {
    create?: XOR<DeviceCreateWithoutSiteInput, DeviceUncheckedCreateWithoutSiteInput> | DeviceCreateWithoutSiteInput[] | DeviceUncheckedCreateWithoutSiteInput[]
    connectOrCreate?: DeviceCreateOrConnectWithoutSiteInput | DeviceCreateOrConnectWithoutSiteInput[]
    createMany?: DeviceCreateManySiteInputEnvelope
    connect?: DeviceWhereUniqueInput | DeviceWhereUniqueInput[]
  }

  export type WeatherDataUncheckedCreateNestedManyWithoutSiteInput = {
    create?: XOR<WeatherDataCreateWithoutSiteInput, WeatherDataUncheckedCreateWithoutSiteInput> | WeatherDataCreateWithoutSiteInput[] | WeatherDataUncheckedCreateWithoutSiteInput[]
    connectOrCreate?: WeatherDataCreateOrConnectWithoutSiteInput | WeatherDataCreateOrConnectWithoutSiteInput[]
    createMany?: WeatherDataCreateManySiteInputEnvelope
    connect?: WeatherDataWhereUniqueInput | WeatherDataWhereUniqueInput[]
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type NullableFloatFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type NullableEnumLocationSourceFieldUpdateOperationsInput = {
    set?: $Enums.LocationSource | null
  }

  export type NullableDateTimeFieldUpdateOperationsInput = {
    set?: Date | string | null
  }

  export type BoolFieldUpdateOperationsInput = {
    set?: boolean
  }

  export type TenantUpdateOneRequiredWithoutSitesNestedInput = {
    create?: XOR<TenantCreateWithoutSitesInput, TenantUncheckedCreateWithoutSitesInput>
    connectOrCreate?: TenantCreateOrConnectWithoutSitesInput
    upsert?: TenantUpsertWithoutSitesInput
    connect?: TenantWhereUniqueInput
    update?: XOR<XOR<TenantUpdateToOneWithWhereWithoutSitesInput, TenantUpdateWithoutSitesInput>, TenantUncheckedUpdateWithoutSitesInput>
  }

  export type UserUpdateOneWithoutSiteLocUpdatesNestedInput = {
    create?: XOR<UserCreateWithoutSiteLocUpdatesInput, UserUncheckedCreateWithoutSiteLocUpdatesInput>
    connectOrCreate?: UserCreateOrConnectWithoutSiteLocUpdatesInput
    upsert?: UserUpsertWithoutSiteLocUpdatesInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutSiteLocUpdatesInput, UserUpdateWithoutSiteLocUpdatesInput>, UserUncheckedUpdateWithoutSiteLocUpdatesInput>
  }

  export type DeviceUpdateManyWithoutSiteNestedInput = {
    create?: XOR<DeviceCreateWithoutSiteInput, DeviceUncheckedCreateWithoutSiteInput> | DeviceCreateWithoutSiteInput[] | DeviceUncheckedCreateWithoutSiteInput[]
    connectOrCreate?: DeviceCreateOrConnectWithoutSiteInput | DeviceCreateOrConnectWithoutSiteInput[]
    upsert?: DeviceUpsertWithWhereUniqueWithoutSiteInput | DeviceUpsertWithWhereUniqueWithoutSiteInput[]
    createMany?: DeviceCreateManySiteInputEnvelope
    set?: DeviceWhereUniqueInput | DeviceWhereUniqueInput[]
    disconnect?: DeviceWhereUniqueInput | DeviceWhereUniqueInput[]
    delete?: DeviceWhereUniqueInput | DeviceWhereUniqueInput[]
    connect?: DeviceWhereUniqueInput | DeviceWhereUniqueInput[]
    update?: DeviceUpdateWithWhereUniqueWithoutSiteInput | DeviceUpdateWithWhereUniqueWithoutSiteInput[]
    updateMany?: DeviceUpdateManyWithWhereWithoutSiteInput | DeviceUpdateManyWithWhereWithoutSiteInput[]
    deleteMany?: DeviceScalarWhereInput | DeviceScalarWhereInput[]
  }

  export type WeatherDataUpdateManyWithoutSiteNestedInput = {
    create?: XOR<WeatherDataCreateWithoutSiteInput, WeatherDataUncheckedCreateWithoutSiteInput> | WeatherDataCreateWithoutSiteInput[] | WeatherDataUncheckedCreateWithoutSiteInput[]
    connectOrCreate?: WeatherDataCreateOrConnectWithoutSiteInput | WeatherDataCreateOrConnectWithoutSiteInput[]
    upsert?: WeatherDataUpsertWithWhereUniqueWithoutSiteInput | WeatherDataUpsertWithWhereUniqueWithoutSiteInput[]
    createMany?: WeatherDataCreateManySiteInputEnvelope
    set?: WeatherDataWhereUniqueInput | WeatherDataWhereUniqueInput[]
    disconnect?: WeatherDataWhereUniqueInput | WeatherDataWhereUniqueInput[]
    delete?: WeatherDataWhereUniqueInput | WeatherDataWhereUniqueInput[]
    connect?: WeatherDataWhereUniqueInput | WeatherDataWhereUniqueInput[]
    update?: WeatherDataUpdateWithWhereUniqueWithoutSiteInput | WeatherDataUpdateWithWhereUniqueWithoutSiteInput[]
    updateMany?: WeatherDataUpdateManyWithWhereWithoutSiteInput | WeatherDataUpdateManyWithWhereWithoutSiteInput[]
    deleteMany?: WeatherDataScalarWhereInput | WeatherDataScalarWhereInput[]
  }

  export type DeviceUncheckedUpdateManyWithoutSiteNestedInput = {
    create?: XOR<DeviceCreateWithoutSiteInput, DeviceUncheckedCreateWithoutSiteInput> | DeviceCreateWithoutSiteInput[] | DeviceUncheckedCreateWithoutSiteInput[]
    connectOrCreate?: DeviceCreateOrConnectWithoutSiteInput | DeviceCreateOrConnectWithoutSiteInput[]
    upsert?: DeviceUpsertWithWhereUniqueWithoutSiteInput | DeviceUpsertWithWhereUniqueWithoutSiteInput[]
    createMany?: DeviceCreateManySiteInputEnvelope
    set?: DeviceWhereUniqueInput | DeviceWhereUniqueInput[]
    disconnect?: DeviceWhereUniqueInput | DeviceWhereUniqueInput[]
    delete?: DeviceWhereUniqueInput | DeviceWhereUniqueInput[]
    connect?: DeviceWhereUniqueInput | DeviceWhereUniqueInput[]
    update?: DeviceUpdateWithWhereUniqueWithoutSiteInput | DeviceUpdateWithWhereUniqueWithoutSiteInput[]
    updateMany?: DeviceUpdateManyWithWhereWithoutSiteInput | DeviceUpdateManyWithWhereWithoutSiteInput[]
    deleteMany?: DeviceScalarWhereInput | DeviceScalarWhereInput[]
  }

  export type WeatherDataUncheckedUpdateManyWithoutSiteNestedInput = {
    create?: XOR<WeatherDataCreateWithoutSiteInput, WeatherDataUncheckedCreateWithoutSiteInput> | WeatherDataCreateWithoutSiteInput[] | WeatherDataUncheckedCreateWithoutSiteInput[]
    connectOrCreate?: WeatherDataCreateOrConnectWithoutSiteInput | WeatherDataCreateOrConnectWithoutSiteInput[]
    upsert?: WeatherDataUpsertWithWhereUniqueWithoutSiteInput | WeatherDataUpsertWithWhereUniqueWithoutSiteInput[]
    createMany?: WeatherDataCreateManySiteInputEnvelope
    set?: WeatherDataWhereUniqueInput | WeatherDataWhereUniqueInput[]
    disconnect?: WeatherDataWhereUniqueInput | WeatherDataWhereUniqueInput[]
    delete?: WeatherDataWhereUniqueInput | WeatherDataWhereUniqueInput[]
    connect?: WeatherDataWhereUniqueInput | WeatherDataWhereUniqueInput[]
    update?: WeatherDataUpdateWithWhereUniqueWithoutSiteInput | WeatherDataUpdateWithWhereUniqueWithoutSiteInput[]
    updateMany?: WeatherDataUpdateManyWithWhereWithoutSiteInput | WeatherDataUpdateManyWithWhereWithoutSiteInput[]
    deleteMany?: WeatherDataScalarWhereInput | WeatherDataScalarWhereInput[]
  }

  export type TenantCreateNestedOneWithoutDevicesInput = {
    create?: XOR<TenantCreateWithoutDevicesInput, TenantUncheckedCreateWithoutDevicesInput>
    connectOrCreate?: TenantCreateOrConnectWithoutDevicesInput
    connect?: TenantWhereUniqueInput
  }

  export type SiteCreateNestedOneWithoutDevicesInput = {
    create?: XOR<SiteCreateWithoutDevicesInput, SiteUncheckedCreateWithoutDevicesInput>
    connectOrCreate?: SiteCreateOrConnectWithoutDevicesInput
    connect?: SiteWhereUniqueInput
  }

  export type SimInfoCreateNestedOneWithoutDevicesInput = {
    create?: XOR<SimInfoCreateWithoutDevicesInput, SimInfoUncheckedCreateWithoutDevicesInput>
    connectOrCreate?: SimInfoCreateOrConnectWithoutDevicesInput
    connect?: SimInfoWhereUniqueInput
  }

  export type DeviceSecretCreateNestedOneWithoutDeviceInput = {
    create?: XOR<DeviceSecretCreateWithoutDeviceInput, DeviceSecretUncheckedCreateWithoutDeviceInput>
    connectOrCreate?: DeviceSecretCreateOrConnectWithoutDeviceInput
    connect?: DeviceSecretWhereUniqueInput
  }

  export type DeviceTwinCreateNestedOneWithoutDeviceInput = {
    create?: XOR<DeviceTwinCreateWithoutDeviceInput, DeviceTwinUncheckedCreateWithoutDeviceInput>
    connectOrCreate?: DeviceTwinCreateOrConnectWithoutDeviceInput
    connect?: DeviceTwinWhereUniqueInput
  }

  export type TelemetryCreateNestedManyWithoutDeviceInput = {
    create?: XOR<TelemetryCreateWithoutDeviceInput, TelemetryUncheckedCreateWithoutDeviceInput> | TelemetryCreateWithoutDeviceInput[] | TelemetryUncheckedCreateWithoutDeviceInput[]
    connectOrCreate?: TelemetryCreateOrConnectWithoutDeviceInput | TelemetryCreateOrConnectWithoutDeviceInput[]
    createMany?: TelemetryCreateManyDeviceInputEnvelope
    connect?: TelemetryWhereUniqueInput | TelemetryWhereUniqueInput[]
  }

  export type CommandCreateNestedManyWithoutDeviceInput = {
    create?: XOR<CommandCreateWithoutDeviceInput, CommandUncheckedCreateWithoutDeviceInput> | CommandCreateWithoutDeviceInput[] | CommandUncheckedCreateWithoutDeviceInput[]
    connectOrCreate?: CommandCreateOrConnectWithoutDeviceInput | CommandCreateOrConnectWithoutDeviceInput[]
    createMany?: CommandCreateManyDeviceInputEnvelope
    connect?: CommandWhereUniqueInput | CommandWhereUniqueInput[]
  }

  export type AlertEventCreateNestedManyWithoutDeviceInput = {
    create?: XOR<AlertEventCreateWithoutDeviceInput, AlertEventUncheckedCreateWithoutDeviceInput> | AlertEventCreateWithoutDeviceInput[] | AlertEventUncheckedCreateWithoutDeviceInput[]
    connectOrCreate?: AlertEventCreateOrConnectWithoutDeviceInput | AlertEventCreateOrConnectWithoutDeviceInput[]
    createMany?: AlertEventCreateManyDeviceInputEnvelope
    connect?: AlertEventWhereUniqueInput | AlertEventWhereUniqueInput[]
  }

  export type DailyRollupCreateNestedManyWithoutDeviceInput = {
    create?: XOR<DailyRollupCreateWithoutDeviceInput, DailyRollupUncheckedCreateWithoutDeviceInput> | DailyRollupCreateWithoutDeviceInput[] | DailyRollupUncheckedCreateWithoutDeviceInput[]
    connectOrCreate?: DailyRollupCreateOrConnectWithoutDeviceInput | DailyRollupCreateOrConnectWithoutDeviceInput[]
    createMany?: DailyRollupCreateManyDeviceInputEnvelope
    connect?: DailyRollupWhereUniqueInput | DailyRollupWhereUniqueInput[]
  }

  export type EntitlementCreateNestedManyWithoutDeviceInput = {
    create?: XOR<EntitlementCreateWithoutDeviceInput, EntitlementUncheckedCreateWithoutDeviceInput> | EntitlementCreateWithoutDeviceInput[] | EntitlementUncheckedCreateWithoutDeviceInput[]
    connectOrCreate?: EntitlementCreateOrConnectWithoutDeviceInput | EntitlementCreateOrConnectWithoutDeviceInput[]
    createMany?: EntitlementCreateManyDeviceInputEnvelope
    connect?: EntitlementWhereUniqueInput | EntitlementWhereUniqueInput[]
  }

  export type DeviceSecretUncheckedCreateNestedOneWithoutDeviceInput = {
    create?: XOR<DeviceSecretCreateWithoutDeviceInput, DeviceSecretUncheckedCreateWithoutDeviceInput>
    connectOrCreate?: DeviceSecretCreateOrConnectWithoutDeviceInput
    connect?: DeviceSecretWhereUniqueInput
  }

  export type DeviceTwinUncheckedCreateNestedOneWithoutDeviceInput = {
    create?: XOR<DeviceTwinCreateWithoutDeviceInput, DeviceTwinUncheckedCreateWithoutDeviceInput>
    connectOrCreate?: DeviceTwinCreateOrConnectWithoutDeviceInput
    connect?: DeviceTwinWhereUniqueInput
  }

  export type TelemetryUncheckedCreateNestedManyWithoutDeviceInput = {
    create?: XOR<TelemetryCreateWithoutDeviceInput, TelemetryUncheckedCreateWithoutDeviceInput> | TelemetryCreateWithoutDeviceInput[] | TelemetryUncheckedCreateWithoutDeviceInput[]
    connectOrCreate?: TelemetryCreateOrConnectWithoutDeviceInput | TelemetryCreateOrConnectWithoutDeviceInput[]
    createMany?: TelemetryCreateManyDeviceInputEnvelope
    connect?: TelemetryWhereUniqueInput | TelemetryWhereUniqueInput[]
  }

  export type CommandUncheckedCreateNestedManyWithoutDeviceInput = {
    create?: XOR<CommandCreateWithoutDeviceInput, CommandUncheckedCreateWithoutDeviceInput> | CommandCreateWithoutDeviceInput[] | CommandUncheckedCreateWithoutDeviceInput[]
    connectOrCreate?: CommandCreateOrConnectWithoutDeviceInput | CommandCreateOrConnectWithoutDeviceInput[]
    createMany?: CommandCreateManyDeviceInputEnvelope
    connect?: CommandWhereUniqueInput | CommandWhereUniqueInput[]
  }

  export type AlertEventUncheckedCreateNestedManyWithoutDeviceInput = {
    create?: XOR<AlertEventCreateWithoutDeviceInput, AlertEventUncheckedCreateWithoutDeviceInput> | AlertEventCreateWithoutDeviceInput[] | AlertEventUncheckedCreateWithoutDeviceInput[]
    connectOrCreate?: AlertEventCreateOrConnectWithoutDeviceInput | AlertEventCreateOrConnectWithoutDeviceInput[]
    createMany?: AlertEventCreateManyDeviceInputEnvelope
    connect?: AlertEventWhereUniqueInput | AlertEventWhereUniqueInput[]
  }

  export type DailyRollupUncheckedCreateNestedManyWithoutDeviceInput = {
    create?: XOR<DailyRollupCreateWithoutDeviceInput, DailyRollupUncheckedCreateWithoutDeviceInput> | DailyRollupCreateWithoutDeviceInput[] | DailyRollupUncheckedCreateWithoutDeviceInput[]
    connectOrCreate?: DailyRollupCreateOrConnectWithoutDeviceInput | DailyRollupCreateOrConnectWithoutDeviceInput[]
    createMany?: DailyRollupCreateManyDeviceInputEnvelope
    connect?: DailyRollupWhereUniqueInput | DailyRollupWhereUniqueInput[]
  }

  export type EntitlementUncheckedCreateNestedManyWithoutDeviceInput = {
    create?: XOR<EntitlementCreateWithoutDeviceInput, EntitlementUncheckedCreateWithoutDeviceInput> | EntitlementCreateWithoutDeviceInput[] | EntitlementUncheckedCreateWithoutDeviceInput[]
    connectOrCreate?: EntitlementCreateOrConnectWithoutDeviceInput | EntitlementCreateOrConnectWithoutDeviceInput[]
    createMany?: EntitlementCreateManyDeviceInputEnvelope
    connect?: EntitlementWhereUniqueInput | EntitlementWhereUniqueInput[]
  }

  export type EnumDeviceStatusFieldUpdateOperationsInput = {
    set?: $Enums.DeviceStatus
  }

  export type NullableEnumDeviceLocationSourceFieldUpdateOperationsInput = {
    set?: $Enums.DeviceLocationSource | null
  }

  export type TenantUpdateOneRequiredWithoutDevicesNestedInput = {
    create?: XOR<TenantCreateWithoutDevicesInput, TenantUncheckedCreateWithoutDevicesInput>
    connectOrCreate?: TenantCreateOrConnectWithoutDevicesInput
    upsert?: TenantUpsertWithoutDevicesInput
    connect?: TenantWhereUniqueInput
    update?: XOR<XOR<TenantUpdateToOneWithWhereWithoutDevicesInput, TenantUpdateWithoutDevicesInput>, TenantUncheckedUpdateWithoutDevicesInput>
  }

  export type SiteUpdateOneWithoutDevicesNestedInput = {
    create?: XOR<SiteCreateWithoutDevicesInput, SiteUncheckedCreateWithoutDevicesInput>
    connectOrCreate?: SiteCreateOrConnectWithoutDevicesInput
    upsert?: SiteUpsertWithoutDevicesInput
    disconnect?: SiteWhereInput | boolean
    delete?: SiteWhereInput | boolean
    connect?: SiteWhereUniqueInput
    update?: XOR<XOR<SiteUpdateToOneWithWhereWithoutDevicesInput, SiteUpdateWithoutDevicesInput>, SiteUncheckedUpdateWithoutDevicesInput>
  }

  export type SimInfoUpdateOneWithoutDevicesNestedInput = {
    create?: XOR<SimInfoCreateWithoutDevicesInput, SimInfoUncheckedCreateWithoutDevicesInput>
    connectOrCreate?: SimInfoCreateOrConnectWithoutDevicesInput
    upsert?: SimInfoUpsertWithoutDevicesInput
    disconnect?: SimInfoWhereInput | boolean
    delete?: SimInfoWhereInput | boolean
    connect?: SimInfoWhereUniqueInput
    update?: XOR<XOR<SimInfoUpdateToOneWithWhereWithoutDevicesInput, SimInfoUpdateWithoutDevicesInput>, SimInfoUncheckedUpdateWithoutDevicesInput>
  }

  export type DeviceSecretUpdateOneWithoutDeviceNestedInput = {
    create?: XOR<DeviceSecretCreateWithoutDeviceInput, DeviceSecretUncheckedCreateWithoutDeviceInput>
    connectOrCreate?: DeviceSecretCreateOrConnectWithoutDeviceInput
    upsert?: DeviceSecretUpsertWithoutDeviceInput
    disconnect?: DeviceSecretWhereInput | boolean
    delete?: DeviceSecretWhereInput | boolean
    connect?: DeviceSecretWhereUniqueInput
    update?: XOR<XOR<DeviceSecretUpdateToOneWithWhereWithoutDeviceInput, DeviceSecretUpdateWithoutDeviceInput>, DeviceSecretUncheckedUpdateWithoutDeviceInput>
  }

  export type DeviceTwinUpdateOneWithoutDeviceNestedInput = {
    create?: XOR<DeviceTwinCreateWithoutDeviceInput, DeviceTwinUncheckedCreateWithoutDeviceInput>
    connectOrCreate?: DeviceTwinCreateOrConnectWithoutDeviceInput
    upsert?: DeviceTwinUpsertWithoutDeviceInput
    disconnect?: DeviceTwinWhereInput | boolean
    delete?: DeviceTwinWhereInput | boolean
    connect?: DeviceTwinWhereUniqueInput
    update?: XOR<XOR<DeviceTwinUpdateToOneWithWhereWithoutDeviceInput, DeviceTwinUpdateWithoutDeviceInput>, DeviceTwinUncheckedUpdateWithoutDeviceInput>
  }

  export type TelemetryUpdateManyWithoutDeviceNestedInput = {
    create?: XOR<TelemetryCreateWithoutDeviceInput, TelemetryUncheckedCreateWithoutDeviceInput> | TelemetryCreateWithoutDeviceInput[] | TelemetryUncheckedCreateWithoutDeviceInput[]
    connectOrCreate?: TelemetryCreateOrConnectWithoutDeviceInput | TelemetryCreateOrConnectWithoutDeviceInput[]
    upsert?: TelemetryUpsertWithWhereUniqueWithoutDeviceInput | TelemetryUpsertWithWhereUniqueWithoutDeviceInput[]
    createMany?: TelemetryCreateManyDeviceInputEnvelope
    set?: TelemetryWhereUniqueInput | TelemetryWhereUniqueInput[]
    disconnect?: TelemetryWhereUniqueInput | TelemetryWhereUniqueInput[]
    delete?: TelemetryWhereUniqueInput | TelemetryWhereUniqueInput[]
    connect?: TelemetryWhereUniqueInput | TelemetryWhereUniqueInput[]
    update?: TelemetryUpdateWithWhereUniqueWithoutDeviceInput | TelemetryUpdateWithWhereUniqueWithoutDeviceInput[]
    updateMany?: TelemetryUpdateManyWithWhereWithoutDeviceInput | TelemetryUpdateManyWithWhereWithoutDeviceInput[]
    deleteMany?: TelemetryScalarWhereInput | TelemetryScalarWhereInput[]
  }

  export type CommandUpdateManyWithoutDeviceNestedInput = {
    create?: XOR<CommandCreateWithoutDeviceInput, CommandUncheckedCreateWithoutDeviceInput> | CommandCreateWithoutDeviceInput[] | CommandUncheckedCreateWithoutDeviceInput[]
    connectOrCreate?: CommandCreateOrConnectWithoutDeviceInput | CommandCreateOrConnectWithoutDeviceInput[]
    upsert?: CommandUpsertWithWhereUniqueWithoutDeviceInput | CommandUpsertWithWhereUniqueWithoutDeviceInput[]
    createMany?: CommandCreateManyDeviceInputEnvelope
    set?: CommandWhereUniqueInput | CommandWhereUniqueInput[]
    disconnect?: CommandWhereUniqueInput | CommandWhereUniqueInput[]
    delete?: CommandWhereUniqueInput | CommandWhereUniqueInput[]
    connect?: CommandWhereUniqueInput | CommandWhereUniqueInput[]
    update?: CommandUpdateWithWhereUniqueWithoutDeviceInput | CommandUpdateWithWhereUniqueWithoutDeviceInput[]
    updateMany?: CommandUpdateManyWithWhereWithoutDeviceInput | CommandUpdateManyWithWhereWithoutDeviceInput[]
    deleteMany?: CommandScalarWhereInput | CommandScalarWhereInput[]
  }

  export type AlertEventUpdateManyWithoutDeviceNestedInput = {
    create?: XOR<AlertEventCreateWithoutDeviceInput, AlertEventUncheckedCreateWithoutDeviceInput> | AlertEventCreateWithoutDeviceInput[] | AlertEventUncheckedCreateWithoutDeviceInput[]
    connectOrCreate?: AlertEventCreateOrConnectWithoutDeviceInput | AlertEventCreateOrConnectWithoutDeviceInput[]
    upsert?: AlertEventUpsertWithWhereUniqueWithoutDeviceInput | AlertEventUpsertWithWhereUniqueWithoutDeviceInput[]
    createMany?: AlertEventCreateManyDeviceInputEnvelope
    set?: AlertEventWhereUniqueInput | AlertEventWhereUniqueInput[]
    disconnect?: AlertEventWhereUniqueInput | AlertEventWhereUniqueInput[]
    delete?: AlertEventWhereUniqueInput | AlertEventWhereUniqueInput[]
    connect?: AlertEventWhereUniqueInput | AlertEventWhereUniqueInput[]
    update?: AlertEventUpdateWithWhereUniqueWithoutDeviceInput | AlertEventUpdateWithWhereUniqueWithoutDeviceInput[]
    updateMany?: AlertEventUpdateManyWithWhereWithoutDeviceInput | AlertEventUpdateManyWithWhereWithoutDeviceInput[]
    deleteMany?: AlertEventScalarWhereInput | AlertEventScalarWhereInput[]
  }

  export type DailyRollupUpdateManyWithoutDeviceNestedInput = {
    create?: XOR<DailyRollupCreateWithoutDeviceInput, DailyRollupUncheckedCreateWithoutDeviceInput> | DailyRollupCreateWithoutDeviceInput[] | DailyRollupUncheckedCreateWithoutDeviceInput[]
    connectOrCreate?: DailyRollupCreateOrConnectWithoutDeviceInput | DailyRollupCreateOrConnectWithoutDeviceInput[]
    upsert?: DailyRollupUpsertWithWhereUniqueWithoutDeviceInput | DailyRollupUpsertWithWhereUniqueWithoutDeviceInput[]
    createMany?: DailyRollupCreateManyDeviceInputEnvelope
    set?: DailyRollupWhereUniqueInput | DailyRollupWhereUniqueInput[]
    disconnect?: DailyRollupWhereUniqueInput | DailyRollupWhereUniqueInput[]
    delete?: DailyRollupWhereUniqueInput | DailyRollupWhereUniqueInput[]
    connect?: DailyRollupWhereUniqueInput | DailyRollupWhereUniqueInput[]
    update?: DailyRollupUpdateWithWhereUniqueWithoutDeviceInput | DailyRollupUpdateWithWhereUniqueWithoutDeviceInput[]
    updateMany?: DailyRollupUpdateManyWithWhereWithoutDeviceInput | DailyRollupUpdateManyWithWhereWithoutDeviceInput[]
    deleteMany?: DailyRollupScalarWhereInput | DailyRollupScalarWhereInput[]
  }

  export type EntitlementUpdateManyWithoutDeviceNestedInput = {
    create?: XOR<EntitlementCreateWithoutDeviceInput, EntitlementUncheckedCreateWithoutDeviceInput> | EntitlementCreateWithoutDeviceInput[] | EntitlementUncheckedCreateWithoutDeviceInput[]
    connectOrCreate?: EntitlementCreateOrConnectWithoutDeviceInput | EntitlementCreateOrConnectWithoutDeviceInput[]
    upsert?: EntitlementUpsertWithWhereUniqueWithoutDeviceInput | EntitlementUpsertWithWhereUniqueWithoutDeviceInput[]
    createMany?: EntitlementCreateManyDeviceInputEnvelope
    set?: EntitlementWhereUniqueInput | EntitlementWhereUniqueInput[]
    disconnect?: EntitlementWhereUniqueInput | EntitlementWhereUniqueInput[]
    delete?: EntitlementWhereUniqueInput | EntitlementWhereUniqueInput[]
    connect?: EntitlementWhereUniqueInput | EntitlementWhereUniqueInput[]
    update?: EntitlementUpdateWithWhereUniqueWithoutDeviceInput | EntitlementUpdateWithWhereUniqueWithoutDeviceInput[]
    updateMany?: EntitlementUpdateManyWithWhereWithoutDeviceInput | EntitlementUpdateManyWithWhereWithoutDeviceInput[]
    deleteMany?: EntitlementScalarWhereInput | EntitlementScalarWhereInput[]
  }

  export type DeviceSecretUncheckedUpdateOneWithoutDeviceNestedInput = {
    create?: XOR<DeviceSecretCreateWithoutDeviceInput, DeviceSecretUncheckedCreateWithoutDeviceInput>
    connectOrCreate?: DeviceSecretCreateOrConnectWithoutDeviceInput
    upsert?: DeviceSecretUpsertWithoutDeviceInput
    disconnect?: DeviceSecretWhereInput | boolean
    delete?: DeviceSecretWhereInput | boolean
    connect?: DeviceSecretWhereUniqueInput
    update?: XOR<XOR<DeviceSecretUpdateToOneWithWhereWithoutDeviceInput, DeviceSecretUpdateWithoutDeviceInput>, DeviceSecretUncheckedUpdateWithoutDeviceInput>
  }

  export type DeviceTwinUncheckedUpdateOneWithoutDeviceNestedInput = {
    create?: XOR<DeviceTwinCreateWithoutDeviceInput, DeviceTwinUncheckedCreateWithoutDeviceInput>
    connectOrCreate?: DeviceTwinCreateOrConnectWithoutDeviceInput
    upsert?: DeviceTwinUpsertWithoutDeviceInput
    disconnect?: DeviceTwinWhereInput | boolean
    delete?: DeviceTwinWhereInput | boolean
    connect?: DeviceTwinWhereUniqueInput
    update?: XOR<XOR<DeviceTwinUpdateToOneWithWhereWithoutDeviceInput, DeviceTwinUpdateWithoutDeviceInput>, DeviceTwinUncheckedUpdateWithoutDeviceInput>
  }

  export type TelemetryUncheckedUpdateManyWithoutDeviceNestedInput = {
    create?: XOR<TelemetryCreateWithoutDeviceInput, TelemetryUncheckedCreateWithoutDeviceInput> | TelemetryCreateWithoutDeviceInput[] | TelemetryUncheckedCreateWithoutDeviceInput[]
    connectOrCreate?: TelemetryCreateOrConnectWithoutDeviceInput | TelemetryCreateOrConnectWithoutDeviceInput[]
    upsert?: TelemetryUpsertWithWhereUniqueWithoutDeviceInput | TelemetryUpsertWithWhereUniqueWithoutDeviceInput[]
    createMany?: TelemetryCreateManyDeviceInputEnvelope
    set?: TelemetryWhereUniqueInput | TelemetryWhereUniqueInput[]
    disconnect?: TelemetryWhereUniqueInput | TelemetryWhereUniqueInput[]
    delete?: TelemetryWhereUniqueInput | TelemetryWhereUniqueInput[]
    connect?: TelemetryWhereUniqueInput | TelemetryWhereUniqueInput[]
    update?: TelemetryUpdateWithWhereUniqueWithoutDeviceInput | TelemetryUpdateWithWhereUniqueWithoutDeviceInput[]
    updateMany?: TelemetryUpdateManyWithWhereWithoutDeviceInput | TelemetryUpdateManyWithWhereWithoutDeviceInput[]
    deleteMany?: TelemetryScalarWhereInput | TelemetryScalarWhereInput[]
  }

  export type CommandUncheckedUpdateManyWithoutDeviceNestedInput = {
    create?: XOR<CommandCreateWithoutDeviceInput, CommandUncheckedCreateWithoutDeviceInput> | CommandCreateWithoutDeviceInput[] | CommandUncheckedCreateWithoutDeviceInput[]
    connectOrCreate?: CommandCreateOrConnectWithoutDeviceInput | CommandCreateOrConnectWithoutDeviceInput[]
    upsert?: CommandUpsertWithWhereUniqueWithoutDeviceInput | CommandUpsertWithWhereUniqueWithoutDeviceInput[]
    createMany?: CommandCreateManyDeviceInputEnvelope
    set?: CommandWhereUniqueInput | CommandWhereUniqueInput[]
    disconnect?: CommandWhereUniqueInput | CommandWhereUniqueInput[]
    delete?: CommandWhereUniqueInput | CommandWhereUniqueInput[]
    connect?: CommandWhereUniqueInput | CommandWhereUniqueInput[]
    update?: CommandUpdateWithWhereUniqueWithoutDeviceInput | CommandUpdateWithWhereUniqueWithoutDeviceInput[]
    updateMany?: CommandUpdateManyWithWhereWithoutDeviceInput | CommandUpdateManyWithWhereWithoutDeviceInput[]
    deleteMany?: CommandScalarWhereInput | CommandScalarWhereInput[]
  }

  export type AlertEventUncheckedUpdateManyWithoutDeviceNestedInput = {
    create?: XOR<AlertEventCreateWithoutDeviceInput, AlertEventUncheckedCreateWithoutDeviceInput> | AlertEventCreateWithoutDeviceInput[] | AlertEventUncheckedCreateWithoutDeviceInput[]
    connectOrCreate?: AlertEventCreateOrConnectWithoutDeviceInput | AlertEventCreateOrConnectWithoutDeviceInput[]
    upsert?: AlertEventUpsertWithWhereUniqueWithoutDeviceInput | AlertEventUpsertWithWhereUniqueWithoutDeviceInput[]
    createMany?: AlertEventCreateManyDeviceInputEnvelope
    set?: AlertEventWhereUniqueInput | AlertEventWhereUniqueInput[]
    disconnect?: AlertEventWhereUniqueInput | AlertEventWhereUniqueInput[]
    delete?: AlertEventWhereUniqueInput | AlertEventWhereUniqueInput[]
    connect?: AlertEventWhereUniqueInput | AlertEventWhereUniqueInput[]
    update?: AlertEventUpdateWithWhereUniqueWithoutDeviceInput | AlertEventUpdateWithWhereUniqueWithoutDeviceInput[]
    updateMany?: AlertEventUpdateManyWithWhereWithoutDeviceInput | AlertEventUpdateManyWithWhereWithoutDeviceInput[]
    deleteMany?: AlertEventScalarWhereInput | AlertEventScalarWhereInput[]
  }

  export type DailyRollupUncheckedUpdateManyWithoutDeviceNestedInput = {
    create?: XOR<DailyRollupCreateWithoutDeviceInput, DailyRollupUncheckedCreateWithoutDeviceInput> | DailyRollupCreateWithoutDeviceInput[] | DailyRollupUncheckedCreateWithoutDeviceInput[]
    connectOrCreate?: DailyRollupCreateOrConnectWithoutDeviceInput | DailyRollupCreateOrConnectWithoutDeviceInput[]
    upsert?: DailyRollupUpsertWithWhereUniqueWithoutDeviceInput | DailyRollupUpsertWithWhereUniqueWithoutDeviceInput[]
    createMany?: DailyRollupCreateManyDeviceInputEnvelope
    set?: DailyRollupWhereUniqueInput | DailyRollupWhereUniqueInput[]
    disconnect?: DailyRollupWhereUniqueInput | DailyRollupWhereUniqueInput[]
    delete?: DailyRollupWhereUniqueInput | DailyRollupWhereUniqueInput[]
    connect?: DailyRollupWhereUniqueInput | DailyRollupWhereUniqueInput[]
    update?: DailyRollupUpdateWithWhereUniqueWithoutDeviceInput | DailyRollupUpdateWithWhereUniqueWithoutDeviceInput[]
    updateMany?: DailyRollupUpdateManyWithWhereWithoutDeviceInput | DailyRollupUpdateManyWithWhereWithoutDeviceInput[]
    deleteMany?: DailyRollupScalarWhereInput | DailyRollupScalarWhereInput[]
  }

  export type EntitlementUncheckedUpdateManyWithoutDeviceNestedInput = {
    create?: XOR<EntitlementCreateWithoutDeviceInput, EntitlementUncheckedCreateWithoutDeviceInput> | EntitlementCreateWithoutDeviceInput[] | EntitlementUncheckedCreateWithoutDeviceInput[]
    connectOrCreate?: EntitlementCreateOrConnectWithoutDeviceInput | EntitlementCreateOrConnectWithoutDeviceInput[]
    upsert?: EntitlementUpsertWithWhereUniqueWithoutDeviceInput | EntitlementUpsertWithWhereUniqueWithoutDeviceInput[]
    createMany?: EntitlementCreateManyDeviceInputEnvelope
    set?: EntitlementWhereUniqueInput | EntitlementWhereUniqueInput[]
    disconnect?: EntitlementWhereUniqueInput | EntitlementWhereUniqueInput[]
    delete?: EntitlementWhereUniqueInput | EntitlementWhereUniqueInput[]
    connect?: EntitlementWhereUniqueInput | EntitlementWhereUniqueInput[]
    update?: EntitlementUpdateWithWhereUniqueWithoutDeviceInput | EntitlementUpdateWithWhereUniqueWithoutDeviceInput[]
    updateMany?: EntitlementUpdateManyWithWhereWithoutDeviceInput | EntitlementUpdateManyWithWhereWithoutDeviceInput[]
    deleteMany?: EntitlementScalarWhereInput | EntitlementScalarWhereInput[]
  }

  export type DeviceCreateNestedOneWithoutSecretInput = {
    create?: XOR<DeviceCreateWithoutSecretInput, DeviceUncheckedCreateWithoutSecretInput>
    connectOrCreate?: DeviceCreateOrConnectWithoutSecretInput
    connect?: DeviceWhereUniqueInput
  }

  export type DeviceUpdateOneRequiredWithoutSecretNestedInput = {
    create?: XOR<DeviceCreateWithoutSecretInput, DeviceUncheckedCreateWithoutSecretInput>
    connectOrCreate?: DeviceCreateOrConnectWithoutSecretInput
    upsert?: DeviceUpsertWithoutSecretInput
    connect?: DeviceWhereUniqueInput
    update?: XOR<XOR<DeviceUpdateToOneWithWhereWithoutSecretInput, DeviceUpdateWithoutSecretInput>, DeviceUncheckedUpdateWithoutSecretInput>
  }

  export type DeviceCreateNestedOneWithoutTelemetryInput = {
    create?: XOR<DeviceCreateWithoutTelemetryInput, DeviceUncheckedCreateWithoutTelemetryInput>
    connectOrCreate?: DeviceCreateOrConnectWithoutTelemetryInput
    connect?: DeviceWhereUniqueInput
  }

  export type DeviceUpdateOneRequiredWithoutTelemetryNestedInput = {
    create?: XOR<DeviceCreateWithoutTelemetryInput, DeviceUncheckedCreateWithoutTelemetryInput>
    connectOrCreate?: DeviceCreateOrConnectWithoutTelemetryInput
    upsert?: DeviceUpsertWithoutTelemetryInput
    connect?: DeviceWhereUniqueInput
    update?: XOR<XOR<DeviceUpdateToOneWithWhereWithoutTelemetryInput, DeviceUpdateWithoutTelemetryInput>, DeviceUncheckedUpdateWithoutTelemetryInput>
  }

  export type DeviceCreateNestedOneWithoutTwinInput = {
    create?: XOR<DeviceCreateWithoutTwinInput, DeviceUncheckedCreateWithoutTwinInput>
    connectOrCreate?: DeviceCreateOrConnectWithoutTwinInput
    connect?: DeviceWhereUniqueInput
  }

  export type DeviceUpdateOneRequiredWithoutTwinNestedInput = {
    create?: XOR<DeviceCreateWithoutTwinInput, DeviceUncheckedCreateWithoutTwinInput>
    connectOrCreate?: DeviceCreateOrConnectWithoutTwinInput
    upsert?: DeviceUpsertWithoutTwinInput
    connect?: DeviceWhereUniqueInput
    update?: XOR<XOR<DeviceUpdateToOneWithWhereWithoutTwinInput, DeviceUpdateWithoutTwinInput>, DeviceUncheckedUpdateWithoutTwinInput>
  }

  export type DeviceCreateNestedOneWithoutCommandsInput = {
    create?: XOR<DeviceCreateWithoutCommandsInput, DeviceUncheckedCreateWithoutCommandsInput>
    connectOrCreate?: DeviceCreateOrConnectWithoutCommandsInput
    connect?: DeviceWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutCommandsInput = {
    create?: XOR<UserCreateWithoutCommandsInput, UserUncheckedCreateWithoutCommandsInput>
    connectOrCreate?: UserCreateOrConnectWithoutCommandsInput
    connect?: UserWhereUniqueInput
  }

  export type EnumCommandTypeFieldUpdateOperationsInput = {
    set?: $Enums.CommandType
  }

  export type EnumCommandStatusFieldUpdateOperationsInput = {
    set?: $Enums.CommandStatus
  }

  export type DeviceUpdateOneRequiredWithoutCommandsNestedInput = {
    create?: XOR<DeviceCreateWithoutCommandsInput, DeviceUncheckedCreateWithoutCommandsInput>
    connectOrCreate?: DeviceCreateOrConnectWithoutCommandsInput
    upsert?: DeviceUpsertWithoutCommandsInput
    connect?: DeviceWhereUniqueInput
    update?: XOR<XOR<DeviceUpdateToOneWithWhereWithoutCommandsInput, DeviceUpdateWithoutCommandsInput>, DeviceUncheckedUpdateWithoutCommandsInput>
  }

  export type UserUpdateOneWithoutCommandsNestedInput = {
    create?: XOR<UserCreateWithoutCommandsInput, UserUncheckedCreateWithoutCommandsInput>
    connectOrCreate?: UserCreateOrConnectWithoutCommandsInput
    upsert?: UserUpsertWithoutCommandsInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutCommandsInput, UserUpdateWithoutCommandsInput>, UserUncheckedUpdateWithoutCommandsInput>
  }

  export type OtaJobCreateNestedManyWithoutFirmwarePackageInput = {
    create?: XOR<OtaJobCreateWithoutFirmwarePackageInput, OtaJobUncheckedCreateWithoutFirmwarePackageInput> | OtaJobCreateWithoutFirmwarePackageInput[] | OtaJobUncheckedCreateWithoutFirmwarePackageInput[]
    connectOrCreate?: OtaJobCreateOrConnectWithoutFirmwarePackageInput | OtaJobCreateOrConnectWithoutFirmwarePackageInput[]
    createMany?: OtaJobCreateManyFirmwarePackageInputEnvelope
    connect?: OtaJobWhereUniqueInput | OtaJobWhereUniqueInput[]
  }

  export type OtaJobUncheckedCreateNestedManyWithoutFirmwarePackageInput = {
    create?: XOR<OtaJobCreateWithoutFirmwarePackageInput, OtaJobUncheckedCreateWithoutFirmwarePackageInput> | OtaJobCreateWithoutFirmwarePackageInput[] | OtaJobUncheckedCreateWithoutFirmwarePackageInput[]
    connectOrCreate?: OtaJobCreateOrConnectWithoutFirmwarePackageInput | OtaJobCreateOrConnectWithoutFirmwarePackageInput[]
    createMany?: OtaJobCreateManyFirmwarePackageInputEnvelope
    connect?: OtaJobWhereUniqueInput | OtaJobWhereUniqueInput[]
  }

  export type OtaJobUpdateManyWithoutFirmwarePackageNestedInput = {
    create?: XOR<OtaJobCreateWithoutFirmwarePackageInput, OtaJobUncheckedCreateWithoutFirmwarePackageInput> | OtaJobCreateWithoutFirmwarePackageInput[] | OtaJobUncheckedCreateWithoutFirmwarePackageInput[]
    connectOrCreate?: OtaJobCreateOrConnectWithoutFirmwarePackageInput | OtaJobCreateOrConnectWithoutFirmwarePackageInput[]
    upsert?: OtaJobUpsertWithWhereUniqueWithoutFirmwarePackageInput | OtaJobUpsertWithWhereUniqueWithoutFirmwarePackageInput[]
    createMany?: OtaJobCreateManyFirmwarePackageInputEnvelope
    set?: OtaJobWhereUniqueInput | OtaJobWhereUniqueInput[]
    disconnect?: OtaJobWhereUniqueInput | OtaJobWhereUniqueInput[]
    delete?: OtaJobWhereUniqueInput | OtaJobWhereUniqueInput[]
    connect?: OtaJobWhereUniqueInput | OtaJobWhereUniqueInput[]
    update?: OtaJobUpdateWithWhereUniqueWithoutFirmwarePackageInput | OtaJobUpdateWithWhereUniqueWithoutFirmwarePackageInput[]
    updateMany?: OtaJobUpdateManyWithWhereWithoutFirmwarePackageInput | OtaJobUpdateManyWithWhereWithoutFirmwarePackageInput[]
    deleteMany?: OtaJobScalarWhereInput | OtaJobScalarWhereInput[]
  }

  export type OtaJobUncheckedUpdateManyWithoutFirmwarePackageNestedInput = {
    create?: XOR<OtaJobCreateWithoutFirmwarePackageInput, OtaJobUncheckedCreateWithoutFirmwarePackageInput> | OtaJobCreateWithoutFirmwarePackageInput[] | OtaJobUncheckedCreateWithoutFirmwarePackageInput[]
    connectOrCreate?: OtaJobCreateOrConnectWithoutFirmwarePackageInput | OtaJobCreateOrConnectWithoutFirmwarePackageInput[]
    upsert?: OtaJobUpsertWithWhereUniqueWithoutFirmwarePackageInput | OtaJobUpsertWithWhereUniqueWithoutFirmwarePackageInput[]
    createMany?: OtaJobCreateManyFirmwarePackageInputEnvelope
    set?: OtaJobWhereUniqueInput | OtaJobWhereUniqueInput[]
    disconnect?: OtaJobWhereUniqueInput | OtaJobWhereUniqueInput[]
    delete?: OtaJobWhereUniqueInput | OtaJobWhereUniqueInput[]
    connect?: OtaJobWhereUniqueInput | OtaJobWhereUniqueInput[]
    update?: OtaJobUpdateWithWhereUniqueWithoutFirmwarePackageInput | OtaJobUpdateWithWhereUniqueWithoutFirmwarePackageInput[]
    updateMany?: OtaJobUpdateManyWithWhereWithoutFirmwarePackageInput | OtaJobUpdateManyWithWhereWithoutFirmwarePackageInput[]
    deleteMany?: OtaJobScalarWhereInput | OtaJobScalarWhereInput[]
  }

  export type TenantCreateNestedOneWithoutOtaJobsInput = {
    create?: XOR<TenantCreateWithoutOtaJobsInput, TenantUncheckedCreateWithoutOtaJobsInput>
    connectOrCreate?: TenantCreateOrConnectWithoutOtaJobsInput
    connect?: TenantWhereUniqueInput
  }

  export type FirmwarePackageCreateNestedOneWithoutOtaJobsInput = {
    create?: XOR<FirmwarePackageCreateWithoutOtaJobsInput, FirmwarePackageUncheckedCreateWithoutOtaJobsInput>
    connectOrCreate?: FirmwarePackageCreateOrConnectWithoutOtaJobsInput
    connect?: FirmwarePackageWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutOtaJobsInput = {
    create?: XOR<UserCreateWithoutOtaJobsInput, UserUncheckedCreateWithoutOtaJobsInput>
    connectOrCreate?: UserCreateOrConnectWithoutOtaJobsInput
    connect?: UserWhereUniqueInput
  }

  export type EnumOtaTargetTypeFieldUpdateOperationsInput = {
    set?: $Enums.OtaTargetType
  }

  export type EnumOtaJobStatusFieldUpdateOperationsInput = {
    set?: $Enums.OtaJobStatus
  }

  export type TenantUpdateOneRequiredWithoutOtaJobsNestedInput = {
    create?: XOR<TenantCreateWithoutOtaJobsInput, TenantUncheckedCreateWithoutOtaJobsInput>
    connectOrCreate?: TenantCreateOrConnectWithoutOtaJobsInput
    upsert?: TenantUpsertWithoutOtaJobsInput
    connect?: TenantWhereUniqueInput
    update?: XOR<XOR<TenantUpdateToOneWithWhereWithoutOtaJobsInput, TenantUpdateWithoutOtaJobsInput>, TenantUncheckedUpdateWithoutOtaJobsInput>
  }

  export type FirmwarePackageUpdateOneRequiredWithoutOtaJobsNestedInput = {
    create?: XOR<FirmwarePackageCreateWithoutOtaJobsInput, FirmwarePackageUncheckedCreateWithoutOtaJobsInput>
    connectOrCreate?: FirmwarePackageCreateOrConnectWithoutOtaJobsInput
    upsert?: FirmwarePackageUpsertWithoutOtaJobsInput
    connect?: FirmwarePackageWhereUniqueInput
    update?: XOR<XOR<FirmwarePackageUpdateToOneWithWhereWithoutOtaJobsInput, FirmwarePackageUpdateWithoutOtaJobsInput>, FirmwarePackageUncheckedUpdateWithoutOtaJobsInput>
  }

  export type UserUpdateOneWithoutOtaJobsNestedInput = {
    create?: XOR<UserCreateWithoutOtaJobsInput, UserUncheckedCreateWithoutOtaJobsInput>
    connectOrCreate?: UserCreateOrConnectWithoutOtaJobsInput
    upsert?: UserUpsertWithoutOtaJobsInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutOtaJobsInput, UserUpdateWithoutOtaJobsInput>, UserUncheckedUpdateWithoutOtaJobsInput>
  }

  export type DeviceCreateNestedManyWithoutSimInput = {
    create?: XOR<DeviceCreateWithoutSimInput, DeviceUncheckedCreateWithoutSimInput> | DeviceCreateWithoutSimInput[] | DeviceUncheckedCreateWithoutSimInput[]
    connectOrCreate?: DeviceCreateOrConnectWithoutSimInput | DeviceCreateOrConnectWithoutSimInput[]
    createMany?: DeviceCreateManySimInputEnvelope
    connect?: DeviceWhereUniqueInput | DeviceWhereUniqueInput[]
  }

  export type SimActionCreateNestedManyWithoutSimInput = {
    create?: XOR<SimActionCreateWithoutSimInput, SimActionUncheckedCreateWithoutSimInput> | SimActionCreateWithoutSimInput[] | SimActionUncheckedCreateWithoutSimInput[]
    connectOrCreate?: SimActionCreateOrConnectWithoutSimInput | SimActionCreateOrConnectWithoutSimInput[]
    createMany?: SimActionCreateManySimInputEnvelope
    connect?: SimActionWhereUniqueInput | SimActionWhereUniqueInput[]
  }

  export type DeviceUncheckedCreateNestedManyWithoutSimInput = {
    create?: XOR<DeviceCreateWithoutSimInput, DeviceUncheckedCreateWithoutSimInput> | DeviceCreateWithoutSimInput[] | DeviceUncheckedCreateWithoutSimInput[]
    connectOrCreate?: DeviceCreateOrConnectWithoutSimInput | DeviceCreateOrConnectWithoutSimInput[]
    createMany?: DeviceCreateManySimInputEnvelope
    connect?: DeviceWhereUniqueInput | DeviceWhereUniqueInput[]
  }

  export type SimActionUncheckedCreateNestedManyWithoutSimInput = {
    create?: XOR<SimActionCreateWithoutSimInput, SimActionUncheckedCreateWithoutSimInput> | SimActionCreateWithoutSimInput[] | SimActionUncheckedCreateWithoutSimInput[]
    connectOrCreate?: SimActionCreateOrConnectWithoutSimInput | SimActionCreateOrConnectWithoutSimInput[]
    createMany?: SimActionCreateManySimInputEnvelope
    connect?: SimActionWhereUniqueInput | SimActionWhereUniqueInput[]
  }

  export type EnumSimStatusFieldUpdateOperationsInput = {
    set?: $Enums.SimStatus
  }

  export type DeviceUpdateManyWithoutSimNestedInput = {
    create?: XOR<DeviceCreateWithoutSimInput, DeviceUncheckedCreateWithoutSimInput> | DeviceCreateWithoutSimInput[] | DeviceUncheckedCreateWithoutSimInput[]
    connectOrCreate?: DeviceCreateOrConnectWithoutSimInput | DeviceCreateOrConnectWithoutSimInput[]
    upsert?: DeviceUpsertWithWhereUniqueWithoutSimInput | DeviceUpsertWithWhereUniqueWithoutSimInput[]
    createMany?: DeviceCreateManySimInputEnvelope
    set?: DeviceWhereUniqueInput | DeviceWhereUniqueInput[]
    disconnect?: DeviceWhereUniqueInput | DeviceWhereUniqueInput[]
    delete?: DeviceWhereUniqueInput | DeviceWhereUniqueInput[]
    connect?: DeviceWhereUniqueInput | DeviceWhereUniqueInput[]
    update?: DeviceUpdateWithWhereUniqueWithoutSimInput | DeviceUpdateWithWhereUniqueWithoutSimInput[]
    updateMany?: DeviceUpdateManyWithWhereWithoutSimInput | DeviceUpdateManyWithWhereWithoutSimInput[]
    deleteMany?: DeviceScalarWhereInput | DeviceScalarWhereInput[]
  }

  export type SimActionUpdateManyWithoutSimNestedInput = {
    create?: XOR<SimActionCreateWithoutSimInput, SimActionUncheckedCreateWithoutSimInput> | SimActionCreateWithoutSimInput[] | SimActionUncheckedCreateWithoutSimInput[]
    connectOrCreate?: SimActionCreateOrConnectWithoutSimInput | SimActionCreateOrConnectWithoutSimInput[]
    upsert?: SimActionUpsertWithWhereUniqueWithoutSimInput | SimActionUpsertWithWhereUniqueWithoutSimInput[]
    createMany?: SimActionCreateManySimInputEnvelope
    set?: SimActionWhereUniqueInput | SimActionWhereUniqueInput[]
    disconnect?: SimActionWhereUniqueInput | SimActionWhereUniqueInput[]
    delete?: SimActionWhereUniqueInput | SimActionWhereUniqueInput[]
    connect?: SimActionWhereUniqueInput | SimActionWhereUniqueInput[]
    update?: SimActionUpdateWithWhereUniqueWithoutSimInput | SimActionUpdateWithWhereUniqueWithoutSimInput[]
    updateMany?: SimActionUpdateManyWithWhereWithoutSimInput | SimActionUpdateManyWithWhereWithoutSimInput[]
    deleteMany?: SimActionScalarWhereInput | SimActionScalarWhereInput[]
  }

  export type DeviceUncheckedUpdateManyWithoutSimNestedInput = {
    create?: XOR<DeviceCreateWithoutSimInput, DeviceUncheckedCreateWithoutSimInput> | DeviceCreateWithoutSimInput[] | DeviceUncheckedCreateWithoutSimInput[]
    connectOrCreate?: DeviceCreateOrConnectWithoutSimInput | DeviceCreateOrConnectWithoutSimInput[]
    upsert?: DeviceUpsertWithWhereUniqueWithoutSimInput | DeviceUpsertWithWhereUniqueWithoutSimInput[]
    createMany?: DeviceCreateManySimInputEnvelope
    set?: DeviceWhereUniqueInput | DeviceWhereUniqueInput[]
    disconnect?: DeviceWhereUniqueInput | DeviceWhereUniqueInput[]
    delete?: DeviceWhereUniqueInput | DeviceWhereUniqueInput[]
    connect?: DeviceWhereUniqueInput | DeviceWhereUniqueInput[]
    update?: DeviceUpdateWithWhereUniqueWithoutSimInput | DeviceUpdateWithWhereUniqueWithoutSimInput[]
    updateMany?: DeviceUpdateManyWithWhereWithoutSimInput | DeviceUpdateManyWithWhereWithoutSimInput[]
    deleteMany?: DeviceScalarWhereInput | DeviceScalarWhereInput[]
  }

  export type SimActionUncheckedUpdateManyWithoutSimNestedInput = {
    create?: XOR<SimActionCreateWithoutSimInput, SimActionUncheckedCreateWithoutSimInput> | SimActionCreateWithoutSimInput[] | SimActionUncheckedCreateWithoutSimInput[]
    connectOrCreate?: SimActionCreateOrConnectWithoutSimInput | SimActionCreateOrConnectWithoutSimInput[]
    upsert?: SimActionUpsertWithWhereUniqueWithoutSimInput | SimActionUpsertWithWhereUniqueWithoutSimInput[]
    createMany?: SimActionCreateManySimInputEnvelope
    set?: SimActionWhereUniqueInput | SimActionWhereUniqueInput[]
    disconnect?: SimActionWhereUniqueInput | SimActionWhereUniqueInput[]
    delete?: SimActionWhereUniqueInput | SimActionWhereUniqueInput[]
    connect?: SimActionWhereUniqueInput | SimActionWhereUniqueInput[]
    update?: SimActionUpdateWithWhereUniqueWithoutSimInput | SimActionUpdateWithWhereUniqueWithoutSimInput[]
    updateMany?: SimActionUpdateManyWithWhereWithoutSimInput | SimActionUpdateManyWithWhereWithoutSimInput[]
    deleteMany?: SimActionScalarWhereInput | SimActionScalarWhereInput[]
  }

  export type SimInfoCreateNestedOneWithoutSimActionsInput = {
    create?: XOR<SimInfoCreateWithoutSimActionsInput, SimInfoUncheckedCreateWithoutSimActionsInput>
    connectOrCreate?: SimInfoCreateOrConnectWithoutSimActionsInput
    connect?: SimInfoWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutSimActionsInput = {
    create?: XOR<UserCreateWithoutSimActionsInput, UserUncheckedCreateWithoutSimActionsInput>
    connectOrCreate?: UserCreateOrConnectWithoutSimActionsInput
    connect?: UserWhereUniqueInput
  }

  export type EnumSimActionTypeFieldUpdateOperationsInput = {
    set?: $Enums.SimActionType
  }

  export type EnumSimActionStatusFieldUpdateOperationsInput = {
    set?: $Enums.SimActionStatus
  }

  export type SimInfoUpdateOneRequiredWithoutSimActionsNestedInput = {
    create?: XOR<SimInfoCreateWithoutSimActionsInput, SimInfoUncheckedCreateWithoutSimActionsInput>
    connectOrCreate?: SimInfoCreateOrConnectWithoutSimActionsInput
    upsert?: SimInfoUpsertWithoutSimActionsInput
    connect?: SimInfoWhereUniqueInput
    update?: XOR<XOR<SimInfoUpdateToOneWithWhereWithoutSimActionsInput, SimInfoUpdateWithoutSimActionsInput>, SimInfoUncheckedUpdateWithoutSimActionsInput>
  }

  export type UserUpdateOneWithoutSimActionsNestedInput = {
    create?: XOR<UserCreateWithoutSimActionsInput, UserUncheckedCreateWithoutSimActionsInput>
    connectOrCreate?: UserCreateOrConnectWithoutSimActionsInput
    upsert?: UserUpsertWithoutSimActionsInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutSimActionsInput, UserUpdateWithoutSimActionsInput>, UserUncheckedUpdateWithoutSimActionsInput>
  }

  export type TenantCreateNestedOneWithoutAlertRulesInput = {
    create?: XOR<TenantCreateWithoutAlertRulesInput, TenantUncheckedCreateWithoutAlertRulesInput>
    connectOrCreate?: TenantCreateOrConnectWithoutAlertRulesInput
    connect?: TenantWhereUniqueInput
  }

  export type AlertEventCreateNestedManyWithoutRuleInput = {
    create?: XOR<AlertEventCreateWithoutRuleInput, AlertEventUncheckedCreateWithoutRuleInput> | AlertEventCreateWithoutRuleInput[] | AlertEventUncheckedCreateWithoutRuleInput[]
    connectOrCreate?: AlertEventCreateOrConnectWithoutRuleInput | AlertEventCreateOrConnectWithoutRuleInput[]
    createMany?: AlertEventCreateManyRuleInputEnvelope
    connect?: AlertEventWhereUniqueInput | AlertEventWhereUniqueInput[]
  }

  export type AlertEventUncheckedCreateNestedManyWithoutRuleInput = {
    create?: XOR<AlertEventCreateWithoutRuleInput, AlertEventUncheckedCreateWithoutRuleInput> | AlertEventCreateWithoutRuleInput[] | AlertEventUncheckedCreateWithoutRuleInput[]
    connectOrCreate?: AlertEventCreateOrConnectWithoutRuleInput | AlertEventCreateOrConnectWithoutRuleInput[]
    createMany?: AlertEventCreateManyRuleInputEnvelope
    connect?: AlertEventWhereUniqueInput | AlertEventWhereUniqueInput[]
  }

  export type EnumAlertRuleTypeFieldUpdateOperationsInput = {
    set?: $Enums.AlertRuleType
  }

  export type EnumAlertSeverityFieldUpdateOperationsInput = {
    set?: $Enums.AlertSeverity
  }

  export type TenantUpdateOneRequiredWithoutAlertRulesNestedInput = {
    create?: XOR<TenantCreateWithoutAlertRulesInput, TenantUncheckedCreateWithoutAlertRulesInput>
    connectOrCreate?: TenantCreateOrConnectWithoutAlertRulesInput
    upsert?: TenantUpsertWithoutAlertRulesInput
    connect?: TenantWhereUniqueInput
    update?: XOR<XOR<TenantUpdateToOneWithWhereWithoutAlertRulesInput, TenantUpdateWithoutAlertRulesInput>, TenantUncheckedUpdateWithoutAlertRulesInput>
  }

  export type AlertEventUpdateManyWithoutRuleNestedInput = {
    create?: XOR<AlertEventCreateWithoutRuleInput, AlertEventUncheckedCreateWithoutRuleInput> | AlertEventCreateWithoutRuleInput[] | AlertEventUncheckedCreateWithoutRuleInput[]
    connectOrCreate?: AlertEventCreateOrConnectWithoutRuleInput | AlertEventCreateOrConnectWithoutRuleInput[]
    upsert?: AlertEventUpsertWithWhereUniqueWithoutRuleInput | AlertEventUpsertWithWhereUniqueWithoutRuleInput[]
    createMany?: AlertEventCreateManyRuleInputEnvelope
    set?: AlertEventWhereUniqueInput | AlertEventWhereUniqueInput[]
    disconnect?: AlertEventWhereUniqueInput | AlertEventWhereUniqueInput[]
    delete?: AlertEventWhereUniqueInput | AlertEventWhereUniqueInput[]
    connect?: AlertEventWhereUniqueInput | AlertEventWhereUniqueInput[]
    update?: AlertEventUpdateWithWhereUniqueWithoutRuleInput | AlertEventUpdateWithWhereUniqueWithoutRuleInput[]
    updateMany?: AlertEventUpdateManyWithWhereWithoutRuleInput | AlertEventUpdateManyWithWhereWithoutRuleInput[]
    deleteMany?: AlertEventScalarWhereInput | AlertEventScalarWhereInput[]
  }

  export type AlertEventUncheckedUpdateManyWithoutRuleNestedInput = {
    create?: XOR<AlertEventCreateWithoutRuleInput, AlertEventUncheckedCreateWithoutRuleInput> | AlertEventCreateWithoutRuleInput[] | AlertEventUncheckedCreateWithoutRuleInput[]
    connectOrCreate?: AlertEventCreateOrConnectWithoutRuleInput | AlertEventCreateOrConnectWithoutRuleInput[]
    upsert?: AlertEventUpsertWithWhereUniqueWithoutRuleInput | AlertEventUpsertWithWhereUniqueWithoutRuleInput[]
    createMany?: AlertEventCreateManyRuleInputEnvelope
    set?: AlertEventWhereUniqueInput | AlertEventWhereUniqueInput[]
    disconnect?: AlertEventWhereUniqueInput | AlertEventWhereUniqueInput[]
    delete?: AlertEventWhereUniqueInput | AlertEventWhereUniqueInput[]
    connect?: AlertEventWhereUniqueInput | AlertEventWhereUniqueInput[]
    update?: AlertEventUpdateWithWhereUniqueWithoutRuleInput | AlertEventUpdateWithWhereUniqueWithoutRuleInput[]
    updateMany?: AlertEventUpdateManyWithWhereWithoutRuleInput | AlertEventUpdateManyWithWhereWithoutRuleInput[]
    deleteMany?: AlertEventScalarWhereInput | AlertEventScalarWhereInput[]
  }

  export type TenantCreateNestedOneWithoutAlertEventsInput = {
    create?: XOR<TenantCreateWithoutAlertEventsInput, TenantUncheckedCreateWithoutAlertEventsInput>
    connectOrCreate?: TenantCreateOrConnectWithoutAlertEventsInput
    connect?: TenantWhereUniqueInput
  }

  export type DeviceCreateNestedOneWithoutAlertEventsInput = {
    create?: XOR<DeviceCreateWithoutAlertEventsInput, DeviceUncheckedCreateWithoutAlertEventsInput>
    connectOrCreate?: DeviceCreateOrConnectWithoutAlertEventsInput
    connect?: DeviceWhereUniqueInput
  }

  export type AlertRuleCreateNestedOneWithoutAlertEventsInput = {
    create?: XOR<AlertRuleCreateWithoutAlertEventsInput, AlertRuleUncheckedCreateWithoutAlertEventsInput>
    connectOrCreate?: AlertRuleCreateOrConnectWithoutAlertEventsInput
    connect?: AlertRuleWhereUniqueInput
  }

  export type NotificationEventCreateNestedManyWithoutAlertEventInput = {
    create?: XOR<NotificationEventCreateWithoutAlertEventInput, NotificationEventUncheckedCreateWithoutAlertEventInput> | NotificationEventCreateWithoutAlertEventInput[] | NotificationEventUncheckedCreateWithoutAlertEventInput[]
    connectOrCreate?: NotificationEventCreateOrConnectWithoutAlertEventInput | NotificationEventCreateOrConnectWithoutAlertEventInput[]
    createMany?: NotificationEventCreateManyAlertEventInputEnvelope
    connect?: NotificationEventWhereUniqueInput | NotificationEventWhereUniqueInput[]
  }

  export type NotificationEventUncheckedCreateNestedManyWithoutAlertEventInput = {
    create?: XOR<NotificationEventCreateWithoutAlertEventInput, NotificationEventUncheckedCreateWithoutAlertEventInput> | NotificationEventCreateWithoutAlertEventInput[] | NotificationEventUncheckedCreateWithoutAlertEventInput[]
    connectOrCreate?: NotificationEventCreateOrConnectWithoutAlertEventInput | NotificationEventCreateOrConnectWithoutAlertEventInput[]
    createMany?: NotificationEventCreateManyAlertEventInputEnvelope
    connect?: NotificationEventWhereUniqueInput | NotificationEventWhereUniqueInput[]
  }

  export type EnumAlertEventStatusFieldUpdateOperationsInput = {
    set?: $Enums.AlertEventStatus
  }

  export type TenantUpdateOneRequiredWithoutAlertEventsNestedInput = {
    create?: XOR<TenantCreateWithoutAlertEventsInput, TenantUncheckedCreateWithoutAlertEventsInput>
    connectOrCreate?: TenantCreateOrConnectWithoutAlertEventsInput
    upsert?: TenantUpsertWithoutAlertEventsInput
    connect?: TenantWhereUniqueInput
    update?: XOR<XOR<TenantUpdateToOneWithWhereWithoutAlertEventsInput, TenantUpdateWithoutAlertEventsInput>, TenantUncheckedUpdateWithoutAlertEventsInput>
  }

  export type DeviceUpdateOneRequiredWithoutAlertEventsNestedInput = {
    create?: XOR<DeviceCreateWithoutAlertEventsInput, DeviceUncheckedCreateWithoutAlertEventsInput>
    connectOrCreate?: DeviceCreateOrConnectWithoutAlertEventsInput
    upsert?: DeviceUpsertWithoutAlertEventsInput
    connect?: DeviceWhereUniqueInput
    update?: XOR<XOR<DeviceUpdateToOneWithWhereWithoutAlertEventsInput, DeviceUpdateWithoutAlertEventsInput>, DeviceUncheckedUpdateWithoutAlertEventsInput>
  }

  export type AlertRuleUpdateOneRequiredWithoutAlertEventsNestedInput = {
    create?: XOR<AlertRuleCreateWithoutAlertEventsInput, AlertRuleUncheckedCreateWithoutAlertEventsInput>
    connectOrCreate?: AlertRuleCreateOrConnectWithoutAlertEventsInput
    upsert?: AlertRuleUpsertWithoutAlertEventsInput
    connect?: AlertRuleWhereUniqueInput
    update?: XOR<XOR<AlertRuleUpdateToOneWithWhereWithoutAlertEventsInput, AlertRuleUpdateWithoutAlertEventsInput>, AlertRuleUncheckedUpdateWithoutAlertEventsInput>
  }

  export type NotificationEventUpdateManyWithoutAlertEventNestedInput = {
    create?: XOR<NotificationEventCreateWithoutAlertEventInput, NotificationEventUncheckedCreateWithoutAlertEventInput> | NotificationEventCreateWithoutAlertEventInput[] | NotificationEventUncheckedCreateWithoutAlertEventInput[]
    connectOrCreate?: NotificationEventCreateOrConnectWithoutAlertEventInput | NotificationEventCreateOrConnectWithoutAlertEventInput[]
    upsert?: NotificationEventUpsertWithWhereUniqueWithoutAlertEventInput | NotificationEventUpsertWithWhereUniqueWithoutAlertEventInput[]
    createMany?: NotificationEventCreateManyAlertEventInputEnvelope
    set?: NotificationEventWhereUniqueInput | NotificationEventWhereUniqueInput[]
    disconnect?: NotificationEventWhereUniqueInput | NotificationEventWhereUniqueInput[]
    delete?: NotificationEventWhereUniqueInput | NotificationEventWhereUniqueInput[]
    connect?: NotificationEventWhereUniqueInput | NotificationEventWhereUniqueInput[]
    update?: NotificationEventUpdateWithWhereUniqueWithoutAlertEventInput | NotificationEventUpdateWithWhereUniqueWithoutAlertEventInput[]
    updateMany?: NotificationEventUpdateManyWithWhereWithoutAlertEventInput | NotificationEventUpdateManyWithWhereWithoutAlertEventInput[]
    deleteMany?: NotificationEventScalarWhereInput | NotificationEventScalarWhereInput[]
  }

  export type NotificationEventUncheckedUpdateManyWithoutAlertEventNestedInput = {
    create?: XOR<NotificationEventCreateWithoutAlertEventInput, NotificationEventUncheckedCreateWithoutAlertEventInput> | NotificationEventCreateWithoutAlertEventInput[] | NotificationEventUncheckedCreateWithoutAlertEventInput[]
    connectOrCreate?: NotificationEventCreateOrConnectWithoutAlertEventInput | NotificationEventCreateOrConnectWithoutAlertEventInput[]
    upsert?: NotificationEventUpsertWithWhereUniqueWithoutAlertEventInput | NotificationEventUpsertWithWhereUniqueWithoutAlertEventInput[]
    createMany?: NotificationEventCreateManyAlertEventInputEnvelope
    set?: NotificationEventWhereUniqueInput | NotificationEventWhereUniqueInput[]
    disconnect?: NotificationEventWhereUniqueInput | NotificationEventWhereUniqueInput[]
    delete?: NotificationEventWhereUniqueInput | NotificationEventWhereUniqueInput[]
    connect?: NotificationEventWhereUniqueInput | NotificationEventWhereUniqueInput[]
    update?: NotificationEventUpdateWithWhereUniqueWithoutAlertEventInput | NotificationEventUpdateWithWhereUniqueWithoutAlertEventInput[]
    updateMany?: NotificationEventUpdateManyWithWhereWithoutAlertEventInput | NotificationEventUpdateManyWithWhereWithoutAlertEventInput[]
    deleteMany?: NotificationEventScalarWhereInput | NotificationEventScalarWhereInput[]
  }

  export type TenantCreateNestedOneWithoutNotificationChannelsInput = {
    create?: XOR<TenantCreateWithoutNotificationChannelsInput, TenantUncheckedCreateWithoutNotificationChannelsInput>
    connectOrCreate?: TenantCreateOrConnectWithoutNotificationChannelsInput
    connect?: TenantWhereUniqueInput
  }

  export type NotificationEventCreateNestedManyWithoutChannelInput = {
    create?: XOR<NotificationEventCreateWithoutChannelInput, NotificationEventUncheckedCreateWithoutChannelInput> | NotificationEventCreateWithoutChannelInput[] | NotificationEventUncheckedCreateWithoutChannelInput[]
    connectOrCreate?: NotificationEventCreateOrConnectWithoutChannelInput | NotificationEventCreateOrConnectWithoutChannelInput[]
    createMany?: NotificationEventCreateManyChannelInputEnvelope
    connect?: NotificationEventWhereUniqueInput | NotificationEventWhereUniqueInput[]
  }

  export type NotificationEventUncheckedCreateNestedManyWithoutChannelInput = {
    create?: XOR<NotificationEventCreateWithoutChannelInput, NotificationEventUncheckedCreateWithoutChannelInput> | NotificationEventCreateWithoutChannelInput[] | NotificationEventUncheckedCreateWithoutChannelInput[]
    connectOrCreate?: NotificationEventCreateOrConnectWithoutChannelInput | NotificationEventCreateOrConnectWithoutChannelInput[]
    createMany?: NotificationEventCreateManyChannelInputEnvelope
    connect?: NotificationEventWhereUniqueInput | NotificationEventWhereUniqueInput[]
  }

  export type EnumNotificationChannelTypeFieldUpdateOperationsInput = {
    set?: $Enums.NotificationChannelType
  }

  export type TenantUpdateOneRequiredWithoutNotificationChannelsNestedInput = {
    create?: XOR<TenantCreateWithoutNotificationChannelsInput, TenantUncheckedCreateWithoutNotificationChannelsInput>
    connectOrCreate?: TenantCreateOrConnectWithoutNotificationChannelsInput
    upsert?: TenantUpsertWithoutNotificationChannelsInput
    connect?: TenantWhereUniqueInput
    update?: XOR<XOR<TenantUpdateToOneWithWhereWithoutNotificationChannelsInput, TenantUpdateWithoutNotificationChannelsInput>, TenantUncheckedUpdateWithoutNotificationChannelsInput>
  }

  export type NotificationEventUpdateManyWithoutChannelNestedInput = {
    create?: XOR<NotificationEventCreateWithoutChannelInput, NotificationEventUncheckedCreateWithoutChannelInput> | NotificationEventCreateWithoutChannelInput[] | NotificationEventUncheckedCreateWithoutChannelInput[]
    connectOrCreate?: NotificationEventCreateOrConnectWithoutChannelInput | NotificationEventCreateOrConnectWithoutChannelInput[]
    upsert?: NotificationEventUpsertWithWhereUniqueWithoutChannelInput | NotificationEventUpsertWithWhereUniqueWithoutChannelInput[]
    createMany?: NotificationEventCreateManyChannelInputEnvelope
    set?: NotificationEventWhereUniqueInput | NotificationEventWhereUniqueInput[]
    disconnect?: NotificationEventWhereUniqueInput | NotificationEventWhereUniqueInput[]
    delete?: NotificationEventWhereUniqueInput | NotificationEventWhereUniqueInput[]
    connect?: NotificationEventWhereUniqueInput | NotificationEventWhereUniqueInput[]
    update?: NotificationEventUpdateWithWhereUniqueWithoutChannelInput | NotificationEventUpdateWithWhereUniqueWithoutChannelInput[]
    updateMany?: NotificationEventUpdateManyWithWhereWithoutChannelInput | NotificationEventUpdateManyWithWhereWithoutChannelInput[]
    deleteMany?: NotificationEventScalarWhereInput | NotificationEventScalarWhereInput[]
  }

  export type NotificationEventUncheckedUpdateManyWithoutChannelNestedInput = {
    create?: XOR<NotificationEventCreateWithoutChannelInput, NotificationEventUncheckedCreateWithoutChannelInput> | NotificationEventCreateWithoutChannelInput[] | NotificationEventUncheckedCreateWithoutChannelInput[]
    connectOrCreate?: NotificationEventCreateOrConnectWithoutChannelInput | NotificationEventCreateOrConnectWithoutChannelInput[]
    upsert?: NotificationEventUpsertWithWhereUniqueWithoutChannelInput | NotificationEventUpsertWithWhereUniqueWithoutChannelInput[]
    createMany?: NotificationEventCreateManyChannelInputEnvelope
    set?: NotificationEventWhereUniqueInput | NotificationEventWhereUniqueInput[]
    disconnect?: NotificationEventWhereUniqueInput | NotificationEventWhereUniqueInput[]
    delete?: NotificationEventWhereUniqueInput | NotificationEventWhereUniqueInput[]
    connect?: NotificationEventWhereUniqueInput | NotificationEventWhereUniqueInput[]
    update?: NotificationEventUpdateWithWhereUniqueWithoutChannelInput | NotificationEventUpdateWithWhereUniqueWithoutChannelInput[]
    updateMany?: NotificationEventUpdateManyWithWhereWithoutChannelInput | NotificationEventUpdateManyWithWhereWithoutChannelInput[]
    deleteMany?: NotificationEventScalarWhereInput | NotificationEventScalarWhereInput[]
  }

  export type TenantCreateNestedOneWithoutNotificationEventsInput = {
    create?: XOR<TenantCreateWithoutNotificationEventsInput, TenantUncheckedCreateWithoutNotificationEventsInput>
    connectOrCreate?: TenantCreateOrConnectWithoutNotificationEventsInput
    connect?: TenantWhereUniqueInput
  }

  export type NotificationChannelCreateNestedOneWithoutNotificationEventsInput = {
    create?: XOR<NotificationChannelCreateWithoutNotificationEventsInput, NotificationChannelUncheckedCreateWithoutNotificationEventsInput>
    connectOrCreate?: NotificationChannelCreateOrConnectWithoutNotificationEventsInput
    connect?: NotificationChannelWhereUniqueInput
  }

  export type AlertEventCreateNestedOneWithoutNotificationEventsInput = {
    create?: XOR<AlertEventCreateWithoutNotificationEventsInput, AlertEventUncheckedCreateWithoutNotificationEventsInput>
    connectOrCreate?: AlertEventCreateOrConnectWithoutNotificationEventsInput
    connect?: AlertEventWhereUniqueInput
  }

  export type EnumNotificationEventStatusFieldUpdateOperationsInput = {
    set?: $Enums.NotificationEventStatus
  }

  export type TenantUpdateOneRequiredWithoutNotificationEventsNestedInput = {
    create?: XOR<TenantCreateWithoutNotificationEventsInput, TenantUncheckedCreateWithoutNotificationEventsInput>
    connectOrCreate?: TenantCreateOrConnectWithoutNotificationEventsInput
    upsert?: TenantUpsertWithoutNotificationEventsInput
    connect?: TenantWhereUniqueInput
    update?: XOR<XOR<TenantUpdateToOneWithWhereWithoutNotificationEventsInput, TenantUpdateWithoutNotificationEventsInput>, TenantUncheckedUpdateWithoutNotificationEventsInput>
  }

  export type NotificationChannelUpdateOneRequiredWithoutNotificationEventsNestedInput = {
    create?: XOR<NotificationChannelCreateWithoutNotificationEventsInput, NotificationChannelUncheckedCreateWithoutNotificationEventsInput>
    connectOrCreate?: NotificationChannelCreateOrConnectWithoutNotificationEventsInput
    upsert?: NotificationChannelUpsertWithoutNotificationEventsInput
    connect?: NotificationChannelWhereUniqueInput
    update?: XOR<XOR<NotificationChannelUpdateToOneWithWhereWithoutNotificationEventsInput, NotificationChannelUpdateWithoutNotificationEventsInput>, NotificationChannelUncheckedUpdateWithoutNotificationEventsInput>
  }

  export type AlertEventUpdateOneWithoutNotificationEventsNestedInput = {
    create?: XOR<AlertEventCreateWithoutNotificationEventsInput, AlertEventUncheckedCreateWithoutNotificationEventsInput>
    connectOrCreate?: AlertEventCreateOrConnectWithoutNotificationEventsInput
    upsert?: AlertEventUpsertWithoutNotificationEventsInput
    disconnect?: AlertEventWhereInput | boolean
    delete?: AlertEventWhereInput | boolean
    connect?: AlertEventWhereUniqueInput
    update?: XOR<XOR<AlertEventUpdateToOneWithWhereWithoutNotificationEventsInput, AlertEventUpdateWithoutNotificationEventsInput>, AlertEventUncheckedUpdateWithoutNotificationEventsInput>
  }

  export type TenantCreateNestedOneWithoutDailyRollupsInput = {
    create?: XOR<TenantCreateWithoutDailyRollupsInput, TenantUncheckedCreateWithoutDailyRollupsInput>
    connectOrCreate?: TenantCreateOrConnectWithoutDailyRollupsInput
    connect?: TenantWhereUniqueInput
  }

  export type DeviceCreateNestedOneWithoutDailyRollupsInput = {
    create?: XOR<DeviceCreateWithoutDailyRollupsInput, DeviceUncheckedCreateWithoutDailyRollupsInput>
    connectOrCreate?: DeviceCreateOrConnectWithoutDailyRollupsInput
    connect?: DeviceWhereUniqueInput
  }

  export type TenantUpdateOneRequiredWithoutDailyRollupsNestedInput = {
    create?: XOR<TenantCreateWithoutDailyRollupsInput, TenantUncheckedCreateWithoutDailyRollupsInput>
    connectOrCreate?: TenantCreateOrConnectWithoutDailyRollupsInput
    upsert?: TenantUpsertWithoutDailyRollupsInput
    connect?: TenantWhereUniqueInput
    update?: XOR<XOR<TenantUpdateToOneWithWhereWithoutDailyRollupsInput, TenantUpdateWithoutDailyRollupsInput>, TenantUncheckedUpdateWithoutDailyRollupsInput>
  }

  export type DeviceUpdateOneRequiredWithoutDailyRollupsNestedInput = {
    create?: XOR<DeviceCreateWithoutDailyRollupsInput, DeviceUncheckedCreateWithoutDailyRollupsInput>
    connectOrCreate?: DeviceCreateOrConnectWithoutDailyRollupsInput
    upsert?: DeviceUpsertWithoutDailyRollupsInput
    connect?: DeviceWhereUniqueInput
    update?: XOR<XOR<DeviceUpdateToOneWithWhereWithoutDailyRollupsInput, DeviceUpdateWithoutDailyRollupsInput>, DeviceUncheckedUpdateWithoutDailyRollupsInput>
  }

  export type TenantCreateNestedOneWithoutEntitlementsInput = {
    create?: XOR<TenantCreateWithoutEntitlementsInput, TenantUncheckedCreateWithoutEntitlementsInput>
    connectOrCreate?: TenantCreateOrConnectWithoutEntitlementsInput
    connect?: TenantWhereUniqueInput
  }

  export type DeviceCreateNestedOneWithoutEntitlementsInput = {
    create?: XOR<DeviceCreateWithoutEntitlementsInput, DeviceUncheckedCreateWithoutEntitlementsInput>
    connectOrCreate?: DeviceCreateOrConnectWithoutEntitlementsInput
    connect?: DeviceWhereUniqueInput
  }

  export type EnumEntitlementScopeFieldUpdateOperationsInput = {
    set?: $Enums.EntitlementScope
  }

  export type EnumEntitlementKeyFieldUpdateOperationsInput = {
    set?: $Enums.EntitlementKey
  }

  export type TenantUpdateOneRequiredWithoutEntitlementsNestedInput = {
    create?: XOR<TenantCreateWithoutEntitlementsInput, TenantUncheckedCreateWithoutEntitlementsInput>
    connectOrCreate?: TenantCreateOrConnectWithoutEntitlementsInput
    upsert?: TenantUpsertWithoutEntitlementsInput
    connect?: TenantWhereUniqueInput
    update?: XOR<XOR<TenantUpdateToOneWithWhereWithoutEntitlementsInput, TenantUpdateWithoutEntitlementsInput>, TenantUncheckedUpdateWithoutEntitlementsInput>
  }

  export type DeviceUpdateOneWithoutEntitlementsNestedInput = {
    create?: XOR<DeviceCreateWithoutEntitlementsInput, DeviceUncheckedCreateWithoutEntitlementsInput>
    connectOrCreate?: DeviceCreateOrConnectWithoutEntitlementsInput
    upsert?: DeviceUpsertWithoutEntitlementsInput
    disconnect?: DeviceWhereInput | boolean
    delete?: DeviceWhereInput | boolean
    connect?: DeviceWhereUniqueInput
    update?: XOR<XOR<DeviceUpdateToOneWithWhereWithoutEntitlementsInput, DeviceUpdateWithoutEntitlementsInput>, DeviceUncheckedUpdateWithoutEntitlementsInput>
  }

  export type TenantCreateNestedOneWithoutAuditLogsInput = {
    create?: XOR<TenantCreateWithoutAuditLogsInput, TenantUncheckedCreateWithoutAuditLogsInput>
    connectOrCreate?: TenantCreateOrConnectWithoutAuditLogsInput
    connect?: TenantWhereUniqueInput
  }

  export type EnumActorTypeFieldUpdateOperationsInput = {
    set?: $Enums.ActorType
  }

  export type TenantUpdateOneWithoutAuditLogsNestedInput = {
    create?: XOR<TenantCreateWithoutAuditLogsInput, TenantUncheckedCreateWithoutAuditLogsInput>
    connectOrCreate?: TenantCreateOrConnectWithoutAuditLogsInput
    upsert?: TenantUpsertWithoutAuditLogsInput
    disconnect?: TenantWhereInput | boolean
    delete?: TenantWhereInput | boolean
    connect?: TenantWhereUniqueInput
    update?: XOR<XOR<TenantUpdateToOneWithWhereWithoutAuditLogsInput, TenantUpdateWithoutAuditLogsInput>, TenantUncheckedUpdateWithoutAuditLogsInput>
  }

  export type TenantCreateNestedOneWithoutWeatherDataInput = {
    create?: XOR<TenantCreateWithoutWeatherDataInput, TenantUncheckedCreateWithoutWeatherDataInput>
    connectOrCreate?: TenantCreateOrConnectWithoutWeatherDataInput
    connect?: TenantWhereUniqueInput
  }

  export type SiteCreateNestedOneWithoutWeatherDataInput = {
    create?: XOR<SiteCreateWithoutWeatherDataInput, SiteUncheckedCreateWithoutWeatherDataInput>
    connectOrCreate?: SiteCreateOrConnectWithoutWeatherDataInput
    connect?: SiteWhereUniqueInput
  }

  export type TenantUpdateOneRequiredWithoutWeatherDataNestedInput = {
    create?: XOR<TenantCreateWithoutWeatherDataInput, TenantUncheckedCreateWithoutWeatherDataInput>
    connectOrCreate?: TenantCreateOrConnectWithoutWeatherDataInput
    upsert?: TenantUpsertWithoutWeatherDataInput
    connect?: TenantWhereUniqueInput
    update?: XOR<XOR<TenantUpdateToOneWithWhereWithoutWeatherDataInput, TenantUpdateWithoutWeatherDataInput>, TenantUncheckedUpdateWithoutWeatherDataInput>
  }

  export type SiteUpdateOneRequiredWithoutWeatherDataNestedInput = {
    create?: XOR<SiteCreateWithoutWeatherDataInput, SiteUncheckedCreateWithoutWeatherDataInput>
    connectOrCreate?: SiteCreateOrConnectWithoutWeatherDataInput
    upsert?: SiteUpsertWithoutWeatherDataInput
    connect?: SiteWhereUniqueInput
    update?: XOR<XOR<SiteUpdateToOneWithWhereWithoutWeatherDataInput, SiteUpdateWithoutWeatherDataInput>, SiteUncheckedUpdateWithoutWeatherDataInput>
  }

  export type NestedStringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type NestedEnumTenantTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.TenantType | EnumTenantTypeFieldRefInput<$PrismaModel>
    in?: $Enums.TenantType[] | ListEnumTenantTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.TenantType[] | ListEnumTenantTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumTenantTypeFilter<$PrismaModel> | $Enums.TenantType
  }

  export type NestedEnumTenantStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.TenantStatus | EnumTenantStatusFieldRefInput<$PrismaModel>
    in?: $Enums.TenantStatus[] | ListEnumTenantStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.TenantStatus[] | ListEnumTenantStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumTenantStatusFilter<$PrismaModel> | $Enums.TenantStatus
  }

  export type NestedDateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type NestedStringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedIntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type NestedEnumTenantTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.TenantType | EnumTenantTypeFieldRefInput<$PrismaModel>
    in?: $Enums.TenantType[] | ListEnumTenantTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.TenantType[] | ListEnumTenantTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumTenantTypeWithAggregatesFilter<$PrismaModel> | $Enums.TenantType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumTenantTypeFilter<$PrismaModel>
    _max?: NestedEnumTenantTypeFilter<$PrismaModel>
  }

  export type NestedEnumTenantStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.TenantStatus | EnumTenantStatusFieldRefInput<$PrismaModel>
    in?: $Enums.TenantStatus[] | ListEnumTenantStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.TenantStatus[] | ListEnumTenantStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumTenantStatusWithAggregatesFilter<$PrismaModel> | $Enums.TenantStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumTenantStatusFilter<$PrismaModel>
    _max?: NestedEnumTenantStatusFilter<$PrismaModel>
  }

  export type NestedIntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }
  export type NestedJsonNullableFilter<$PrismaModel = never> = 
    | PatchUndefined<
        Either<Required<NestedJsonNullableFilterBase<$PrismaModel>>, Exclude<keyof Required<NestedJsonNullableFilterBase<$PrismaModel>>, 'path'>>,
        Required<NestedJsonNullableFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<NestedJsonNullableFilterBase<$PrismaModel>>, 'path'>>

  export type NestedJsonNullableFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type NestedDateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type NestedEnumUserStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.UserStatus | EnumUserStatusFieldRefInput<$PrismaModel>
    in?: $Enums.UserStatus[] | ListEnumUserStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.UserStatus[] | ListEnumUserStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumUserStatusFilter<$PrismaModel> | $Enums.UserStatus
  }

  export type NestedEnumUserStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.UserStatus | EnumUserStatusFieldRefInput<$PrismaModel>
    in?: $Enums.UserStatus[] | ListEnumUserStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.UserStatus[] | ListEnumUserStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumUserStatusWithAggregatesFilter<$PrismaModel> | $Enums.UserStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumUserStatusFilter<$PrismaModel>
    _max?: NestedEnumUserStatusFilter<$PrismaModel>
  }

  export type NestedEnumMembershipRoleFilter<$PrismaModel = never> = {
    equals?: $Enums.MembershipRole | EnumMembershipRoleFieldRefInput<$PrismaModel>
    in?: $Enums.MembershipRole[] | ListEnumMembershipRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.MembershipRole[] | ListEnumMembershipRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumMembershipRoleFilter<$PrismaModel> | $Enums.MembershipRole
  }

  export type NestedEnumMembershipRoleWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.MembershipRole | EnumMembershipRoleFieldRefInput<$PrismaModel>
    in?: $Enums.MembershipRole[] | ListEnumMembershipRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.MembershipRole[] | ListEnumMembershipRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumMembershipRoleWithAggregatesFilter<$PrismaModel> | $Enums.MembershipRole
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumMembershipRoleFilter<$PrismaModel>
    _max?: NestedEnumMembershipRoleFilter<$PrismaModel>
  }

  export type NestedStringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type NestedFloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type NestedEnumLocationSourceNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.LocationSource | EnumLocationSourceFieldRefInput<$PrismaModel> | null
    in?: $Enums.LocationSource[] | ListEnumLocationSourceFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.LocationSource[] | ListEnumLocationSourceFieldRefInput<$PrismaModel> | null
    not?: NestedEnumLocationSourceNullableFilter<$PrismaModel> | $Enums.LocationSource | null
  }

  export type NestedDateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type NestedBoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type NestedStringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type NestedFloatNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedFloatNullableFilter<$PrismaModel>
    _min?: NestedFloatNullableFilter<$PrismaModel>
    _max?: NestedFloatNullableFilter<$PrismaModel>
  }

  export type NestedEnumLocationSourceNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.LocationSource | EnumLocationSourceFieldRefInput<$PrismaModel> | null
    in?: $Enums.LocationSource[] | ListEnumLocationSourceFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.LocationSource[] | ListEnumLocationSourceFieldRefInput<$PrismaModel> | null
    not?: NestedEnumLocationSourceNullableWithAggregatesFilter<$PrismaModel> | $Enums.LocationSource | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumLocationSourceNullableFilter<$PrismaModel>
    _max?: NestedEnumLocationSourceNullableFilter<$PrismaModel>
  }

  export type NestedDateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type NestedBoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type NestedEnumDeviceStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.DeviceStatus | EnumDeviceStatusFieldRefInput<$PrismaModel>
    in?: $Enums.DeviceStatus[] | ListEnumDeviceStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.DeviceStatus[] | ListEnumDeviceStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumDeviceStatusFilter<$PrismaModel> | $Enums.DeviceStatus
  }

  export type NestedEnumDeviceLocationSourceNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.DeviceLocationSource | EnumDeviceLocationSourceFieldRefInput<$PrismaModel> | null
    in?: $Enums.DeviceLocationSource[] | ListEnumDeviceLocationSourceFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.DeviceLocationSource[] | ListEnumDeviceLocationSourceFieldRefInput<$PrismaModel> | null
    not?: NestedEnumDeviceLocationSourceNullableFilter<$PrismaModel> | $Enums.DeviceLocationSource | null
  }

  export type NestedEnumDeviceStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.DeviceStatus | EnumDeviceStatusFieldRefInput<$PrismaModel>
    in?: $Enums.DeviceStatus[] | ListEnumDeviceStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.DeviceStatus[] | ListEnumDeviceStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumDeviceStatusWithAggregatesFilter<$PrismaModel> | $Enums.DeviceStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumDeviceStatusFilter<$PrismaModel>
    _max?: NestedEnumDeviceStatusFilter<$PrismaModel>
  }

  export type NestedEnumDeviceLocationSourceNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.DeviceLocationSource | EnumDeviceLocationSourceFieldRefInput<$PrismaModel> | null
    in?: $Enums.DeviceLocationSource[] | ListEnumDeviceLocationSourceFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.DeviceLocationSource[] | ListEnumDeviceLocationSourceFieldRefInput<$PrismaModel> | null
    not?: NestedEnumDeviceLocationSourceNullableWithAggregatesFilter<$PrismaModel> | $Enums.DeviceLocationSource | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumDeviceLocationSourceNullableFilter<$PrismaModel>
    _max?: NestedEnumDeviceLocationSourceNullableFilter<$PrismaModel>
  }
  export type NestedJsonFilter<$PrismaModel = never> = 
    | PatchUndefined<
        Either<Required<NestedJsonFilterBase<$PrismaModel>>, Exclude<keyof Required<NestedJsonFilterBase<$PrismaModel>>, 'path'>>,
        Required<NestedJsonFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<NestedJsonFilterBase<$PrismaModel>>, 'path'>>

  export type NestedJsonFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type NestedEnumCommandTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.CommandType | EnumCommandTypeFieldRefInput<$PrismaModel>
    in?: $Enums.CommandType[] | ListEnumCommandTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.CommandType[] | ListEnumCommandTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumCommandTypeFilter<$PrismaModel> | $Enums.CommandType
  }

  export type NestedEnumCommandStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.CommandStatus | EnumCommandStatusFieldRefInput<$PrismaModel>
    in?: $Enums.CommandStatus[] | ListEnumCommandStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.CommandStatus[] | ListEnumCommandStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumCommandStatusFilter<$PrismaModel> | $Enums.CommandStatus
  }

  export type NestedEnumCommandTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.CommandType | EnumCommandTypeFieldRefInput<$PrismaModel>
    in?: $Enums.CommandType[] | ListEnumCommandTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.CommandType[] | ListEnumCommandTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumCommandTypeWithAggregatesFilter<$PrismaModel> | $Enums.CommandType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumCommandTypeFilter<$PrismaModel>
    _max?: NestedEnumCommandTypeFilter<$PrismaModel>
  }

  export type NestedEnumCommandStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.CommandStatus | EnumCommandStatusFieldRefInput<$PrismaModel>
    in?: $Enums.CommandStatus[] | ListEnumCommandStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.CommandStatus[] | ListEnumCommandStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumCommandStatusWithAggregatesFilter<$PrismaModel> | $Enums.CommandStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumCommandStatusFilter<$PrismaModel>
    _max?: NestedEnumCommandStatusFilter<$PrismaModel>
  }

  export type NestedEnumOtaTargetTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.OtaTargetType | EnumOtaTargetTypeFieldRefInput<$PrismaModel>
    in?: $Enums.OtaTargetType[] | ListEnumOtaTargetTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.OtaTargetType[] | ListEnumOtaTargetTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumOtaTargetTypeFilter<$PrismaModel> | $Enums.OtaTargetType
  }

  export type NestedEnumOtaJobStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.OtaJobStatus | EnumOtaJobStatusFieldRefInput<$PrismaModel>
    in?: $Enums.OtaJobStatus[] | ListEnumOtaJobStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.OtaJobStatus[] | ListEnumOtaJobStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumOtaJobStatusFilter<$PrismaModel> | $Enums.OtaJobStatus
  }

  export type NestedEnumOtaTargetTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.OtaTargetType | EnumOtaTargetTypeFieldRefInput<$PrismaModel>
    in?: $Enums.OtaTargetType[] | ListEnumOtaTargetTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.OtaTargetType[] | ListEnumOtaTargetTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumOtaTargetTypeWithAggregatesFilter<$PrismaModel> | $Enums.OtaTargetType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumOtaTargetTypeFilter<$PrismaModel>
    _max?: NestedEnumOtaTargetTypeFilter<$PrismaModel>
  }

  export type NestedEnumOtaJobStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.OtaJobStatus | EnumOtaJobStatusFieldRefInput<$PrismaModel>
    in?: $Enums.OtaJobStatus[] | ListEnumOtaJobStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.OtaJobStatus[] | ListEnumOtaJobStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumOtaJobStatusWithAggregatesFilter<$PrismaModel> | $Enums.OtaJobStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumOtaJobStatusFilter<$PrismaModel>
    _max?: NestedEnumOtaJobStatusFilter<$PrismaModel>
  }

  export type NestedEnumSimStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.SimStatus | EnumSimStatusFieldRefInput<$PrismaModel>
    in?: $Enums.SimStatus[] | ListEnumSimStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.SimStatus[] | ListEnumSimStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumSimStatusFilter<$PrismaModel> | $Enums.SimStatus
  }

  export type NestedEnumSimStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.SimStatus | EnumSimStatusFieldRefInput<$PrismaModel>
    in?: $Enums.SimStatus[] | ListEnumSimStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.SimStatus[] | ListEnumSimStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumSimStatusWithAggregatesFilter<$PrismaModel> | $Enums.SimStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumSimStatusFilter<$PrismaModel>
    _max?: NestedEnumSimStatusFilter<$PrismaModel>
  }

  export type NestedEnumSimActionTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.SimActionType | EnumSimActionTypeFieldRefInput<$PrismaModel>
    in?: $Enums.SimActionType[] | ListEnumSimActionTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.SimActionType[] | ListEnumSimActionTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumSimActionTypeFilter<$PrismaModel> | $Enums.SimActionType
  }

  export type NestedEnumSimActionStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.SimActionStatus | EnumSimActionStatusFieldRefInput<$PrismaModel>
    in?: $Enums.SimActionStatus[] | ListEnumSimActionStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.SimActionStatus[] | ListEnumSimActionStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumSimActionStatusFilter<$PrismaModel> | $Enums.SimActionStatus
  }

  export type NestedEnumSimActionTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.SimActionType | EnumSimActionTypeFieldRefInput<$PrismaModel>
    in?: $Enums.SimActionType[] | ListEnumSimActionTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.SimActionType[] | ListEnumSimActionTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumSimActionTypeWithAggregatesFilter<$PrismaModel> | $Enums.SimActionType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumSimActionTypeFilter<$PrismaModel>
    _max?: NestedEnumSimActionTypeFilter<$PrismaModel>
  }

  export type NestedEnumSimActionStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.SimActionStatus | EnumSimActionStatusFieldRefInput<$PrismaModel>
    in?: $Enums.SimActionStatus[] | ListEnumSimActionStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.SimActionStatus[] | ListEnumSimActionStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumSimActionStatusWithAggregatesFilter<$PrismaModel> | $Enums.SimActionStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumSimActionStatusFilter<$PrismaModel>
    _max?: NestedEnumSimActionStatusFilter<$PrismaModel>
  }

  export type NestedEnumAlertRuleTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.AlertRuleType | EnumAlertRuleTypeFieldRefInput<$PrismaModel>
    in?: $Enums.AlertRuleType[] | ListEnumAlertRuleTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.AlertRuleType[] | ListEnumAlertRuleTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumAlertRuleTypeFilter<$PrismaModel> | $Enums.AlertRuleType
  }

  export type NestedEnumAlertSeverityFilter<$PrismaModel = never> = {
    equals?: $Enums.AlertSeverity | EnumAlertSeverityFieldRefInput<$PrismaModel>
    in?: $Enums.AlertSeverity[] | ListEnumAlertSeverityFieldRefInput<$PrismaModel>
    notIn?: $Enums.AlertSeverity[] | ListEnumAlertSeverityFieldRefInput<$PrismaModel>
    not?: NestedEnumAlertSeverityFilter<$PrismaModel> | $Enums.AlertSeverity
  }

  export type NestedEnumAlertRuleTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.AlertRuleType | EnumAlertRuleTypeFieldRefInput<$PrismaModel>
    in?: $Enums.AlertRuleType[] | ListEnumAlertRuleTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.AlertRuleType[] | ListEnumAlertRuleTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumAlertRuleTypeWithAggregatesFilter<$PrismaModel> | $Enums.AlertRuleType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumAlertRuleTypeFilter<$PrismaModel>
    _max?: NestedEnumAlertRuleTypeFilter<$PrismaModel>
  }

  export type NestedEnumAlertSeverityWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.AlertSeverity | EnumAlertSeverityFieldRefInput<$PrismaModel>
    in?: $Enums.AlertSeverity[] | ListEnumAlertSeverityFieldRefInput<$PrismaModel>
    notIn?: $Enums.AlertSeverity[] | ListEnumAlertSeverityFieldRefInput<$PrismaModel>
    not?: NestedEnumAlertSeverityWithAggregatesFilter<$PrismaModel> | $Enums.AlertSeverity
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumAlertSeverityFilter<$PrismaModel>
    _max?: NestedEnumAlertSeverityFilter<$PrismaModel>
  }

  export type NestedEnumAlertEventStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.AlertEventStatus | EnumAlertEventStatusFieldRefInput<$PrismaModel>
    in?: $Enums.AlertEventStatus[] | ListEnumAlertEventStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.AlertEventStatus[] | ListEnumAlertEventStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumAlertEventStatusFilter<$PrismaModel> | $Enums.AlertEventStatus
  }

  export type NestedEnumAlertEventStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.AlertEventStatus | EnumAlertEventStatusFieldRefInput<$PrismaModel>
    in?: $Enums.AlertEventStatus[] | ListEnumAlertEventStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.AlertEventStatus[] | ListEnumAlertEventStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumAlertEventStatusWithAggregatesFilter<$PrismaModel> | $Enums.AlertEventStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumAlertEventStatusFilter<$PrismaModel>
    _max?: NestedEnumAlertEventStatusFilter<$PrismaModel>
  }

  export type NestedEnumNotificationChannelTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.NotificationChannelType | EnumNotificationChannelTypeFieldRefInput<$PrismaModel>
    in?: $Enums.NotificationChannelType[] | ListEnumNotificationChannelTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.NotificationChannelType[] | ListEnumNotificationChannelTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumNotificationChannelTypeFilter<$PrismaModel> | $Enums.NotificationChannelType
  }

  export type NestedEnumNotificationChannelTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.NotificationChannelType | EnumNotificationChannelTypeFieldRefInput<$PrismaModel>
    in?: $Enums.NotificationChannelType[] | ListEnumNotificationChannelTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.NotificationChannelType[] | ListEnumNotificationChannelTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumNotificationChannelTypeWithAggregatesFilter<$PrismaModel> | $Enums.NotificationChannelType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumNotificationChannelTypeFilter<$PrismaModel>
    _max?: NestedEnumNotificationChannelTypeFilter<$PrismaModel>
  }

  export type NestedEnumNotificationEventStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.NotificationEventStatus | EnumNotificationEventStatusFieldRefInput<$PrismaModel>
    in?: $Enums.NotificationEventStatus[] | ListEnumNotificationEventStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.NotificationEventStatus[] | ListEnumNotificationEventStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumNotificationEventStatusFilter<$PrismaModel> | $Enums.NotificationEventStatus
  }

  export type NestedEnumNotificationEventStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.NotificationEventStatus | EnumNotificationEventStatusFieldRefInput<$PrismaModel>
    in?: $Enums.NotificationEventStatus[] | ListEnumNotificationEventStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.NotificationEventStatus[] | ListEnumNotificationEventStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumNotificationEventStatusWithAggregatesFilter<$PrismaModel> | $Enums.NotificationEventStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumNotificationEventStatusFilter<$PrismaModel>
    _max?: NestedEnumNotificationEventStatusFilter<$PrismaModel>
  }

  export type NestedEnumEntitlementScopeFilter<$PrismaModel = never> = {
    equals?: $Enums.EntitlementScope | EnumEntitlementScopeFieldRefInput<$PrismaModel>
    in?: $Enums.EntitlementScope[] | ListEnumEntitlementScopeFieldRefInput<$PrismaModel>
    notIn?: $Enums.EntitlementScope[] | ListEnumEntitlementScopeFieldRefInput<$PrismaModel>
    not?: NestedEnumEntitlementScopeFilter<$PrismaModel> | $Enums.EntitlementScope
  }

  export type NestedEnumEntitlementKeyFilter<$PrismaModel = never> = {
    equals?: $Enums.EntitlementKey | EnumEntitlementKeyFieldRefInput<$PrismaModel>
    in?: $Enums.EntitlementKey[] | ListEnumEntitlementKeyFieldRefInput<$PrismaModel>
    notIn?: $Enums.EntitlementKey[] | ListEnumEntitlementKeyFieldRefInput<$PrismaModel>
    not?: NestedEnumEntitlementKeyFilter<$PrismaModel> | $Enums.EntitlementKey
  }

  export type NestedEnumEntitlementScopeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.EntitlementScope | EnumEntitlementScopeFieldRefInput<$PrismaModel>
    in?: $Enums.EntitlementScope[] | ListEnumEntitlementScopeFieldRefInput<$PrismaModel>
    notIn?: $Enums.EntitlementScope[] | ListEnumEntitlementScopeFieldRefInput<$PrismaModel>
    not?: NestedEnumEntitlementScopeWithAggregatesFilter<$PrismaModel> | $Enums.EntitlementScope
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumEntitlementScopeFilter<$PrismaModel>
    _max?: NestedEnumEntitlementScopeFilter<$PrismaModel>
  }

  export type NestedEnumEntitlementKeyWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.EntitlementKey | EnumEntitlementKeyFieldRefInput<$PrismaModel>
    in?: $Enums.EntitlementKey[] | ListEnumEntitlementKeyFieldRefInput<$PrismaModel>
    notIn?: $Enums.EntitlementKey[] | ListEnumEntitlementKeyFieldRefInput<$PrismaModel>
    not?: NestedEnumEntitlementKeyWithAggregatesFilter<$PrismaModel> | $Enums.EntitlementKey
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumEntitlementKeyFilter<$PrismaModel>
    _max?: NestedEnumEntitlementKeyFilter<$PrismaModel>
  }

  export type NestedEnumActorTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.ActorType | EnumActorTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ActorType[] | ListEnumActorTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.ActorType[] | ListEnumActorTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumActorTypeFilter<$PrismaModel> | $Enums.ActorType
  }

  export type NestedEnumActorTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ActorType | EnumActorTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ActorType[] | ListEnumActorTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.ActorType[] | ListEnumActorTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumActorTypeWithAggregatesFilter<$PrismaModel> | $Enums.ActorType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumActorTypeFilter<$PrismaModel>
    _max?: NestedEnumActorTypeFilter<$PrismaModel>
  }

  export type MembershipCreateWithoutTenantInput = {
    id?: string
    role: $Enums.MembershipRole
    createdAt?: Date | string
    user: UserCreateNestedOneWithoutMembershipsInput
  }

  export type MembershipUncheckedCreateWithoutTenantInput = {
    id?: string
    userId: string
    role: $Enums.MembershipRole
    createdAt?: Date | string
  }

  export type MembershipCreateOrConnectWithoutTenantInput = {
    where: MembershipWhereUniqueInput
    create: XOR<MembershipCreateWithoutTenantInput, MembershipUncheckedCreateWithoutTenantInput>
  }

  export type MembershipCreateManyTenantInputEnvelope = {
    data: MembershipCreateManyTenantInput | MembershipCreateManyTenantInput[]
    skipDuplicates?: boolean
  }

  export type SiteCreateWithoutTenantInput = {
    id?: string
    name: string
    addressLine1?: string | null
    addressLine2?: string | null
    city?: string | null
    region?: string | null
    postalCode?: string | null
    country?: string | null
    lat?: number | null
    lon?: number | null
    locationSource?: $Enums.LocationSource | null
    locationAccuracyM?: number | null
    locationConfidence?: number | null
    locationUpdatedAt?: Date | string | null
    locationLock?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    locationUpdatedBy?: UserCreateNestedOneWithoutSiteLocUpdatesInput
    devices?: DeviceCreateNestedManyWithoutSiteInput
    weatherData?: WeatherDataCreateNestedManyWithoutSiteInput
  }

  export type SiteUncheckedCreateWithoutTenantInput = {
    id?: string
    name: string
    addressLine1?: string | null
    addressLine2?: string | null
    city?: string | null
    region?: string | null
    postalCode?: string | null
    country?: string | null
    lat?: number | null
    lon?: number | null
    locationSource?: $Enums.LocationSource | null
    locationAccuracyM?: number | null
    locationConfidence?: number | null
    locationUpdatedAt?: Date | string | null
    locationUpdatedByUserId?: string | null
    locationLock?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    devices?: DeviceUncheckedCreateNestedManyWithoutSiteInput
    weatherData?: WeatherDataUncheckedCreateNestedManyWithoutSiteInput
  }

  export type SiteCreateOrConnectWithoutTenantInput = {
    where: SiteWhereUniqueInput
    create: XOR<SiteCreateWithoutTenantInput, SiteUncheckedCreateWithoutTenantInput>
  }

  export type SiteCreateManyTenantInputEnvelope = {
    data: SiteCreateManyTenantInput | SiteCreateManyTenantInput[]
    skipDuplicates?: boolean
  }

  export type DeviceCreateWithoutTenantInput = {
    id?: string
    ownerUserId?: string | null
    model: string
    serialNumber: string
    name?: string | null
    notes?: string | null
    tags?: NullableJsonNullValueInput | InputJsonValue
    status?: $Enums.DeviceStatus
    lastSeenAt?: Date | string | null
    firmwareVersion?: string | null
    deviceLat?: number | null
    deviceLon?: number | null
    deviceLocationTs?: Date | string | null
    deviceLocationSource?: $Enums.DeviceLocationSource | null
    deviceLocationAccuracyM?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    site?: SiteCreateNestedOneWithoutDevicesInput
    sim?: SimInfoCreateNestedOneWithoutDevicesInput
    secret?: DeviceSecretCreateNestedOneWithoutDeviceInput
    twin?: DeviceTwinCreateNestedOneWithoutDeviceInput
    telemetry?: TelemetryCreateNestedManyWithoutDeviceInput
    commands?: CommandCreateNestedManyWithoutDeviceInput
    alertEvents?: AlertEventCreateNestedManyWithoutDeviceInput
    dailyRollups?: DailyRollupCreateNestedManyWithoutDeviceInput
    entitlements?: EntitlementCreateNestedManyWithoutDeviceInput
  }

  export type DeviceUncheckedCreateWithoutTenantInput = {
    id?: string
    siteId?: string | null
    ownerUserId?: string | null
    model: string
    serialNumber: string
    name?: string | null
    notes?: string | null
    tags?: NullableJsonNullValueInput | InputJsonValue
    status?: $Enums.DeviceStatus
    lastSeenAt?: Date | string | null
    firmwareVersion?: string | null
    simIccid?: string | null
    deviceLat?: number | null
    deviceLon?: number | null
    deviceLocationTs?: Date | string | null
    deviceLocationSource?: $Enums.DeviceLocationSource | null
    deviceLocationAccuracyM?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    secret?: DeviceSecretUncheckedCreateNestedOneWithoutDeviceInput
    twin?: DeviceTwinUncheckedCreateNestedOneWithoutDeviceInput
    telemetry?: TelemetryUncheckedCreateNestedManyWithoutDeviceInput
    commands?: CommandUncheckedCreateNestedManyWithoutDeviceInput
    alertEvents?: AlertEventUncheckedCreateNestedManyWithoutDeviceInput
    dailyRollups?: DailyRollupUncheckedCreateNestedManyWithoutDeviceInput
    entitlements?: EntitlementUncheckedCreateNestedManyWithoutDeviceInput
  }

  export type DeviceCreateOrConnectWithoutTenantInput = {
    where: DeviceWhereUniqueInput
    create: XOR<DeviceCreateWithoutTenantInput, DeviceUncheckedCreateWithoutTenantInput>
  }

  export type DeviceCreateManyTenantInputEnvelope = {
    data: DeviceCreateManyTenantInput | DeviceCreateManyTenantInput[]
    skipDuplicates?: boolean
  }

  export type AlertRuleCreateWithoutTenantInput = {
    id?: string
    name: string
    enabled?: boolean
    type: $Enums.AlertRuleType
    params: JsonNullValueInput | InputJsonValue
    severity?: $Enums.AlertSeverity
    createdAt?: Date | string
    updatedAt?: Date | string
    alertEvents?: AlertEventCreateNestedManyWithoutRuleInput
  }

  export type AlertRuleUncheckedCreateWithoutTenantInput = {
    id?: string
    name: string
    enabled?: boolean
    type: $Enums.AlertRuleType
    params: JsonNullValueInput | InputJsonValue
    severity?: $Enums.AlertSeverity
    createdAt?: Date | string
    updatedAt?: Date | string
    alertEvents?: AlertEventUncheckedCreateNestedManyWithoutRuleInput
  }

  export type AlertRuleCreateOrConnectWithoutTenantInput = {
    where: AlertRuleWhereUniqueInput
    create: XOR<AlertRuleCreateWithoutTenantInput, AlertRuleUncheckedCreateWithoutTenantInput>
  }

  export type AlertRuleCreateManyTenantInputEnvelope = {
    data: AlertRuleCreateManyTenantInput | AlertRuleCreateManyTenantInput[]
    skipDuplicates?: boolean
  }

  export type AlertEventCreateWithoutTenantInput = {
    id?: string
    severity: $Enums.AlertSeverity
    status?: $Enums.AlertEventStatus
    openedAt?: Date | string
    acknowledgedAt?: Date | string | null
    closedAt?: Date | string | null
    details?: NullableJsonNullValueInput | InputJsonValue
    dedupeKey?: string | null
    device: DeviceCreateNestedOneWithoutAlertEventsInput
    rule: AlertRuleCreateNestedOneWithoutAlertEventsInput
    notificationEvents?: NotificationEventCreateNestedManyWithoutAlertEventInput
  }

  export type AlertEventUncheckedCreateWithoutTenantInput = {
    id?: string
    deviceId: string
    ruleId: string
    severity: $Enums.AlertSeverity
    status?: $Enums.AlertEventStatus
    openedAt?: Date | string
    acknowledgedAt?: Date | string | null
    closedAt?: Date | string | null
    details?: NullableJsonNullValueInput | InputJsonValue
    dedupeKey?: string | null
    notificationEvents?: NotificationEventUncheckedCreateNestedManyWithoutAlertEventInput
  }

  export type AlertEventCreateOrConnectWithoutTenantInput = {
    where: AlertEventWhereUniqueInput
    create: XOR<AlertEventCreateWithoutTenantInput, AlertEventUncheckedCreateWithoutTenantInput>
  }

  export type AlertEventCreateManyTenantInputEnvelope = {
    data: AlertEventCreateManyTenantInput | AlertEventCreateManyTenantInput[]
    skipDuplicates?: boolean
  }

  export type NotificationChannelCreateWithoutTenantInput = {
    id?: string
    type: $Enums.NotificationChannelType
    config: JsonNullValueInput | InputJsonValue
    enabled?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    notificationEvents?: NotificationEventCreateNestedManyWithoutChannelInput
  }

  export type NotificationChannelUncheckedCreateWithoutTenantInput = {
    id?: string
    type: $Enums.NotificationChannelType
    config: JsonNullValueInput | InputJsonValue
    enabled?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    notificationEvents?: NotificationEventUncheckedCreateNestedManyWithoutChannelInput
  }

  export type NotificationChannelCreateOrConnectWithoutTenantInput = {
    where: NotificationChannelWhereUniqueInput
    create: XOR<NotificationChannelCreateWithoutTenantInput, NotificationChannelUncheckedCreateWithoutTenantInput>
  }

  export type NotificationChannelCreateManyTenantInputEnvelope = {
    data: NotificationChannelCreateManyTenantInput | NotificationChannelCreateManyTenantInput[]
    skipDuplicates?: boolean
  }

  export type NotificationEventCreateWithoutTenantInput = {
    id?: string
    status?: $Enums.NotificationEventStatus
    payload: JsonNullValueInput | InputJsonValue
    sentAt?: Date | string | null
    errorMsg?: string | null
    createdAt?: Date | string
    channel: NotificationChannelCreateNestedOneWithoutNotificationEventsInput
    alertEvent?: AlertEventCreateNestedOneWithoutNotificationEventsInput
  }

  export type NotificationEventUncheckedCreateWithoutTenantInput = {
    id?: string
    channelId: string
    alertEventId?: string | null
    status?: $Enums.NotificationEventStatus
    payload: JsonNullValueInput | InputJsonValue
    sentAt?: Date | string | null
    errorMsg?: string | null
    createdAt?: Date | string
  }

  export type NotificationEventCreateOrConnectWithoutTenantInput = {
    where: NotificationEventWhereUniqueInput
    create: XOR<NotificationEventCreateWithoutTenantInput, NotificationEventUncheckedCreateWithoutTenantInput>
  }

  export type NotificationEventCreateManyTenantInputEnvelope = {
    data: NotificationEventCreateManyTenantInput | NotificationEventCreateManyTenantInput[]
    skipDuplicates?: boolean
  }

  export type DailyRollupCreateWithoutTenantInput = {
    id?: string
    dayDate: Date | string
    energyKwhDay?: number | null
    hotWaterUsageLitersDay?: number | null
    heaterOnMinutesDay?: number | null
    tankTempMinC?: number | null
    tankTempMaxC?: number | null
    ambientTempAvgC?: number | null
    createdAt?: Date | string
    device: DeviceCreateNestedOneWithoutDailyRollupsInput
  }

  export type DailyRollupUncheckedCreateWithoutTenantInput = {
    id?: string
    deviceId: string
    dayDate: Date | string
    energyKwhDay?: number | null
    hotWaterUsageLitersDay?: number | null
    heaterOnMinutesDay?: number | null
    tankTempMinC?: number | null
    tankTempMaxC?: number | null
    ambientTempAvgC?: number | null
    createdAt?: Date | string
  }

  export type DailyRollupCreateOrConnectWithoutTenantInput = {
    where: DailyRollupWhereUniqueInput
    create: XOR<DailyRollupCreateWithoutTenantInput, DailyRollupUncheckedCreateWithoutTenantInput>
  }

  export type DailyRollupCreateManyTenantInputEnvelope = {
    data: DailyRollupCreateManyTenantInput | DailyRollupCreateManyTenantInput[]
    skipDuplicates?: boolean
  }

  export type EntitlementCreateWithoutTenantInput = {
    id?: string
    scope: $Enums.EntitlementScope
    key: $Enums.EntitlementKey
    enabled?: boolean
    updatedAt?: Date | string
    device?: DeviceCreateNestedOneWithoutEntitlementsInput
  }

  export type EntitlementUncheckedCreateWithoutTenantInput = {
    id?: string
    scope: $Enums.EntitlementScope
    deviceId?: string | null
    key: $Enums.EntitlementKey
    enabled?: boolean
    updatedAt?: Date | string
  }

  export type EntitlementCreateOrConnectWithoutTenantInput = {
    where: EntitlementWhereUniqueInput
    create: XOR<EntitlementCreateWithoutTenantInput, EntitlementUncheckedCreateWithoutTenantInput>
  }

  export type EntitlementCreateManyTenantInputEnvelope = {
    data: EntitlementCreateManyTenantInput | EntitlementCreateManyTenantInput[]
    skipDuplicates?: boolean
  }

  export type AuditLogCreateWithoutTenantInput = {
    id?: string
    actorUserId?: string | null
    actorType?: $Enums.ActorType
    action: string
    entityType: string
    entityId: string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type AuditLogUncheckedCreateWithoutTenantInput = {
    id?: string
    actorUserId?: string | null
    actorType?: $Enums.ActorType
    action: string
    entityType: string
    entityId: string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type AuditLogCreateOrConnectWithoutTenantInput = {
    where: AuditLogWhereUniqueInput
    create: XOR<AuditLogCreateWithoutTenantInput, AuditLogUncheckedCreateWithoutTenantInput>
  }

  export type AuditLogCreateManyTenantInputEnvelope = {
    data: AuditLogCreateManyTenantInput | AuditLogCreateManyTenantInput[]
    skipDuplicates?: boolean
  }

  export type OtaJobCreateWithoutTenantInput = {
    id?: string
    targetType: $Enums.OtaTargetType
    deviceId?: string | null
    groupFilter?: NullableJsonNullValueInput | InputJsonValue
    status?: $Enums.OtaJobStatus
    scheduledAt: Date | string
    startedAt?: Date | string | null
    finishedAt?: Date | string | null
    progress?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    firmwarePackage: FirmwarePackageCreateNestedOneWithoutOtaJobsInput
    createdBy?: UserCreateNestedOneWithoutOtaJobsInput
  }

  export type OtaJobUncheckedCreateWithoutTenantInput = {
    id?: string
    targetType: $Enums.OtaTargetType
    deviceId?: string | null
    groupFilter?: NullableJsonNullValueInput | InputJsonValue
    firmwarePackageId: string
    status?: $Enums.OtaJobStatus
    scheduledAt: Date | string
    startedAt?: Date | string | null
    finishedAt?: Date | string | null
    createdByUserId?: string | null
    progress?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type OtaJobCreateOrConnectWithoutTenantInput = {
    where: OtaJobWhereUniqueInput
    create: XOR<OtaJobCreateWithoutTenantInput, OtaJobUncheckedCreateWithoutTenantInput>
  }

  export type OtaJobCreateManyTenantInputEnvelope = {
    data: OtaJobCreateManyTenantInput | OtaJobCreateManyTenantInput[]
    skipDuplicates?: boolean
  }

  export type WeatherDataCreateWithoutTenantInput = {
    id?: string
    date: Date | string
    summary: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    site: SiteCreateNestedOneWithoutWeatherDataInput
  }

  export type WeatherDataUncheckedCreateWithoutTenantInput = {
    id?: string
    siteId: string
    date: Date | string
    summary: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type WeatherDataCreateOrConnectWithoutTenantInput = {
    where: WeatherDataWhereUniqueInput
    create: XOR<WeatherDataCreateWithoutTenantInput, WeatherDataUncheckedCreateWithoutTenantInput>
  }

  export type WeatherDataCreateManyTenantInputEnvelope = {
    data: WeatherDataCreateManyTenantInput | WeatherDataCreateManyTenantInput[]
    skipDuplicates?: boolean
  }

  export type MembershipUpsertWithWhereUniqueWithoutTenantInput = {
    where: MembershipWhereUniqueInput
    update: XOR<MembershipUpdateWithoutTenantInput, MembershipUncheckedUpdateWithoutTenantInput>
    create: XOR<MembershipCreateWithoutTenantInput, MembershipUncheckedCreateWithoutTenantInput>
  }

  export type MembershipUpdateWithWhereUniqueWithoutTenantInput = {
    where: MembershipWhereUniqueInput
    data: XOR<MembershipUpdateWithoutTenantInput, MembershipUncheckedUpdateWithoutTenantInput>
  }

  export type MembershipUpdateManyWithWhereWithoutTenantInput = {
    where: MembershipScalarWhereInput
    data: XOR<MembershipUpdateManyMutationInput, MembershipUncheckedUpdateManyWithoutTenantInput>
  }

  export type MembershipScalarWhereInput = {
    AND?: MembershipScalarWhereInput | MembershipScalarWhereInput[]
    OR?: MembershipScalarWhereInput[]
    NOT?: MembershipScalarWhereInput | MembershipScalarWhereInput[]
    id?: StringFilter<"Membership"> | string
    userId?: StringFilter<"Membership"> | string
    tenantId?: StringFilter<"Membership"> | string
    role?: EnumMembershipRoleFilter<"Membership"> | $Enums.MembershipRole
    createdAt?: DateTimeFilter<"Membership"> | Date | string
  }

  export type SiteUpsertWithWhereUniqueWithoutTenantInput = {
    where: SiteWhereUniqueInput
    update: XOR<SiteUpdateWithoutTenantInput, SiteUncheckedUpdateWithoutTenantInput>
    create: XOR<SiteCreateWithoutTenantInput, SiteUncheckedCreateWithoutTenantInput>
  }

  export type SiteUpdateWithWhereUniqueWithoutTenantInput = {
    where: SiteWhereUniqueInput
    data: XOR<SiteUpdateWithoutTenantInput, SiteUncheckedUpdateWithoutTenantInput>
  }

  export type SiteUpdateManyWithWhereWithoutTenantInput = {
    where: SiteScalarWhereInput
    data: XOR<SiteUpdateManyMutationInput, SiteUncheckedUpdateManyWithoutTenantInput>
  }

  export type SiteScalarWhereInput = {
    AND?: SiteScalarWhereInput | SiteScalarWhereInput[]
    OR?: SiteScalarWhereInput[]
    NOT?: SiteScalarWhereInput | SiteScalarWhereInput[]
    id?: StringFilter<"Site"> | string
    tenantId?: StringFilter<"Site"> | string
    name?: StringFilter<"Site"> | string
    addressLine1?: StringNullableFilter<"Site"> | string | null
    addressLine2?: StringNullableFilter<"Site"> | string | null
    city?: StringNullableFilter<"Site"> | string | null
    region?: StringNullableFilter<"Site"> | string | null
    postalCode?: StringNullableFilter<"Site"> | string | null
    country?: StringNullableFilter<"Site"> | string | null
    lat?: FloatNullableFilter<"Site"> | number | null
    lon?: FloatNullableFilter<"Site"> | number | null
    locationSource?: EnumLocationSourceNullableFilter<"Site"> | $Enums.LocationSource | null
    locationAccuracyM?: FloatNullableFilter<"Site"> | number | null
    locationConfidence?: FloatNullableFilter<"Site"> | number | null
    locationUpdatedAt?: DateTimeNullableFilter<"Site"> | Date | string | null
    locationUpdatedByUserId?: StringNullableFilter<"Site"> | string | null
    locationLock?: BoolFilter<"Site"> | boolean
    createdAt?: DateTimeFilter<"Site"> | Date | string
    updatedAt?: DateTimeFilter<"Site"> | Date | string
  }

  export type DeviceUpsertWithWhereUniqueWithoutTenantInput = {
    where: DeviceWhereUniqueInput
    update: XOR<DeviceUpdateWithoutTenantInput, DeviceUncheckedUpdateWithoutTenantInput>
    create: XOR<DeviceCreateWithoutTenantInput, DeviceUncheckedCreateWithoutTenantInput>
  }

  export type DeviceUpdateWithWhereUniqueWithoutTenantInput = {
    where: DeviceWhereUniqueInput
    data: XOR<DeviceUpdateWithoutTenantInput, DeviceUncheckedUpdateWithoutTenantInput>
  }

  export type DeviceUpdateManyWithWhereWithoutTenantInput = {
    where: DeviceScalarWhereInput
    data: XOR<DeviceUpdateManyMutationInput, DeviceUncheckedUpdateManyWithoutTenantInput>
  }

  export type DeviceScalarWhereInput = {
    AND?: DeviceScalarWhereInput | DeviceScalarWhereInput[]
    OR?: DeviceScalarWhereInput[]
    NOT?: DeviceScalarWhereInput | DeviceScalarWhereInput[]
    id?: StringFilter<"Device"> | string
    tenantId?: StringFilter<"Device"> | string
    siteId?: StringNullableFilter<"Device"> | string | null
    ownerUserId?: StringNullableFilter<"Device"> | string | null
    model?: StringFilter<"Device"> | string
    serialNumber?: StringFilter<"Device"> | string
    name?: StringNullableFilter<"Device"> | string | null
    notes?: StringNullableFilter<"Device"> | string | null
    tags?: JsonNullableFilter<"Device">
    status?: EnumDeviceStatusFilter<"Device"> | $Enums.DeviceStatus
    lastSeenAt?: DateTimeNullableFilter<"Device"> | Date | string | null
    firmwareVersion?: StringNullableFilter<"Device"> | string | null
    simIccid?: StringNullableFilter<"Device"> | string | null
    deviceLat?: FloatNullableFilter<"Device"> | number | null
    deviceLon?: FloatNullableFilter<"Device"> | number | null
    deviceLocationTs?: DateTimeNullableFilter<"Device"> | Date | string | null
    deviceLocationSource?: EnumDeviceLocationSourceNullableFilter<"Device"> | $Enums.DeviceLocationSource | null
    deviceLocationAccuracyM?: FloatNullableFilter<"Device"> | number | null
    createdAt?: DateTimeFilter<"Device"> | Date | string
    updatedAt?: DateTimeFilter<"Device"> | Date | string
  }

  export type AlertRuleUpsertWithWhereUniqueWithoutTenantInput = {
    where: AlertRuleWhereUniqueInput
    update: XOR<AlertRuleUpdateWithoutTenantInput, AlertRuleUncheckedUpdateWithoutTenantInput>
    create: XOR<AlertRuleCreateWithoutTenantInput, AlertRuleUncheckedCreateWithoutTenantInput>
  }

  export type AlertRuleUpdateWithWhereUniqueWithoutTenantInput = {
    where: AlertRuleWhereUniqueInput
    data: XOR<AlertRuleUpdateWithoutTenantInput, AlertRuleUncheckedUpdateWithoutTenantInput>
  }

  export type AlertRuleUpdateManyWithWhereWithoutTenantInput = {
    where: AlertRuleScalarWhereInput
    data: XOR<AlertRuleUpdateManyMutationInput, AlertRuleUncheckedUpdateManyWithoutTenantInput>
  }

  export type AlertRuleScalarWhereInput = {
    AND?: AlertRuleScalarWhereInput | AlertRuleScalarWhereInput[]
    OR?: AlertRuleScalarWhereInput[]
    NOT?: AlertRuleScalarWhereInput | AlertRuleScalarWhereInput[]
    id?: StringFilter<"AlertRule"> | string
    tenantId?: StringFilter<"AlertRule"> | string
    name?: StringFilter<"AlertRule"> | string
    enabled?: BoolFilter<"AlertRule"> | boolean
    type?: EnumAlertRuleTypeFilter<"AlertRule"> | $Enums.AlertRuleType
    params?: JsonFilter<"AlertRule">
    severity?: EnumAlertSeverityFilter<"AlertRule"> | $Enums.AlertSeverity
    createdAt?: DateTimeFilter<"AlertRule"> | Date | string
    updatedAt?: DateTimeFilter<"AlertRule"> | Date | string
  }

  export type AlertEventUpsertWithWhereUniqueWithoutTenantInput = {
    where: AlertEventWhereUniqueInput
    update: XOR<AlertEventUpdateWithoutTenantInput, AlertEventUncheckedUpdateWithoutTenantInput>
    create: XOR<AlertEventCreateWithoutTenantInput, AlertEventUncheckedCreateWithoutTenantInput>
  }

  export type AlertEventUpdateWithWhereUniqueWithoutTenantInput = {
    where: AlertEventWhereUniqueInput
    data: XOR<AlertEventUpdateWithoutTenantInput, AlertEventUncheckedUpdateWithoutTenantInput>
  }

  export type AlertEventUpdateManyWithWhereWithoutTenantInput = {
    where: AlertEventScalarWhereInput
    data: XOR<AlertEventUpdateManyMutationInput, AlertEventUncheckedUpdateManyWithoutTenantInput>
  }

  export type AlertEventScalarWhereInput = {
    AND?: AlertEventScalarWhereInput | AlertEventScalarWhereInput[]
    OR?: AlertEventScalarWhereInput[]
    NOT?: AlertEventScalarWhereInput | AlertEventScalarWhereInput[]
    id?: StringFilter<"AlertEvent"> | string
    tenantId?: StringFilter<"AlertEvent"> | string
    deviceId?: StringFilter<"AlertEvent"> | string
    ruleId?: StringFilter<"AlertEvent"> | string
    severity?: EnumAlertSeverityFilter<"AlertEvent"> | $Enums.AlertSeverity
    status?: EnumAlertEventStatusFilter<"AlertEvent"> | $Enums.AlertEventStatus
    openedAt?: DateTimeFilter<"AlertEvent"> | Date | string
    acknowledgedAt?: DateTimeNullableFilter<"AlertEvent"> | Date | string | null
    closedAt?: DateTimeNullableFilter<"AlertEvent"> | Date | string | null
    details?: JsonNullableFilter<"AlertEvent">
    dedupeKey?: StringNullableFilter<"AlertEvent"> | string | null
  }

  export type NotificationChannelUpsertWithWhereUniqueWithoutTenantInput = {
    where: NotificationChannelWhereUniqueInput
    update: XOR<NotificationChannelUpdateWithoutTenantInput, NotificationChannelUncheckedUpdateWithoutTenantInput>
    create: XOR<NotificationChannelCreateWithoutTenantInput, NotificationChannelUncheckedCreateWithoutTenantInput>
  }

  export type NotificationChannelUpdateWithWhereUniqueWithoutTenantInput = {
    where: NotificationChannelWhereUniqueInput
    data: XOR<NotificationChannelUpdateWithoutTenantInput, NotificationChannelUncheckedUpdateWithoutTenantInput>
  }

  export type NotificationChannelUpdateManyWithWhereWithoutTenantInput = {
    where: NotificationChannelScalarWhereInput
    data: XOR<NotificationChannelUpdateManyMutationInput, NotificationChannelUncheckedUpdateManyWithoutTenantInput>
  }

  export type NotificationChannelScalarWhereInput = {
    AND?: NotificationChannelScalarWhereInput | NotificationChannelScalarWhereInput[]
    OR?: NotificationChannelScalarWhereInput[]
    NOT?: NotificationChannelScalarWhereInput | NotificationChannelScalarWhereInput[]
    id?: StringFilter<"NotificationChannel"> | string
    tenantId?: StringFilter<"NotificationChannel"> | string
    type?: EnumNotificationChannelTypeFilter<"NotificationChannel"> | $Enums.NotificationChannelType
    config?: JsonFilter<"NotificationChannel">
    enabled?: BoolFilter<"NotificationChannel"> | boolean
    createdAt?: DateTimeFilter<"NotificationChannel"> | Date | string
    updatedAt?: DateTimeFilter<"NotificationChannel"> | Date | string
  }

  export type NotificationEventUpsertWithWhereUniqueWithoutTenantInput = {
    where: NotificationEventWhereUniqueInput
    update: XOR<NotificationEventUpdateWithoutTenantInput, NotificationEventUncheckedUpdateWithoutTenantInput>
    create: XOR<NotificationEventCreateWithoutTenantInput, NotificationEventUncheckedCreateWithoutTenantInput>
  }

  export type NotificationEventUpdateWithWhereUniqueWithoutTenantInput = {
    where: NotificationEventWhereUniqueInput
    data: XOR<NotificationEventUpdateWithoutTenantInput, NotificationEventUncheckedUpdateWithoutTenantInput>
  }

  export type NotificationEventUpdateManyWithWhereWithoutTenantInput = {
    where: NotificationEventScalarWhereInput
    data: XOR<NotificationEventUpdateManyMutationInput, NotificationEventUncheckedUpdateManyWithoutTenantInput>
  }

  export type NotificationEventScalarWhereInput = {
    AND?: NotificationEventScalarWhereInput | NotificationEventScalarWhereInput[]
    OR?: NotificationEventScalarWhereInput[]
    NOT?: NotificationEventScalarWhereInput | NotificationEventScalarWhereInput[]
    id?: StringFilter<"NotificationEvent"> | string
    tenantId?: StringFilter<"NotificationEvent"> | string
    channelId?: StringFilter<"NotificationEvent"> | string
    alertEventId?: StringNullableFilter<"NotificationEvent"> | string | null
    status?: EnumNotificationEventStatusFilter<"NotificationEvent"> | $Enums.NotificationEventStatus
    payload?: JsonFilter<"NotificationEvent">
    sentAt?: DateTimeNullableFilter<"NotificationEvent"> | Date | string | null
    errorMsg?: StringNullableFilter<"NotificationEvent"> | string | null
    createdAt?: DateTimeFilter<"NotificationEvent"> | Date | string
  }

  export type DailyRollupUpsertWithWhereUniqueWithoutTenantInput = {
    where: DailyRollupWhereUniqueInput
    update: XOR<DailyRollupUpdateWithoutTenantInput, DailyRollupUncheckedUpdateWithoutTenantInput>
    create: XOR<DailyRollupCreateWithoutTenantInput, DailyRollupUncheckedCreateWithoutTenantInput>
  }

  export type DailyRollupUpdateWithWhereUniqueWithoutTenantInput = {
    where: DailyRollupWhereUniqueInput
    data: XOR<DailyRollupUpdateWithoutTenantInput, DailyRollupUncheckedUpdateWithoutTenantInput>
  }

  export type DailyRollupUpdateManyWithWhereWithoutTenantInput = {
    where: DailyRollupScalarWhereInput
    data: XOR<DailyRollupUpdateManyMutationInput, DailyRollupUncheckedUpdateManyWithoutTenantInput>
  }

  export type DailyRollupScalarWhereInput = {
    AND?: DailyRollupScalarWhereInput | DailyRollupScalarWhereInput[]
    OR?: DailyRollupScalarWhereInput[]
    NOT?: DailyRollupScalarWhereInput | DailyRollupScalarWhereInput[]
    id?: StringFilter<"DailyRollup"> | string
    tenantId?: StringFilter<"DailyRollup"> | string
    deviceId?: StringFilter<"DailyRollup"> | string
    dayDate?: DateTimeFilter<"DailyRollup"> | Date | string
    energyKwhDay?: FloatNullableFilter<"DailyRollup"> | number | null
    hotWaterUsageLitersDay?: FloatNullableFilter<"DailyRollup"> | number | null
    heaterOnMinutesDay?: FloatNullableFilter<"DailyRollup"> | number | null
    tankTempMinC?: FloatNullableFilter<"DailyRollup"> | number | null
    tankTempMaxC?: FloatNullableFilter<"DailyRollup"> | number | null
    ambientTempAvgC?: FloatNullableFilter<"DailyRollup"> | number | null
    createdAt?: DateTimeFilter<"DailyRollup"> | Date | string
  }

  export type EntitlementUpsertWithWhereUniqueWithoutTenantInput = {
    where: EntitlementWhereUniqueInput
    update: XOR<EntitlementUpdateWithoutTenantInput, EntitlementUncheckedUpdateWithoutTenantInput>
    create: XOR<EntitlementCreateWithoutTenantInput, EntitlementUncheckedCreateWithoutTenantInput>
  }

  export type EntitlementUpdateWithWhereUniqueWithoutTenantInput = {
    where: EntitlementWhereUniqueInput
    data: XOR<EntitlementUpdateWithoutTenantInput, EntitlementUncheckedUpdateWithoutTenantInput>
  }

  export type EntitlementUpdateManyWithWhereWithoutTenantInput = {
    where: EntitlementScalarWhereInput
    data: XOR<EntitlementUpdateManyMutationInput, EntitlementUncheckedUpdateManyWithoutTenantInput>
  }

  export type EntitlementScalarWhereInput = {
    AND?: EntitlementScalarWhereInput | EntitlementScalarWhereInput[]
    OR?: EntitlementScalarWhereInput[]
    NOT?: EntitlementScalarWhereInput | EntitlementScalarWhereInput[]
    id?: StringFilter<"Entitlement"> | string
    tenantId?: StringFilter<"Entitlement"> | string
    scope?: EnumEntitlementScopeFilter<"Entitlement"> | $Enums.EntitlementScope
    deviceId?: StringNullableFilter<"Entitlement"> | string | null
    key?: EnumEntitlementKeyFilter<"Entitlement"> | $Enums.EntitlementKey
    enabled?: BoolFilter<"Entitlement"> | boolean
    updatedAt?: DateTimeFilter<"Entitlement"> | Date | string
  }

  export type AuditLogUpsertWithWhereUniqueWithoutTenantInput = {
    where: AuditLogWhereUniqueInput
    update: XOR<AuditLogUpdateWithoutTenantInput, AuditLogUncheckedUpdateWithoutTenantInput>
    create: XOR<AuditLogCreateWithoutTenantInput, AuditLogUncheckedCreateWithoutTenantInput>
  }

  export type AuditLogUpdateWithWhereUniqueWithoutTenantInput = {
    where: AuditLogWhereUniqueInput
    data: XOR<AuditLogUpdateWithoutTenantInput, AuditLogUncheckedUpdateWithoutTenantInput>
  }

  export type AuditLogUpdateManyWithWhereWithoutTenantInput = {
    where: AuditLogScalarWhereInput
    data: XOR<AuditLogUpdateManyMutationInput, AuditLogUncheckedUpdateManyWithoutTenantInput>
  }

  export type AuditLogScalarWhereInput = {
    AND?: AuditLogScalarWhereInput | AuditLogScalarWhereInput[]
    OR?: AuditLogScalarWhereInput[]
    NOT?: AuditLogScalarWhereInput | AuditLogScalarWhereInput[]
    id?: StringFilter<"AuditLog"> | string
    tenantId?: StringNullableFilter<"AuditLog"> | string | null
    actorUserId?: StringNullableFilter<"AuditLog"> | string | null
    actorType?: EnumActorTypeFilter<"AuditLog"> | $Enums.ActorType
    action?: StringFilter<"AuditLog"> | string
    entityType?: StringFilter<"AuditLog"> | string
    entityId?: StringFilter<"AuditLog"> | string
    metadata?: JsonNullableFilter<"AuditLog">
    createdAt?: DateTimeFilter<"AuditLog"> | Date | string
  }

  export type OtaJobUpsertWithWhereUniqueWithoutTenantInput = {
    where: OtaJobWhereUniqueInput
    update: XOR<OtaJobUpdateWithoutTenantInput, OtaJobUncheckedUpdateWithoutTenantInput>
    create: XOR<OtaJobCreateWithoutTenantInput, OtaJobUncheckedCreateWithoutTenantInput>
  }

  export type OtaJobUpdateWithWhereUniqueWithoutTenantInput = {
    where: OtaJobWhereUniqueInput
    data: XOR<OtaJobUpdateWithoutTenantInput, OtaJobUncheckedUpdateWithoutTenantInput>
  }

  export type OtaJobUpdateManyWithWhereWithoutTenantInput = {
    where: OtaJobScalarWhereInput
    data: XOR<OtaJobUpdateManyMutationInput, OtaJobUncheckedUpdateManyWithoutTenantInput>
  }

  export type OtaJobScalarWhereInput = {
    AND?: OtaJobScalarWhereInput | OtaJobScalarWhereInput[]
    OR?: OtaJobScalarWhereInput[]
    NOT?: OtaJobScalarWhereInput | OtaJobScalarWhereInput[]
    id?: StringFilter<"OtaJob"> | string
    tenantId?: StringFilter<"OtaJob"> | string
    targetType?: EnumOtaTargetTypeFilter<"OtaJob"> | $Enums.OtaTargetType
    deviceId?: StringNullableFilter<"OtaJob"> | string | null
    groupFilter?: JsonNullableFilter<"OtaJob">
    firmwarePackageId?: StringFilter<"OtaJob"> | string
    status?: EnumOtaJobStatusFilter<"OtaJob"> | $Enums.OtaJobStatus
    scheduledAt?: DateTimeFilter<"OtaJob"> | Date | string
    startedAt?: DateTimeNullableFilter<"OtaJob"> | Date | string | null
    finishedAt?: DateTimeNullableFilter<"OtaJob"> | Date | string | null
    createdByUserId?: StringNullableFilter<"OtaJob"> | string | null
    progress?: JsonNullableFilter<"OtaJob">
    createdAt?: DateTimeFilter<"OtaJob"> | Date | string
  }

  export type WeatherDataUpsertWithWhereUniqueWithoutTenantInput = {
    where: WeatherDataWhereUniqueInput
    update: XOR<WeatherDataUpdateWithoutTenantInput, WeatherDataUncheckedUpdateWithoutTenantInput>
    create: XOR<WeatherDataCreateWithoutTenantInput, WeatherDataUncheckedCreateWithoutTenantInput>
  }

  export type WeatherDataUpdateWithWhereUniqueWithoutTenantInput = {
    where: WeatherDataWhereUniqueInput
    data: XOR<WeatherDataUpdateWithoutTenantInput, WeatherDataUncheckedUpdateWithoutTenantInput>
  }

  export type WeatherDataUpdateManyWithWhereWithoutTenantInput = {
    where: WeatherDataScalarWhereInput
    data: XOR<WeatherDataUpdateManyMutationInput, WeatherDataUncheckedUpdateManyWithoutTenantInput>
  }

  export type WeatherDataScalarWhereInput = {
    AND?: WeatherDataScalarWhereInput | WeatherDataScalarWhereInput[]
    OR?: WeatherDataScalarWhereInput[]
    NOT?: WeatherDataScalarWhereInput | WeatherDataScalarWhereInput[]
    id?: StringFilter<"WeatherData"> | string
    tenantId?: StringFilter<"WeatherData"> | string
    siteId?: StringFilter<"WeatherData"> | string
    date?: DateTimeFilter<"WeatherData"> | Date | string
    summary?: JsonFilter<"WeatherData">
    createdAt?: DateTimeFilter<"WeatherData"> | Date | string
  }

  export type MembershipCreateWithoutUserInput = {
    id?: string
    role: $Enums.MembershipRole
    createdAt?: Date | string
    tenant: TenantCreateNestedOneWithoutMembershipsInput
  }

  export type MembershipUncheckedCreateWithoutUserInput = {
    id?: string
    tenantId: string
    role: $Enums.MembershipRole
    createdAt?: Date | string
  }

  export type MembershipCreateOrConnectWithoutUserInput = {
    where: MembershipWhereUniqueInput
    create: XOR<MembershipCreateWithoutUserInput, MembershipUncheckedCreateWithoutUserInput>
  }

  export type MembershipCreateManyUserInputEnvelope = {
    data: MembershipCreateManyUserInput | MembershipCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type CommandCreateWithoutRequestedByInput = {
    id?: string
    type: $Enums.CommandType
    payload: JsonNullValueInput | InputJsonValue
    status?: $Enums.CommandStatus
    requestedAt?: Date | string
    deliveredAt?: Date | string | null
    ackAt?: Date | string | null
    errorMsg?: string | null
    device: DeviceCreateNestedOneWithoutCommandsInput
  }

  export type CommandUncheckedCreateWithoutRequestedByInput = {
    id?: string
    deviceId: string
    type: $Enums.CommandType
    payload: JsonNullValueInput | InputJsonValue
    status?: $Enums.CommandStatus
    requestedAt?: Date | string
    deliveredAt?: Date | string | null
    ackAt?: Date | string | null
    errorMsg?: string | null
  }

  export type CommandCreateOrConnectWithoutRequestedByInput = {
    where: CommandWhereUniqueInput
    create: XOR<CommandCreateWithoutRequestedByInput, CommandUncheckedCreateWithoutRequestedByInput>
  }

  export type CommandCreateManyRequestedByInputEnvelope = {
    data: CommandCreateManyRequestedByInput | CommandCreateManyRequestedByInput[]
    skipDuplicates?: boolean
  }

  export type OtaJobCreateWithoutCreatedByInput = {
    id?: string
    targetType: $Enums.OtaTargetType
    deviceId?: string | null
    groupFilter?: NullableJsonNullValueInput | InputJsonValue
    status?: $Enums.OtaJobStatus
    scheduledAt: Date | string
    startedAt?: Date | string | null
    finishedAt?: Date | string | null
    progress?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    tenant: TenantCreateNestedOneWithoutOtaJobsInput
    firmwarePackage: FirmwarePackageCreateNestedOneWithoutOtaJobsInput
  }

  export type OtaJobUncheckedCreateWithoutCreatedByInput = {
    id?: string
    tenantId: string
    targetType: $Enums.OtaTargetType
    deviceId?: string | null
    groupFilter?: NullableJsonNullValueInput | InputJsonValue
    firmwarePackageId: string
    status?: $Enums.OtaJobStatus
    scheduledAt: Date | string
    startedAt?: Date | string | null
    finishedAt?: Date | string | null
    progress?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type OtaJobCreateOrConnectWithoutCreatedByInput = {
    where: OtaJobWhereUniqueInput
    create: XOR<OtaJobCreateWithoutCreatedByInput, OtaJobUncheckedCreateWithoutCreatedByInput>
  }

  export type OtaJobCreateManyCreatedByInputEnvelope = {
    data: OtaJobCreateManyCreatedByInput | OtaJobCreateManyCreatedByInput[]
    skipDuplicates?: boolean
  }

  export type SimActionCreateWithoutRequestedByInput = {
    id?: string
    action: $Enums.SimActionType
    requestedAt?: Date | string
    status?: $Enums.SimActionStatus
    providerRef?: string | null
    errorMsg?: string | null
    sim: SimInfoCreateNestedOneWithoutSimActionsInput
  }

  export type SimActionUncheckedCreateWithoutRequestedByInput = {
    id?: string
    iccid: string
    action: $Enums.SimActionType
    requestedAt?: Date | string
    status?: $Enums.SimActionStatus
    providerRef?: string | null
    errorMsg?: string | null
  }

  export type SimActionCreateOrConnectWithoutRequestedByInput = {
    where: SimActionWhereUniqueInput
    create: XOR<SimActionCreateWithoutRequestedByInput, SimActionUncheckedCreateWithoutRequestedByInput>
  }

  export type SimActionCreateManyRequestedByInputEnvelope = {
    data: SimActionCreateManyRequestedByInput | SimActionCreateManyRequestedByInput[]
    skipDuplicates?: boolean
  }

  export type SiteCreateWithoutLocationUpdatedByInput = {
    id?: string
    name: string
    addressLine1?: string | null
    addressLine2?: string | null
    city?: string | null
    region?: string | null
    postalCode?: string | null
    country?: string | null
    lat?: number | null
    lon?: number | null
    locationSource?: $Enums.LocationSource | null
    locationAccuracyM?: number | null
    locationConfidence?: number | null
    locationUpdatedAt?: Date | string | null
    locationLock?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    tenant: TenantCreateNestedOneWithoutSitesInput
    devices?: DeviceCreateNestedManyWithoutSiteInput
    weatherData?: WeatherDataCreateNestedManyWithoutSiteInput
  }

  export type SiteUncheckedCreateWithoutLocationUpdatedByInput = {
    id?: string
    tenantId: string
    name: string
    addressLine1?: string | null
    addressLine2?: string | null
    city?: string | null
    region?: string | null
    postalCode?: string | null
    country?: string | null
    lat?: number | null
    lon?: number | null
    locationSource?: $Enums.LocationSource | null
    locationAccuracyM?: number | null
    locationConfidence?: number | null
    locationUpdatedAt?: Date | string | null
    locationLock?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    devices?: DeviceUncheckedCreateNestedManyWithoutSiteInput
    weatherData?: WeatherDataUncheckedCreateNestedManyWithoutSiteInput
  }

  export type SiteCreateOrConnectWithoutLocationUpdatedByInput = {
    where: SiteWhereUniqueInput
    create: XOR<SiteCreateWithoutLocationUpdatedByInput, SiteUncheckedCreateWithoutLocationUpdatedByInput>
  }

  export type SiteCreateManyLocationUpdatedByInputEnvelope = {
    data: SiteCreateManyLocationUpdatedByInput | SiteCreateManyLocationUpdatedByInput[]
    skipDuplicates?: boolean
  }

  export type MembershipUpsertWithWhereUniqueWithoutUserInput = {
    where: MembershipWhereUniqueInput
    update: XOR<MembershipUpdateWithoutUserInput, MembershipUncheckedUpdateWithoutUserInput>
    create: XOR<MembershipCreateWithoutUserInput, MembershipUncheckedCreateWithoutUserInput>
  }

  export type MembershipUpdateWithWhereUniqueWithoutUserInput = {
    where: MembershipWhereUniqueInput
    data: XOR<MembershipUpdateWithoutUserInput, MembershipUncheckedUpdateWithoutUserInput>
  }

  export type MembershipUpdateManyWithWhereWithoutUserInput = {
    where: MembershipScalarWhereInput
    data: XOR<MembershipUpdateManyMutationInput, MembershipUncheckedUpdateManyWithoutUserInput>
  }

  export type CommandUpsertWithWhereUniqueWithoutRequestedByInput = {
    where: CommandWhereUniqueInput
    update: XOR<CommandUpdateWithoutRequestedByInput, CommandUncheckedUpdateWithoutRequestedByInput>
    create: XOR<CommandCreateWithoutRequestedByInput, CommandUncheckedCreateWithoutRequestedByInput>
  }

  export type CommandUpdateWithWhereUniqueWithoutRequestedByInput = {
    where: CommandWhereUniqueInput
    data: XOR<CommandUpdateWithoutRequestedByInput, CommandUncheckedUpdateWithoutRequestedByInput>
  }

  export type CommandUpdateManyWithWhereWithoutRequestedByInput = {
    where: CommandScalarWhereInput
    data: XOR<CommandUpdateManyMutationInput, CommandUncheckedUpdateManyWithoutRequestedByInput>
  }

  export type CommandScalarWhereInput = {
    AND?: CommandScalarWhereInput | CommandScalarWhereInput[]
    OR?: CommandScalarWhereInput[]
    NOT?: CommandScalarWhereInput | CommandScalarWhereInput[]
    id?: StringFilter<"Command"> | string
    deviceId?: StringFilter<"Command"> | string
    type?: EnumCommandTypeFilter<"Command"> | $Enums.CommandType
    payload?: JsonFilter<"Command">
    status?: EnumCommandStatusFilter<"Command"> | $Enums.CommandStatus
    requestedByUserId?: StringNullableFilter<"Command"> | string | null
    requestedAt?: DateTimeFilter<"Command"> | Date | string
    deliveredAt?: DateTimeNullableFilter<"Command"> | Date | string | null
    ackAt?: DateTimeNullableFilter<"Command"> | Date | string | null
    errorMsg?: StringNullableFilter<"Command"> | string | null
  }

  export type OtaJobUpsertWithWhereUniqueWithoutCreatedByInput = {
    where: OtaJobWhereUniqueInput
    update: XOR<OtaJobUpdateWithoutCreatedByInput, OtaJobUncheckedUpdateWithoutCreatedByInput>
    create: XOR<OtaJobCreateWithoutCreatedByInput, OtaJobUncheckedCreateWithoutCreatedByInput>
  }

  export type OtaJobUpdateWithWhereUniqueWithoutCreatedByInput = {
    where: OtaJobWhereUniqueInput
    data: XOR<OtaJobUpdateWithoutCreatedByInput, OtaJobUncheckedUpdateWithoutCreatedByInput>
  }

  export type OtaJobUpdateManyWithWhereWithoutCreatedByInput = {
    where: OtaJobScalarWhereInput
    data: XOR<OtaJobUpdateManyMutationInput, OtaJobUncheckedUpdateManyWithoutCreatedByInput>
  }

  export type SimActionUpsertWithWhereUniqueWithoutRequestedByInput = {
    where: SimActionWhereUniqueInput
    update: XOR<SimActionUpdateWithoutRequestedByInput, SimActionUncheckedUpdateWithoutRequestedByInput>
    create: XOR<SimActionCreateWithoutRequestedByInput, SimActionUncheckedCreateWithoutRequestedByInput>
  }

  export type SimActionUpdateWithWhereUniqueWithoutRequestedByInput = {
    where: SimActionWhereUniqueInput
    data: XOR<SimActionUpdateWithoutRequestedByInput, SimActionUncheckedUpdateWithoutRequestedByInput>
  }

  export type SimActionUpdateManyWithWhereWithoutRequestedByInput = {
    where: SimActionScalarWhereInput
    data: XOR<SimActionUpdateManyMutationInput, SimActionUncheckedUpdateManyWithoutRequestedByInput>
  }

  export type SimActionScalarWhereInput = {
    AND?: SimActionScalarWhereInput | SimActionScalarWhereInput[]
    OR?: SimActionScalarWhereInput[]
    NOT?: SimActionScalarWhereInput | SimActionScalarWhereInput[]
    id?: StringFilter<"SimAction"> | string
    iccid?: StringFilter<"SimAction"> | string
    action?: EnumSimActionTypeFilter<"SimAction"> | $Enums.SimActionType
    requestedByUserId?: StringNullableFilter<"SimAction"> | string | null
    requestedAt?: DateTimeFilter<"SimAction"> | Date | string
    status?: EnumSimActionStatusFilter<"SimAction"> | $Enums.SimActionStatus
    providerRef?: StringNullableFilter<"SimAction"> | string | null
    errorMsg?: StringNullableFilter<"SimAction"> | string | null
  }

  export type SiteUpsertWithWhereUniqueWithoutLocationUpdatedByInput = {
    where: SiteWhereUniqueInput
    update: XOR<SiteUpdateWithoutLocationUpdatedByInput, SiteUncheckedUpdateWithoutLocationUpdatedByInput>
    create: XOR<SiteCreateWithoutLocationUpdatedByInput, SiteUncheckedCreateWithoutLocationUpdatedByInput>
  }

  export type SiteUpdateWithWhereUniqueWithoutLocationUpdatedByInput = {
    where: SiteWhereUniqueInput
    data: XOR<SiteUpdateWithoutLocationUpdatedByInput, SiteUncheckedUpdateWithoutLocationUpdatedByInput>
  }

  export type SiteUpdateManyWithWhereWithoutLocationUpdatedByInput = {
    where: SiteScalarWhereInput
    data: XOR<SiteUpdateManyMutationInput, SiteUncheckedUpdateManyWithoutLocationUpdatedByInput>
  }

  export type UserCreateWithoutMembershipsInput = {
    id?: string
    email: string
    passwordHash: string
    name: string
    status?: $Enums.UserStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    commands?: CommandCreateNestedManyWithoutRequestedByInput
    otaJobs?: OtaJobCreateNestedManyWithoutCreatedByInput
    simActions?: SimActionCreateNestedManyWithoutRequestedByInput
    siteLocUpdates?: SiteCreateNestedManyWithoutLocationUpdatedByInput
  }

  export type UserUncheckedCreateWithoutMembershipsInput = {
    id?: string
    email: string
    passwordHash: string
    name: string
    status?: $Enums.UserStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    commands?: CommandUncheckedCreateNestedManyWithoutRequestedByInput
    otaJobs?: OtaJobUncheckedCreateNestedManyWithoutCreatedByInput
    simActions?: SimActionUncheckedCreateNestedManyWithoutRequestedByInput
    siteLocUpdates?: SiteUncheckedCreateNestedManyWithoutLocationUpdatedByInput
  }

  export type UserCreateOrConnectWithoutMembershipsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutMembershipsInput, UserUncheckedCreateWithoutMembershipsInput>
  }

  export type TenantCreateWithoutMembershipsInput = {
    id?: string
    name: string
    type: $Enums.TenantType
    status?: $Enums.TenantStatus
    settings?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    sites?: SiteCreateNestedManyWithoutTenantInput
    devices?: DeviceCreateNestedManyWithoutTenantInput
    alertRules?: AlertRuleCreateNestedManyWithoutTenantInput
    alertEvents?: AlertEventCreateNestedManyWithoutTenantInput
    notificationChannels?: NotificationChannelCreateNestedManyWithoutTenantInput
    notificationEvents?: NotificationEventCreateNestedManyWithoutTenantInput
    dailyRollups?: DailyRollupCreateNestedManyWithoutTenantInput
    entitlements?: EntitlementCreateNestedManyWithoutTenantInput
    auditLogs?: AuditLogCreateNestedManyWithoutTenantInput
    otaJobs?: OtaJobCreateNestedManyWithoutTenantInput
    weatherData?: WeatherDataCreateNestedManyWithoutTenantInput
  }

  export type TenantUncheckedCreateWithoutMembershipsInput = {
    id?: string
    name: string
    type: $Enums.TenantType
    status?: $Enums.TenantStatus
    settings?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    sites?: SiteUncheckedCreateNestedManyWithoutTenantInput
    devices?: DeviceUncheckedCreateNestedManyWithoutTenantInput
    alertRules?: AlertRuleUncheckedCreateNestedManyWithoutTenantInput
    alertEvents?: AlertEventUncheckedCreateNestedManyWithoutTenantInput
    notificationChannels?: NotificationChannelUncheckedCreateNestedManyWithoutTenantInput
    notificationEvents?: NotificationEventUncheckedCreateNestedManyWithoutTenantInput
    dailyRollups?: DailyRollupUncheckedCreateNestedManyWithoutTenantInput
    entitlements?: EntitlementUncheckedCreateNestedManyWithoutTenantInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutTenantInput
    otaJobs?: OtaJobUncheckedCreateNestedManyWithoutTenantInput
    weatherData?: WeatherDataUncheckedCreateNestedManyWithoutTenantInput
  }

  export type TenantCreateOrConnectWithoutMembershipsInput = {
    where: TenantWhereUniqueInput
    create: XOR<TenantCreateWithoutMembershipsInput, TenantUncheckedCreateWithoutMembershipsInput>
  }

  export type UserUpsertWithoutMembershipsInput = {
    update: XOR<UserUpdateWithoutMembershipsInput, UserUncheckedUpdateWithoutMembershipsInput>
    create: XOR<UserCreateWithoutMembershipsInput, UserUncheckedCreateWithoutMembershipsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutMembershipsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutMembershipsInput, UserUncheckedUpdateWithoutMembershipsInput>
  }

  export type UserUpdateWithoutMembershipsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    status?: EnumUserStatusFieldUpdateOperationsInput | $Enums.UserStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    commands?: CommandUpdateManyWithoutRequestedByNestedInput
    otaJobs?: OtaJobUpdateManyWithoutCreatedByNestedInput
    simActions?: SimActionUpdateManyWithoutRequestedByNestedInput
    siteLocUpdates?: SiteUpdateManyWithoutLocationUpdatedByNestedInput
  }

  export type UserUncheckedUpdateWithoutMembershipsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    status?: EnumUserStatusFieldUpdateOperationsInput | $Enums.UserStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    commands?: CommandUncheckedUpdateManyWithoutRequestedByNestedInput
    otaJobs?: OtaJobUncheckedUpdateManyWithoutCreatedByNestedInput
    simActions?: SimActionUncheckedUpdateManyWithoutRequestedByNestedInput
    siteLocUpdates?: SiteUncheckedUpdateManyWithoutLocationUpdatedByNestedInput
  }

  export type TenantUpsertWithoutMembershipsInput = {
    update: XOR<TenantUpdateWithoutMembershipsInput, TenantUncheckedUpdateWithoutMembershipsInput>
    create: XOR<TenantCreateWithoutMembershipsInput, TenantUncheckedCreateWithoutMembershipsInput>
    where?: TenantWhereInput
  }

  export type TenantUpdateToOneWithWhereWithoutMembershipsInput = {
    where?: TenantWhereInput
    data: XOR<TenantUpdateWithoutMembershipsInput, TenantUncheckedUpdateWithoutMembershipsInput>
  }

  export type TenantUpdateWithoutMembershipsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumTenantTypeFieldUpdateOperationsInput | $Enums.TenantType
    status?: EnumTenantStatusFieldUpdateOperationsInput | $Enums.TenantStatus
    settings?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sites?: SiteUpdateManyWithoutTenantNestedInput
    devices?: DeviceUpdateManyWithoutTenantNestedInput
    alertRules?: AlertRuleUpdateManyWithoutTenantNestedInput
    alertEvents?: AlertEventUpdateManyWithoutTenantNestedInput
    notificationChannels?: NotificationChannelUpdateManyWithoutTenantNestedInput
    notificationEvents?: NotificationEventUpdateManyWithoutTenantNestedInput
    dailyRollups?: DailyRollupUpdateManyWithoutTenantNestedInput
    entitlements?: EntitlementUpdateManyWithoutTenantNestedInput
    auditLogs?: AuditLogUpdateManyWithoutTenantNestedInput
    otaJobs?: OtaJobUpdateManyWithoutTenantNestedInput
    weatherData?: WeatherDataUpdateManyWithoutTenantNestedInput
  }

  export type TenantUncheckedUpdateWithoutMembershipsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumTenantTypeFieldUpdateOperationsInput | $Enums.TenantType
    status?: EnumTenantStatusFieldUpdateOperationsInput | $Enums.TenantStatus
    settings?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sites?: SiteUncheckedUpdateManyWithoutTenantNestedInput
    devices?: DeviceUncheckedUpdateManyWithoutTenantNestedInput
    alertRules?: AlertRuleUncheckedUpdateManyWithoutTenantNestedInput
    alertEvents?: AlertEventUncheckedUpdateManyWithoutTenantNestedInput
    notificationChannels?: NotificationChannelUncheckedUpdateManyWithoutTenantNestedInput
    notificationEvents?: NotificationEventUncheckedUpdateManyWithoutTenantNestedInput
    dailyRollups?: DailyRollupUncheckedUpdateManyWithoutTenantNestedInput
    entitlements?: EntitlementUncheckedUpdateManyWithoutTenantNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutTenantNestedInput
    otaJobs?: OtaJobUncheckedUpdateManyWithoutTenantNestedInput
    weatherData?: WeatherDataUncheckedUpdateManyWithoutTenantNestedInput
  }

  export type TenantCreateWithoutSitesInput = {
    id?: string
    name: string
    type: $Enums.TenantType
    status?: $Enums.TenantStatus
    settings?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    memberships?: MembershipCreateNestedManyWithoutTenantInput
    devices?: DeviceCreateNestedManyWithoutTenantInput
    alertRules?: AlertRuleCreateNestedManyWithoutTenantInput
    alertEvents?: AlertEventCreateNestedManyWithoutTenantInput
    notificationChannels?: NotificationChannelCreateNestedManyWithoutTenantInput
    notificationEvents?: NotificationEventCreateNestedManyWithoutTenantInput
    dailyRollups?: DailyRollupCreateNestedManyWithoutTenantInput
    entitlements?: EntitlementCreateNestedManyWithoutTenantInput
    auditLogs?: AuditLogCreateNestedManyWithoutTenantInput
    otaJobs?: OtaJobCreateNestedManyWithoutTenantInput
    weatherData?: WeatherDataCreateNestedManyWithoutTenantInput
  }

  export type TenantUncheckedCreateWithoutSitesInput = {
    id?: string
    name: string
    type: $Enums.TenantType
    status?: $Enums.TenantStatus
    settings?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    memberships?: MembershipUncheckedCreateNestedManyWithoutTenantInput
    devices?: DeviceUncheckedCreateNestedManyWithoutTenantInput
    alertRules?: AlertRuleUncheckedCreateNestedManyWithoutTenantInput
    alertEvents?: AlertEventUncheckedCreateNestedManyWithoutTenantInput
    notificationChannels?: NotificationChannelUncheckedCreateNestedManyWithoutTenantInput
    notificationEvents?: NotificationEventUncheckedCreateNestedManyWithoutTenantInput
    dailyRollups?: DailyRollupUncheckedCreateNestedManyWithoutTenantInput
    entitlements?: EntitlementUncheckedCreateNestedManyWithoutTenantInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutTenantInput
    otaJobs?: OtaJobUncheckedCreateNestedManyWithoutTenantInput
    weatherData?: WeatherDataUncheckedCreateNestedManyWithoutTenantInput
  }

  export type TenantCreateOrConnectWithoutSitesInput = {
    where: TenantWhereUniqueInput
    create: XOR<TenantCreateWithoutSitesInput, TenantUncheckedCreateWithoutSitesInput>
  }

  export type UserCreateWithoutSiteLocUpdatesInput = {
    id?: string
    email: string
    passwordHash: string
    name: string
    status?: $Enums.UserStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    memberships?: MembershipCreateNestedManyWithoutUserInput
    commands?: CommandCreateNestedManyWithoutRequestedByInput
    otaJobs?: OtaJobCreateNestedManyWithoutCreatedByInput
    simActions?: SimActionCreateNestedManyWithoutRequestedByInput
  }

  export type UserUncheckedCreateWithoutSiteLocUpdatesInput = {
    id?: string
    email: string
    passwordHash: string
    name: string
    status?: $Enums.UserStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    memberships?: MembershipUncheckedCreateNestedManyWithoutUserInput
    commands?: CommandUncheckedCreateNestedManyWithoutRequestedByInput
    otaJobs?: OtaJobUncheckedCreateNestedManyWithoutCreatedByInput
    simActions?: SimActionUncheckedCreateNestedManyWithoutRequestedByInput
  }

  export type UserCreateOrConnectWithoutSiteLocUpdatesInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutSiteLocUpdatesInput, UserUncheckedCreateWithoutSiteLocUpdatesInput>
  }

  export type DeviceCreateWithoutSiteInput = {
    id?: string
    ownerUserId?: string | null
    model: string
    serialNumber: string
    name?: string | null
    notes?: string | null
    tags?: NullableJsonNullValueInput | InputJsonValue
    status?: $Enums.DeviceStatus
    lastSeenAt?: Date | string | null
    firmwareVersion?: string | null
    deviceLat?: number | null
    deviceLon?: number | null
    deviceLocationTs?: Date | string | null
    deviceLocationSource?: $Enums.DeviceLocationSource | null
    deviceLocationAccuracyM?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    tenant: TenantCreateNestedOneWithoutDevicesInput
    sim?: SimInfoCreateNestedOneWithoutDevicesInput
    secret?: DeviceSecretCreateNestedOneWithoutDeviceInput
    twin?: DeviceTwinCreateNestedOneWithoutDeviceInput
    telemetry?: TelemetryCreateNestedManyWithoutDeviceInput
    commands?: CommandCreateNestedManyWithoutDeviceInput
    alertEvents?: AlertEventCreateNestedManyWithoutDeviceInput
    dailyRollups?: DailyRollupCreateNestedManyWithoutDeviceInput
    entitlements?: EntitlementCreateNestedManyWithoutDeviceInput
  }

  export type DeviceUncheckedCreateWithoutSiteInput = {
    id?: string
    tenantId: string
    ownerUserId?: string | null
    model: string
    serialNumber: string
    name?: string | null
    notes?: string | null
    tags?: NullableJsonNullValueInput | InputJsonValue
    status?: $Enums.DeviceStatus
    lastSeenAt?: Date | string | null
    firmwareVersion?: string | null
    simIccid?: string | null
    deviceLat?: number | null
    deviceLon?: number | null
    deviceLocationTs?: Date | string | null
    deviceLocationSource?: $Enums.DeviceLocationSource | null
    deviceLocationAccuracyM?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    secret?: DeviceSecretUncheckedCreateNestedOneWithoutDeviceInput
    twin?: DeviceTwinUncheckedCreateNestedOneWithoutDeviceInput
    telemetry?: TelemetryUncheckedCreateNestedManyWithoutDeviceInput
    commands?: CommandUncheckedCreateNestedManyWithoutDeviceInput
    alertEvents?: AlertEventUncheckedCreateNestedManyWithoutDeviceInput
    dailyRollups?: DailyRollupUncheckedCreateNestedManyWithoutDeviceInput
    entitlements?: EntitlementUncheckedCreateNestedManyWithoutDeviceInput
  }

  export type DeviceCreateOrConnectWithoutSiteInput = {
    where: DeviceWhereUniqueInput
    create: XOR<DeviceCreateWithoutSiteInput, DeviceUncheckedCreateWithoutSiteInput>
  }

  export type DeviceCreateManySiteInputEnvelope = {
    data: DeviceCreateManySiteInput | DeviceCreateManySiteInput[]
    skipDuplicates?: boolean
  }

  export type WeatherDataCreateWithoutSiteInput = {
    id?: string
    date: Date | string
    summary: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    tenant: TenantCreateNestedOneWithoutWeatherDataInput
  }

  export type WeatherDataUncheckedCreateWithoutSiteInput = {
    id?: string
    tenantId: string
    date: Date | string
    summary: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type WeatherDataCreateOrConnectWithoutSiteInput = {
    where: WeatherDataWhereUniqueInput
    create: XOR<WeatherDataCreateWithoutSiteInput, WeatherDataUncheckedCreateWithoutSiteInput>
  }

  export type WeatherDataCreateManySiteInputEnvelope = {
    data: WeatherDataCreateManySiteInput | WeatherDataCreateManySiteInput[]
    skipDuplicates?: boolean
  }

  export type TenantUpsertWithoutSitesInput = {
    update: XOR<TenantUpdateWithoutSitesInput, TenantUncheckedUpdateWithoutSitesInput>
    create: XOR<TenantCreateWithoutSitesInput, TenantUncheckedCreateWithoutSitesInput>
    where?: TenantWhereInput
  }

  export type TenantUpdateToOneWithWhereWithoutSitesInput = {
    where?: TenantWhereInput
    data: XOR<TenantUpdateWithoutSitesInput, TenantUncheckedUpdateWithoutSitesInput>
  }

  export type TenantUpdateWithoutSitesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumTenantTypeFieldUpdateOperationsInput | $Enums.TenantType
    status?: EnumTenantStatusFieldUpdateOperationsInput | $Enums.TenantStatus
    settings?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    memberships?: MembershipUpdateManyWithoutTenantNestedInput
    devices?: DeviceUpdateManyWithoutTenantNestedInput
    alertRules?: AlertRuleUpdateManyWithoutTenantNestedInput
    alertEvents?: AlertEventUpdateManyWithoutTenantNestedInput
    notificationChannels?: NotificationChannelUpdateManyWithoutTenantNestedInput
    notificationEvents?: NotificationEventUpdateManyWithoutTenantNestedInput
    dailyRollups?: DailyRollupUpdateManyWithoutTenantNestedInput
    entitlements?: EntitlementUpdateManyWithoutTenantNestedInput
    auditLogs?: AuditLogUpdateManyWithoutTenantNestedInput
    otaJobs?: OtaJobUpdateManyWithoutTenantNestedInput
    weatherData?: WeatherDataUpdateManyWithoutTenantNestedInput
  }

  export type TenantUncheckedUpdateWithoutSitesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumTenantTypeFieldUpdateOperationsInput | $Enums.TenantType
    status?: EnumTenantStatusFieldUpdateOperationsInput | $Enums.TenantStatus
    settings?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    memberships?: MembershipUncheckedUpdateManyWithoutTenantNestedInput
    devices?: DeviceUncheckedUpdateManyWithoutTenantNestedInput
    alertRules?: AlertRuleUncheckedUpdateManyWithoutTenantNestedInput
    alertEvents?: AlertEventUncheckedUpdateManyWithoutTenantNestedInput
    notificationChannels?: NotificationChannelUncheckedUpdateManyWithoutTenantNestedInput
    notificationEvents?: NotificationEventUncheckedUpdateManyWithoutTenantNestedInput
    dailyRollups?: DailyRollupUncheckedUpdateManyWithoutTenantNestedInput
    entitlements?: EntitlementUncheckedUpdateManyWithoutTenantNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutTenantNestedInput
    otaJobs?: OtaJobUncheckedUpdateManyWithoutTenantNestedInput
    weatherData?: WeatherDataUncheckedUpdateManyWithoutTenantNestedInput
  }

  export type UserUpsertWithoutSiteLocUpdatesInput = {
    update: XOR<UserUpdateWithoutSiteLocUpdatesInput, UserUncheckedUpdateWithoutSiteLocUpdatesInput>
    create: XOR<UserCreateWithoutSiteLocUpdatesInput, UserUncheckedCreateWithoutSiteLocUpdatesInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutSiteLocUpdatesInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutSiteLocUpdatesInput, UserUncheckedUpdateWithoutSiteLocUpdatesInput>
  }

  export type UserUpdateWithoutSiteLocUpdatesInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    status?: EnumUserStatusFieldUpdateOperationsInput | $Enums.UserStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    memberships?: MembershipUpdateManyWithoutUserNestedInput
    commands?: CommandUpdateManyWithoutRequestedByNestedInput
    otaJobs?: OtaJobUpdateManyWithoutCreatedByNestedInput
    simActions?: SimActionUpdateManyWithoutRequestedByNestedInput
  }

  export type UserUncheckedUpdateWithoutSiteLocUpdatesInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    status?: EnumUserStatusFieldUpdateOperationsInput | $Enums.UserStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    memberships?: MembershipUncheckedUpdateManyWithoutUserNestedInput
    commands?: CommandUncheckedUpdateManyWithoutRequestedByNestedInput
    otaJobs?: OtaJobUncheckedUpdateManyWithoutCreatedByNestedInput
    simActions?: SimActionUncheckedUpdateManyWithoutRequestedByNestedInput
  }

  export type DeviceUpsertWithWhereUniqueWithoutSiteInput = {
    where: DeviceWhereUniqueInput
    update: XOR<DeviceUpdateWithoutSiteInput, DeviceUncheckedUpdateWithoutSiteInput>
    create: XOR<DeviceCreateWithoutSiteInput, DeviceUncheckedCreateWithoutSiteInput>
  }

  export type DeviceUpdateWithWhereUniqueWithoutSiteInput = {
    where: DeviceWhereUniqueInput
    data: XOR<DeviceUpdateWithoutSiteInput, DeviceUncheckedUpdateWithoutSiteInput>
  }

  export type DeviceUpdateManyWithWhereWithoutSiteInput = {
    where: DeviceScalarWhereInput
    data: XOR<DeviceUpdateManyMutationInput, DeviceUncheckedUpdateManyWithoutSiteInput>
  }

  export type WeatherDataUpsertWithWhereUniqueWithoutSiteInput = {
    where: WeatherDataWhereUniqueInput
    update: XOR<WeatherDataUpdateWithoutSiteInput, WeatherDataUncheckedUpdateWithoutSiteInput>
    create: XOR<WeatherDataCreateWithoutSiteInput, WeatherDataUncheckedCreateWithoutSiteInput>
  }

  export type WeatherDataUpdateWithWhereUniqueWithoutSiteInput = {
    where: WeatherDataWhereUniqueInput
    data: XOR<WeatherDataUpdateWithoutSiteInput, WeatherDataUncheckedUpdateWithoutSiteInput>
  }

  export type WeatherDataUpdateManyWithWhereWithoutSiteInput = {
    where: WeatherDataScalarWhereInput
    data: XOR<WeatherDataUpdateManyMutationInput, WeatherDataUncheckedUpdateManyWithoutSiteInput>
  }

  export type TenantCreateWithoutDevicesInput = {
    id?: string
    name: string
    type: $Enums.TenantType
    status?: $Enums.TenantStatus
    settings?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    memberships?: MembershipCreateNestedManyWithoutTenantInput
    sites?: SiteCreateNestedManyWithoutTenantInput
    alertRules?: AlertRuleCreateNestedManyWithoutTenantInput
    alertEvents?: AlertEventCreateNestedManyWithoutTenantInput
    notificationChannels?: NotificationChannelCreateNestedManyWithoutTenantInput
    notificationEvents?: NotificationEventCreateNestedManyWithoutTenantInput
    dailyRollups?: DailyRollupCreateNestedManyWithoutTenantInput
    entitlements?: EntitlementCreateNestedManyWithoutTenantInput
    auditLogs?: AuditLogCreateNestedManyWithoutTenantInput
    otaJobs?: OtaJobCreateNestedManyWithoutTenantInput
    weatherData?: WeatherDataCreateNestedManyWithoutTenantInput
  }

  export type TenantUncheckedCreateWithoutDevicesInput = {
    id?: string
    name: string
    type: $Enums.TenantType
    status?: $Enums.TenantStatus
    settings?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    memberships?: MembershipUncheckedCreateNestedManyWithoutTenantInput
    sites?: SiteUncheckedCreateNestedManyWithoutTenantInput
    alertRules?: AlertRuleUncheckedCreateNestedManyWithoutTenantInput
    alertEvents?: AlertEventUncheckedCreateNestedManyWithoutTenantInput
    notificationChannels?: NotificationChannelUncheckedCreateNestedManyWithoutTenantInput
    notificationEvents?: NotificationEventUncheckedCreateNestedManyWithoutTenantInput
    dailyRollups?: DailyRollupUncheckedCreateNestedManyWithoutTenantInput
    entitlements?: EntitlementUncheckedCreateNestedManyWithoutTenantInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutTenantInput
    otaJobs?: OtaJobUncheckedCreateNestedManyWithoutTenantInput
    weatherData?: WeatherDataUncheckedCreateNestedManyWithoutTenantInput
  }

  export type TenantCreateOrConnectWithoutDevicesInput = {
    where: TenantWhereUniqueInput
    create: XOR<TenantCreateWithoutDevicesInput, TenantUncheckedCreateWithoutDevicesInput>
  }

  export type SiteCreateWithoutDevicesInput = {
    id?: string
    name: string
    addressLine1?: string | null
    addressLine2?: string | null
    city?: string | null
    region?: string | null
    postalCode?: string | null
    country?: string | null
    lat?: number | null
    lon?: number | null
    locationSource?: $Enums.LocationSource | null
    locationAccuracyM?: number | null
    locationConfidence?: number | null
    locationUpdatedAt?: Date | string | null
    locationLock?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    tenant: TenantCreateNestedOneWithoutSitesInput
    locationUpdatedBy?: UserCreateNestedOneWithoutSiteLocUpdatesInput
    weatherData?: WeatherDataCreateNestedManyWithoutSiteInput
  }

  export type SiteUncheckedCreateWithoutDevicesInput = {
    id?: string
    tenantId: string
    name: string
    addressLine1?: string | null
    addressLine2?: string | null
    city?: string | null
    region?: string | null
    postalCode?: string | null
    country?: string | null
    lat?: number | null
    lon?: number | null
    locationSource?: $Enums.LocationSource | null
    locationAccuracyM?: number | null
    locationConfidence?: number | null
    locationUpdatedAt?: Date | string | null
    locationUpdatedByUserId?: string | null
    locationLock?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    weatherData?: WeatherDataUncheckedCreateNestedManyWithoutSiteInput
  }

  export type SiteCreateOrConnectWithoutDevicesInput = {
    where: SiteWhereUniqueInput
    create: XOR<SiteCreateWithoutDevicesInput, SiteUncheckedCreateWithoutDevicesInput>
  }

  export type SimInfoCreateWithoutDevicesInput = {
    iccid: string
    carrier?: string | null
    planName?: string | null
    status?: $Enums.SimStatus
    lastSyncAt?: Date | string | null
    dataUsageMb?: number | null
    msisdn?: string | null
    imsi?: string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    simActions?: SimActionCreateNestedManyWithoutSimInput
  }

  export type SimInfoUncheckedCreateWithoutDevicesInput = {
    iccid: string
    carrier?: string | null
    planName?: string | null
    status?: $Enums.SimStatus
    lastSyncAt?: Date | string | null
    dataUsageMb?: number | null
    msisdn?: string | null
    imsi?: string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    simActions?: SimActionUncheckedCreateNestedManyWithoutSimInput
  }

  export type SimInfoCreateOrConnectWithoutDevicesInput = {
    where: SimInfoWhereUniqueInput
    create: XOR<SimInfoCreateWithoutDevicesInput, SimInfoUncheckedCreateWithoutDevicesInput>
  }

  export type DeviceSecretCreateWithoutDeviceInput = {
    id?: string
    secretHash: string
    publicKey?: string | null
    rotatedAt?: Date | string
  }

  export type DeviceSecretUncheckedCreateWithoutDeviceInput = {
    id?: string
    secretHash: string
    publicKey?: string | null
    rotatedAt?: Date | string
  }

  export type DeviceSecretCreateOrConnectWithoutDeviceInput = {
    where: DeviceSecretWhereUniqueInput
    create: XOR<DeviceSecretCreateWithoutDeviceInput, DeviceSecretUncheckedCreateWithoutDeviceInput>
  }

  export type DeviceTwinCreateWithoutDeviceInput = {
    id?: string
    lastTs?: Date | string | null
    derivedState?: JsonNullValueInput | InputJsonValue
    updatedAt?: Date | string
  }

  export type DeviceTwinUncheckedCreateWithoutDeviceInput = {
    id?: string
    lastTs?: Date | string | null
    derivedState?: JsonNullValueInput | InputJsonValue
    updatedAt?: Date | string
  }

  export type DeviceTwinCreateOrConnectWithoutDeviceInput = {
    where: DeviceTwinWhereUniqueInput
    create: XOR<DeviceTwinCreateWithoutDeviceInput, DeviceTwinUncheckedCreateWithoutDeviceInput>
  }

  export type TelemetryCreateWithoutDeviceInput = {
    id?: string
    ts: Date | string
    metrics: JsonNullValueInput | InputJsonValue
    geo?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type TelemetryUncheckedCreateWithoutDeviceInput = {
    id?: string
    ts: Date | string
    metrics: JsonNullValueInput | InputJsonValue
    geo?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type TelemetryCreateOrConnectWithoutDeviceInput = {
    where: TelemetryWhereUniqueInput
    create: XOR<TelemetryCreateWithoutDeviceInput, TelemetryUncheckedCreateWithoutDeviceInput>
  }

  export type TelemetryCreateManyDeviceInputEnvelope = {
    data: TelemetryCreateManyDeviceInput | TelemetryCreateManyDeviceInput[]
    skipDuplicates?: boolean
  }

  export type CommandCreateWithoutDeviceInput = {
    id?: string
    type: $Enums.CommandType
    payload: JsonNullValueInput | InputJsonValue
    status?: $Enums.CommandStatus
    requestedAt?: Date | string
    deliveredAt?: Date | string | null
    ackAt?: Date | string | null
    errorMsg?: string | null
    requestedBy?: UserCreateNestedOneWithoutCommandsInput
  }

  export type CommandUncheckedCreateWithoutDeviceInput = {
    id?: string
    type: $Enums.CommandType
    payload: JsonNullValueInput | InputJsonValue
    status?: $Enums.CommandStatus
    requestedByUserId?: string | null
    requestedAt?: Date | string
    deliveredAt?: Date | string | null
    ackAt?: Date | string | null
    errorMsg?: string | null
  }

  export type CommandCreateOrConnectWithoutDeviceInput = {
    where: CommandWhereUniqueInput
    create: XOR<CommandCreateWithoutDeviceInput, CommandUncheckedCreateWithoutDeviceInput>
  }

  export type CommandCreateManyDeviceInputEnvelope = {
    data: CommandCreateManyDeviceInput | CommandCreateManyDeviceInput[]
    skipDuplicates?: boolean
  }

  export type AlertEventCreateWithoutDeviceInput = {
    id?: string
    severity: $Enums.AlertSeverity
    status?: $Enums.AlertEventStatus
    openedAt?: Date | string
    acknowledgedAt?: Date | string | null
    closedAt?: Date | string | null
    details?: NullableJsonNullValueInput | InputJsonValue
    dedupeKey?: string | null
    tenant: TenantCreateNestedOneWithoutAlertEventsInput
    rule: AlertRuleCreateNestedOneWithoutAlertEventsInput
    notificationEvents?: NotificationEventCreateNestedManyWithoutAlertEventInput
  }

  export type AlertEventUncheckedCreateWithoutDeviceInput = {
    id?: string
    tenantId: string
    ruleId: string
    severity: $Enums.AlertSeverity
    status?: $Enums.AlertEventStatus
    openedAt?: Date | string
    acknowledgedAt?: Date | string | null
    closedAt?: Date | string | null
    details?: NullableJsonNullValueInput | InputJsonValue
    dedupeKey?: string | null
    notificationEvents?: NotificationEventUncheckedCreateNestedManyWithoutAlertEventInput
  }

  export type AlertEventCreateOrConnectWithoutDeviceInput = {
    where: AlertEventWhereUniqueInput
    create: XOR<AlertEventCreateWithoutDeviceInput, AlertEventUncheckedCreateWithoutDeviceInput>
  }

  export type AlertEventCreateManyDeviceInputEnvelope = {
    data: AlertEventCreateManyDeviceInput | AlertEventCreateManyDeviceInput[]
    skipDuplicates?: boolean
  }

  export type DailyRollupCreateWithoutDeviceInput = {
    id?: string
    dayDate: Date | string
    energyKwhDay?: number | null
    hotWaterUsageLitersDay?: number | null
    heaterOnMinutesDay?: number | null
    tankTempMinC?: number | null
    tankTempMaxC?: number | null
    ambientTempAvgC?: number | null
    createdAt?: Date | string
    tenant: TenantCreateNestedOneWithoutDailyRollupsInput
  }

  export type DailyRollupUncheckedCreateWithoutDeviceInput = {
    id?: string
    tenantId: string
    dayDate: Date | string
    energyKwhDay?: number | null
    hotWaterUsageLitersDay?: number | null
    heaterOnMinutesDay?: number | null
    tankTempMinC?: number | null
    tankTempMaxC?: number | null
    ambientTempAvgC?: number | null
    createdAt?: Date | string
  }

  export type DailyRollupCreateOrConnectWithoutDeviceInput = {
    where: DailyRollupWhereUniqueInput
    create: XOR<DailyRollupCreateWithoutDeviceInput, DailyRollupUncheckedCreateWithoutDeviceInput>
  }

  export type DailyRollupCreateManyDeviceInputEnvelope = {
    data: DailyRollupCreateManyDeviceInput | DailyRollupCreateManyDeviceInput[]
    skipDuplicates?: boolean
  }

  export type EntitlementCreateWithoutDeviceInput = {
    id?: string
    scope: $Enums.EntitlementScope
    key: $Enums.EntitlementKey
    enabled?: boolean
    updatedAt?: Date | string
    tenant: TenantCreateNestedOneWithoutEntitlementsInput
  }

  export type EntitlementUncheckedCreateWithoutDeviceInput = {
    id?: string
    tenantId: string
    scope: $Enums.EntitlementScope
    key: $Enums.EntitlementKey
    enabled?: boolean
    updatedAt?: Date | string
  }

  export type EntitlementCreateOrConnectWithoutDeviceInput = {
    where: EntitlementWhereUniqueInput
    create: XOR<EntitlementCreateWithoutDeviceInput, EntitlementUncheckedCreateWithoutDeviceInput>
  }

  export type EntitlementCreateManyDeviceInputEnvelope = {
    data: EntitlementCreateManyDeviceInput | EntitlementCreateManyDeviceInput[]
    skipDuplicates?: boolean
  }

  export type TenantUpsertWithoutDevicesInput = {
    update: XOR<TenantUpdateWithoutDevicesInput, TenantUncheckedUpdateWithoutDevicesInput>
    create: XOR<TenantCreateWithoutDevicesInput, TenantUncheckedCreateWithoutDevicesInput>
    where?: TenantWhereInput
  }

  export type TenantUpdateToOneWithWhereWithoutDevicesInput = {
    where?: TenantWhereInput
    data: XOR<TenantUpdateWithoutDevicesInput, TenantUncheckedUpdateWithoutDevicesInput>
  }

  export type TenantUpdateWithoutDevicesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumTenantTypeFieldUpdateOperationsInput | $Enums.TenantType
    status?: EnumTenantStatusFieldUpdateOperationsInput | $Enums.TenantStatus
    settings?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    memberships?: MembershipUpdateManyWithoutTenantNestedInput
    sites?: SiteUpdateManyWithoutTenantNestedInput
    alertRules?: AlertRuleUpdateManyWithoutTenantNestedInput
    alertEvents?: AlertEventUpdateManyWithoutTenantNestedInput
    notificationChannels?: NotificationChannelUpdateManyWithoutTenantNestedInput
    notificationEvents?: NotificationEventUpdateManyWithoutTenantNestedInput
    dailyRollups?: DailyRollupUpdateManyWithoutTenantNestedInput
    entitlements?: EntitlementUpdateManyWithoutTenantNestedInput
    auditLogs?: AuditLogUpdateManyWithoutTenantNestedInput
    otaJobs?: OtaJobUpdateManyWithoutTenantNestedInput
    weatherData?: WeatherDataUpdateManyWithoutTenantNestedInput
  }

  export type TenantUncheckedUpdateWithoutDevicesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumTenantTypeFieldUpdateOperationsInput | $Enums.TenantType
    status?: EnumTenantStatusFieldUpdateOperationsInput | $Enums.TenantStatus
    settings?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    memberships?: MembershipUncheckedUpdateManyWithoutTenantNestedInput
    sites?: SiteUncheckedUpdateManyWithoutTenantNestedInput
    alertRules?: AlertRuleUncheckedUpdateManyWithoutTenantNestedInput
    alertEvents?: AlertEventUncheckedUpdateManyWithoutTenantNestedInput
    notificationChannels?: NotificationChannelUncheckedUpdateManyWithoutTenantNestedInput
    notificationEvents?: NotificationEventUncheckedUpdateManyWithoutTenantNestedInput
    dailyRollups?: DailyRollupUncheckedUpdateManyWithoutTenantNestedInput
    entitlements?: EntitlementUncheckedUpdateManyWithoutTenantNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutTenantNestedInput
    otaJobs?: OtaJobUncheckedUpdateManyWithoutTenantNestedInput
    weatherData?: WeatherDataUncheckedUpdateManyWithoutTenantNestedInput
  }

  export type SiteUpsertWithoutDevicesInput = {
    update: XOR<SiteUpdateWithoutDevicesInput, SiteUncheckedUpdateWithoutDevicesInput>
    create: XOR<SiteCreateWithoutDevicesInput, SiteUncheckedCreateWithoutDevicesInput>
    where?: SiteWhereInput
  }

  export type SiteUpdateToOneWithWhereWithoutDevicesInput = {
    where?: SiteWhereInput
    data: XOR<SiteUpdateWithoutDevicesInput, SiteUncheckedUpdateWithoutDevicesInput>
  }

  export type SiteUpdateWithoutDevicesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    addressLine1?: NullableStringFieldUpdateOperationsInput | string | null
    addressLine2?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    region?: NullableStringFieldUpdateOperationsInput | string | null
    postalCode?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    lat?: NullableFloatFieldUpdateOperationsInput | number | null
    lon?: NullableFloatFieldUpdateOperationsInput | number | null
    locationSource?: NullableEnumLocationSourceFieldUpdateOperationsInput | $Enums.LocationSource | null
    locationAccuracyM?: NullableFloatFieldUpdateOperationsInput | number | null
    locationConfidence?: NullableFloatFieldUpdateOperationsInput | number | null
    locationUpdatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    locationLock?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tenant?: TenantUpdateOneRequiredWithoutSitesNestedInput
    locationUpdatedBy?: UserUpdateOneWithoutSiteLocUpdatesNestedInput
    weatherData?: WeatherDataUpdateManyWithoutSiteNestedInput
  }

  export type SiteUncheckedUpdateWithoutDevicesInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    addressLine1?: NullableStringFieldUpdateOperationsInput | string | null
    addressLine2?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    region?: NullableStringFieldUpdateOperationsInput | string | null
    postalCode?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    lat?: NullableFloatFieldUpdateOperationsInput | number | null
    lon?: NullableFloatFieldUpdateOperationsInput | number | null
    locationSource?: NullableEnumLocationSourceFieldUpdateOperationsInput | $Enums.LocationSource | null
    locationAccuracyM?: NullableFloatFieldUpdateOperationsInput | number | null
    locationConfidence?: NullableFloatFieldUpdateOperationsInput | number | null
    locationUpdatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    locationUpdatedByUserId?: NullableStringFieldUpdateOperationsInput | string | null
    locationLock?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    weatherData?: WeatherDataUncheckedUpdateManyWithoutSiteNestedInput
  }

  export type SimInfoUpsertWithoutDevicesInput = {
    update: XOR<SimInfoUpdateWithoutDevicesInput, SimInfoUncheckedUpdateWithoutDevicesInput>
    create: XOR<SimInfoCreateWithoutDevicesInput, SimInfoUncheckedCreateWithoutDevicesInput>
    where?: SimInfoWhereInput
  }

  export type SimInfoUpdateToOneWithWhereWithoutDevicesInput = {
    where?: SimInfoWhereInput
    data: XOR<SimInfoUpdateWithoutDevicesInput, SimInfoUncheckedUpdateWithoutDevicesInput>
  }

  export type SimInfoUpdateWithoutDevicesInput = {
    iccid?: StringFieldUpdateOperationsInput | string
    carrier?: NullableStringFieldUpdateOperationsInput | string | null
    planName?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumSimStatusFieldUpdateOperationsInput | $Enums.SimStatus
    lastSyncAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dataUsageMb?: NullableFloatFieldUpdateOperationsInput | number | null
    msisdn?: NullableStringFieldUpdateOperationsInput | string | null
    imsi?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    simActions?: SimActionUpdateManyWithoutSimNestedInput
  }

  export type SimInfoUncheckedUpdateWithoutDevicesInput = {
    iccid?: StringFieldUpdateOperationsInput | string
    carrier?: NullableStringFieldUpdateOperationsInput | string | null
    planName?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumSimStatusFieldUpdateOperationsInput | $Enums.SimStatus
    lastSyncAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dataUsageMb?: NullableFloatFieldUpdateOperationsInput | number | null
    msisdn?: NullableStringFieldUpdateOperationsInput | string | null
    imsi?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    simActions?: SimActionUncheckedUpdateManyWithoutSimNestedInput
  }

  export type DeviceSecretUpsertWithoutDeviceInput = {
    update: XOR<DeviceSecretUpdateWithoutDeviceInput, DeviceSecretUncheckedUpdateWithoutDeviceInput>
    create: XOR<DeviceSecretCreateWithoutDeviceInput, DeviceSecretUncheckedCreateWithoutDeviceInput>
    where?: DeviceSecretWhereInput
  }

  export type DeviceSecretUpdateToOneWithWhereWithoutDeviceInput = {
    where?: DeviceSecretWhereInput
    data: XOR<DeviceSecretUpdateWithoutDeviceInput, DeviceSecretUncheckedUpdateWithoutDeviceInput>
  }

  export type DeviceSecretUpdateWithoutDeviceInput = {
    id?: StringFieldUpdateOperationsInput | string
    secretHash?: StringFieldUpdateOperationsInput | string
    publicKey?: NullableStringFieldUpdateOperationsInput | string | null
    rotatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DeviceSecretUncheckedUpdateWithoutDeviceInput = {
    id?: StringFieldUpdateOperationsInput | string
    secretHash?: StringFieldUpdateOperationsInput | string
    publicKey?: NullableStringFieldUpdateOperationsInput | string | null
    rotatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DeviceTwinUpsertWithoutDeviceInput = {
    update: XOR<DeviceTwinUpdateWithoutDeviceInput, DeviceTwinUncheckedUpdateWithoutDeviceInput>
    create: XOR<DeviceTwinCreateWithoutDeviceInput, DeviceTwinUncheckedCreateWithoutDeviceInput>
    where?: DeviceTwinWhereInput
  }

  export type DeviceTwinUpdateToOneWithWhereWithoutDeviceInput = {
    where?: DeviceTwinWhereInput
    data: XOR<DeviceTwinUpdateWithoutDeviceInput, DeviceTwinUncheckedUpdateWithoutDeviceInput>
  }

  export type DeviceTwinUpdateWithoutDeviceInput = {
    id?: StringFieldUpdateOperationsInput | string
    lastTs?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    derivedState?: JsonNullValueInput | InputJsonValue
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DeviceTwinUncheckedUpdateWithoutDeviceInput = {
    id?: StringFieldUpdateOperationsInput | string
    lastTs?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    derivedState?: JsonNullValueInput | InputJsonValue
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TelemetryUpsertWithWhereUniqueWithoutDeviceInput = {
    where: TelemetryWhereUniqueInput
    update: XOR<TelemetryUpdateWithoutDeviceInput, TelemetryUncheckedUpdateWithoutDeviceInput>
    create: XOR<TelemetryCreateWithoutDeviceInput, TelemetryUncheckedCreateWithoutDeviceInput>
  }

  export type TelemetryUpdateWithWhereUniqueWithoutDeviceInput = {
    where: TelemetryWhereUniqueInput
    data: XOR<TelemetryUpdateWithoutDeviceInput, TelemetryUncheckedUpdateWithoutDeviceInput>
  }

  export type TelemetryUpdateManyWithWhereWithoutDeviceInput = {
    where: TelemetryScalarWhereInput
    data: XOR<TelemetryUpdateManyMutationInput, TelemetryUncheckedUpdateManyWithoutDeviceInput>
  }

  export type TelemetryScalarWhereInput = {
    AND?: TelemetryScalarWhereInput | TelemetryScalarWhereInput[]
    OR?: TelemetryScalarWhereInput[]
    NOT?: TelemetryScalarWhereInput | TelemetryScalarWhereInput[]
    id?: StringFilter<"Telemetry"> | string
    deviceId?: StringFilter<"Telemetry"> | string
    ts?: DateTimeFilter<"Telemetry"> | Date | string
    metrics?: JsonFilter<"Telemetry">
    geo?: JsonNullableFilter<"Telemetry">
    createdAt?: DateTimeFilter<"Telemetry"> | Date | string
  }

  export type CommandUpsertWithWhereUniqueWithoutDeviceInput = {
    where: CommandWhereUniqueInput
    update: XOR<CommandUpdateWithoutDeviceInput, CommandUncheckedUpdateWithoutDeviceInput>
    create: XOR<CommandCreateWithoutDeviceInput, CommandUncheckedCreateWithoutDeviceInput>
  }

  export type CommandUpdateWithWhereUniqueWithoutDeviceInput = {
    where: CommandWhereUniqueInput
    data: XOR<CommandUpdateWithoutDeviceInput, CommandUncheckedUpdateWithoutDeviceInput>
  }

  export type CommandUpdateManyWithWhereWithoutDeviceInput = {
    where: CommandScalarWhereInput
    data: XOR<CommandUpdateManyMutationInput, CommandUncheckedUpdateManyWithoutDeviceInput>
  }

  export type AlertEventUpsertWithWhereUniqueWithoutDeviceInput = {
    where: AlertEventWhereUniqueInput
    update: XOR<AlertEventUpdateWithoutDeviceInput, AlertEventUncheckedUpdateWithoutDeviceInput>
    create: XOR<AlertEventCreateWithoutDeviceInput, AlertEventUncheckedCreateWithoutDeviceInput>
  }

  export type AlertEventUpdateWithWhereUniqueWithoutDeviceInput = {
    where: AlertEventWhereUniqueInput
    data: XOR<AlertEventUpdateWithoutDeviceInput, AlertEventUncheckedUpdateWithoutDeviceInput>
  }

  export type AlertEventUpdateManyWithWhereWithoutDeviceInput = {
    where: AlertEventScalarWhereInput
    data: XOR<AlertEventUpdateManyMutationInput, AlertEventUncheckedUpdateManyWithoutDeviceInput>
  }

  export type DailyRollupUpsertWithWhereUniqueWithoutDeviceInput = {
    where: DailyRollupWhereUniqueInput
    update: XOR<DailyRollupUpdateWithoutDeviceInput, DailyRollupUncheckedUpdateWithoutDeviceInput>
    create: XOR<DailyRollupCreateWithoutDeviceInput, DailyRollupUncheckedCreateWithoutDeviceInput>
  }

  export type DailyRollupUpdateWithWhereUniqueWithoutDeviceInput = {
    where: DailyRollupWhereUniqueInput
    data: XOR<DailyRollupUpdateWithoutDeviceInput, DailyRollupUncheckedUpdateWithoutDeviceInput>
  }

  export type DailyRollupUpdateManyWithWhereWithoutDeviceInput = {
    where: DailyRollupScalarWhereInput
    data: XOR<DailyRollupUpdateManyMutationInput, DailyRollupUncheckedUpdateManyWithoutDeviceInput>
  }

  export type EntitlementUpsertWithWhereUniqueWithoutDeviceInput = {
    where: EntitlementWhereUniqueInput
    update: XOR<EntitlementUpdateWithoutDeviceInput, EntitlementUncheckedUpdateWithoutDeviceInput>
    create: XOR<EntitlementCreateWithoutDeviceInput, EntitlementUncheckedCreateWithoutDeviceInput>
  }

  export type EntitlementUpdateWithWhereUniqueWithoutDeviceInput = {
    where: EntitlementWhereUniqueInput
    data: XOR<EntitlementUpdateWithoutDeviceInput, EntitlementUncheckedUpdateWithoutDeviceInput>
  }

  export type EntitlementUpdateManyWithWhereWithoutDeviceInput = {
    where: EntitlementScalarWhereInput
    data: XOR<EntitlementUpdateManyMutationInput, EntitlementUncheckedUpdateManyWithoutDeviceInput>
  }

  export type DeviceCreateWithoutSecretInput = {
    id?: string
    ownerUserId?: string | null
    model: string
    serialNumber: string
    name?: string | null
    notes?: string | null
    tags?: NullableJsonNullValueInput | InputJsonValue
    status?: $Enums.DeviceStatus
    lastSeenAt?: Date | string | null
    firmwareVersion?: string | null
    deviceLat?: number | null
    deviceLon?: number | null
    deviceLocationTs?: Date | string | null
    deviceLocationSource?: $Enums.DeviceLocationSource | null
    deviceLocationAccuracyM?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    tenant: TenantCreateNestedOneWithoutDevicesInput
    site?: SiteCreateNestedOneWithoutDevicesInput
    sim?: SimInfoCreateNestedOneWithoutDevicesInput
    twin?: DeviceTwinCreateNestedOneWithoutDeviceInput
    telemetry?: TelemetryCreateNestedManyWithoutDeviceInput
    commands?: CommandCreateNestedManyWithoutDeviceInput
    alertEvents?: AlertEventCreateNestedManyWithoutDeviceInput
    dailyRollups?: DailyRollupCreateNestedManyWithoutDeviceInput
    entitlements?: EntitlementCreateNestedManyWithoutDeviceInput
  }

  export type DeviceUncheckedCreateWithoutSecretInput = {
    id?: string
    tenantId: string
    siteId?: string | null
    ownerUserId?: string | null
    model: string
    serialNumber: string
    name?: string | null
    notes?: string | null
    tags?: NullableJsonNullValueInput | InputJsonValue
    status?: $Enums.DeviceStatus
    lastSeenAt?: Date | string | null
    firmwareVersion?: string | null
    simIccid?: string | null
    deviceLat?: number | null
    deviceLon?: number | null
    deviceLocationTs?: Date | string | null
    deviceLocationSource?: $Enums.DeviceLocationSource | null
    deviceLocationAccuracyM?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    twin?: DeviceTwinUncheckedCreateNestedOneWithoutDeviceInput
    telemetry?: TelemetryUncheckedCreateNestedManyWithoutDeviceInput
    commands?: CommandUncheckedCreateNestedManyWithoutDeviceInput
    alertEvents?: AlertEventUncheckedCreateNestedManyWithoutDeviceInput
    dailyRollups?: DailyRollupUncheckedCreateNestedManyWithoutDeviceInput
    entitlements?: EntitlementUncheckedCreateNestedManyWithoutDeviceInput
  }

  export type DeviceCreateOrConnectWithoutSecretInput = {
    where: DeviceWhereUniqueInput
    create: XOR<DeviceCreateWithoutSecretInput, DeviceUncheckedCreateWithoutSecretInput>
  }

  export type DeviceUpsertWithoutSecretInput = {
    update: XOR<DeviceUpdateWithoutSecretInput, DeviceUncheckedUpdateWithoutSecretInput>
    create: XOR<DeviceCreateWithoutSecretInput, DeviceUncheckedCreateWithoutSecretInput>
    where?: DeviceWhereInput
  }

  export type DeviceUpdateToOneWithWhereWithoutSecretInput = {
    where?: DeviceWhereInput
    data: XOR<DeviceUpdateWithoutSecretInput, DeviceUncheckedUpdateWithoutSecretInput>
  }

  export type DeviceUpdateWithoutSecretInput = {
    id?: StringFieldUpdateOperationsInput | string
    ownerUserId?: NullableStringFieldUpdateOperationsInput | string | null
    model?: StringFieldUpdateOperationsInput | string
    serialNumber?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: NullableJsonNullValueInput | InputJsonValue
    status?: EnumDeviceStatusFieldUpdateOperationsInput | $Enums.DeviceStatus
    lastSeenAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    firmwareVersion?: NullableStringFieldUpdateOperationsInput | string | null
    deviceLat?: NullableFloatFieldUpdateOperationsInput | number | null
    deviceLon?: NullableFloatFieldUpdateOperationsInput | number | null
    deviceLocationTs?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deviceLocationSource?: NullableEnumDeviceLocationSourceFieldUpdateOperationsInput | $Enums.DeviceLocationSource | null
    deviceLocationAccuracyM?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tenant?: TenantUpdateOneRequiredWithoutDevicesNestedInput
    site?: SiteUpdateOneWithoutDevicesNestedInput
    sim?: SimInfoUpdateOneWithoutDevicesNestedInput
    twin?: DeviceTwinUpdateOneWithoutDeviceNestedInput
    telemetry?: TelemetryUpdateManyWithoutDeviceNestedInput
    commands?: CommandUpdateManyWithoutDeviceNestedInput
    alertEvents?: AlertEventUpdateManyWithoutDeviceNestedInput
    dailyRollups?: DailyRollupUpdateManyWithoutDeviceNestedInput
    entitlements?: EntitlementUpdateManyWithoutDeviceNestedInput
  }

  export type DeviceUncheckedUpdateWithoutSecretInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    siteId?: NullableStringFieldUpdateOperationsInput | string | null
    ownerUserId?: NullableStringFieldUpdateOperationsInput | string | null
    model?: StringFieldUpdateOperationsInput | string
    serialNumber?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: NullableJsonNullValueInput | InputJsonValue
    status?: EnumDeviceStatusFieldUpdateOperationsInput | $Enums.DeviceStatus
    lastSeenAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    firmwareVersion?: NullableStringFieldUpdateOperationsInput | string | null
    simIccid?: NullableStringFieldUpdateOperationsInput | string | null
    deviceLat?: NullableFloatFieldUpdateOperationsInput | number | null
    deviceLon?: NullableFloatFieldUpdateOperationsInput | number | null
    deviceLocationTs?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deviceLocationSource?: NullableEnumDeviceLocationSourceFieldUpdateOperationsInput | $Enums.DeviceLocationSource | null
    deviceLocationAccuracyM?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    twin?: DeviceTwinUncheckedUpdateOneWithoutDeviceNestedInput
    telemetry?: TelemetryUncheckedUpdateManyWithoutDeviceNestedInput
    commands?: CommandUncheckedUpdateManyWithoutDeviceNestedInput
    alertEvents?: AlertEventUncheckedUpdateManyWithoutDeviceNestedInput
    dailyRollups?: DailyRollupUncheckedUpdateManyWithoutDeviceNestedInput
    entitlements?: EntitlementUncheckedUpdateManyWithoutDeviceNestedInput
  }

  export type DeviceCreateWithoutTelemetryInput = {
    id?: string
    ownerUserId?: string | null
    model: string
    serialNumber: string
    name?: string | null
    notes?: string | null
    tags?: NullableJsonNullValueInput | InputJsonValue
    status?: $Enums.DeviceStatus
    lastSeenAt?: Date | string | null
    firmwareVersion?: string | null
    deviceLat?: number | null
    deviceLon?: number | null
    deviceLocationTs?: Date | string | null
    deviceLocationSource?: $Enums.DeviceLocationSource | null
    deviceLocationAccuracyM?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    tenant: TenantCreateNestedOneWithoutDevicesInput
    site?: SiteCreateNestedOneWithoutDevicesInput
    sim?: SimInfoCreateNestedOneWithoutDevicesInput
    secret?: DeviceSecretCreateNestedOneWithoutDeviceInput
    twin?: DeviceTwinCreateNestedOneWithoutDeviceInput
    commands?: CommandCreateNestedManyWithoutDeviceInput
    alertEvents?: AlertEventCreateNestedManyWithoutDeviceInput
    dailyRollups?: DailyRollupCreateNestedManyWithoutDeviceInput
    entitlements?: EntitlementCreateNestedManyWithoutDeviceInput
  }

  export type DeviceUncheckedCreateWithoutTelemetryInput = {
    id?: string
    tenantId: string
    siteId?: string | null
    ownerUserId?: string | null
    model: string
    serialNumber: string
    name?: string | null
    notes?: string | null
    tags?: NullableJsonNullValueInput | InputJsonValue
    status?: $Enums.DeviceStatus
    lastSeenAt?: Date | string | null
    firmwareVersion?: string | null
    simIccid?: string | null
    deviceLat?: number | null
    deviceLon?: number | null
    deviceLocationTs?: Date | string | null
    deviceLocationSource?: $Enums.DeviceLocationSource | null
    deviceLocationAccuracyM?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    secret?: DeviceSecretUncheckedCreateNestedOneWithoutDeviceInput
    twin?: DeviceTwinUncheckedCreateNestedOneWithoutDeviceInput
    commands?: CommandUncheckedCreateNestedManyWithoutDeviceInput
    alertEvents?: AlertEventUncheckedCreateNestedManyWithoutDeviceInput
    dailyRollups?: DailyRollupUncheckedCreateNestedManyWithoutDeviceInput
    entitlements?: EntitlementUncheckedCreateNestedManyWithoutDeviceInput
  }

  export type DeviceCreateOrConnectWithoutTelemetryInput = {
    where: DeviceWhereUniqueInput
    create: XOR<DeviceCreateWithoutTelemetryInput, DeviceUncheckedCreateWithoutTelemetryInput>
  }

  export type DeviceUpsertWithoutTelemetryInput = {
    update: XOR<DeviceUpdateWithoutTelemetryInput, DeviceUncheckedUpdateWithoutTelemetryInput>
    create: XOR<DeviceCreateWithoutTelemetryInput, DeviceUncheckedCreateWithoutTelemetryInput>
    where?: DeviceWhereInput
  }

  export type DeviceUpdateToOneWithWhereWithoutTelemetryInput = {
    where?: DeviceWhereInput
    data: XOR<DeviceUpdateWithoutTelemetryInput, DeviceUncheckedUpdateWithoutTelemetryInput>
  }

  export type DeviceUpdateWithoutTelemetryInput = {
    id?: StringFieldUpdateOperationsInput | string
    ownerUserId?: NullableStringFieldUpdateOperationsInput | string | null
    model?: StringFieldUpdateOperationsInput | string
    serialNumber?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: NullableJsonNullValueInput | InputJsonValue
    status?: EnumDeviceStatusFieldUpdateOperationsInput | $Enums.DeviceStatus
    lastSeenAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    firmwareVersion?: NullableStringFieldUpdateOperationsInput | string | null
    deviceLat?: NullableFloatFieldUpdateOperationsInput | number | null
    deviceLon?: NullableFloatFieldUpdateOperationsInput | number | null
    deviceLocationTs?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deviceLocationSource?: NullableEnumDeviceLocationSourceFieldUpdateOperationsInput | $Enums.DeviceLocationSource | null
    deviceLocationAccuracyM?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tenant?: TenantUpdateOneRequiredWithoutDevicesNestedInput
    site?: SiteUpdateOneWithoutDevicesNestedInput
    sim?: SimInfoUpdateOneWithoutDevicesNestedInput
    secret?: DeviceSecretUpdateOneWithoutDeviceNestedInput
    twin?: DeviceTwinUpdateOneWithoutDeviceNestedInput
    commands?: CommandUpdateManyWithoutDeviceNestedInput
    alertEvents?: AlertEventUpdateManyWithoutDeviceNestedInput
    dailyRollups?: DailyRollupUpdateManyWithoutDeviceNestedInput
    entitlements?: EntitlementUpdateManyWithoutDeviceNestedInput
  }

  export type DeviceUncheckedUpdateWithoutTelemetryInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    siteId?: NullableStringFieldUpdateOperationsInput | string | null
    ownerUserId?: NullableStringFieldUpdateOperationsInput | string | null
    model?: StringFieldUpdateOperationsInput | string
    serialNumber?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: NullableJsonNullValueInput | InputJsonValue
    status?: EnumDeviceStatusFieldUpdateOperationsInput | $Enums.DeviceStatus
    lastSeenAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    firmwareVersion?: NullableStringFieldUpdateOperationsInput | string | null
    simIccid?: NullableStringFieldUpdateOperationsInput | string | null
    deviceLat?: NullableFloatFieldUpdateOperationsInput | number | null
    deviceLon?: NullableFloatFieldUpdateOperationsInput | number | null
    deviceLocationTs?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deviceLocationSource?: NullableEnumDeviceLocationSourceFieldUpdateOperationsInput | $Enums.DeviceLocationSource | null
    deviceLocationAccuracyM?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    secret?: DeviceSecretUncheckedUpdateOneWithoutDeviceNestedInput
    twin?: DeviceTwinUncheckedUpdateOneWithoutDeviceNestedInput
    commands?: CommandUncheckedUpdateManyWithoutDeviceNestedInput
    alertEvents?: AlertEventUncheckedUpdateManyWithoutDeviceNestedInput
    dailyRollups?: DailyRollupUncheckedUpdateManyWithoutDeviceNestedInput
    entitlements?: EntitlementUncheckedUpdateManyWithoutDeviceNestedInput
  }

  export type DeviceCreateWithoutTwinInput = {
    id?: string
    ownerUserId?: string | null
    model: string
    serialNumber: string
    name?: string | null
    notes?: string | null
    tags?: NullableJsonNullValueInput | InputJsonValue
    status?: $Enums.DeviceStatus
    lastSeenAt?: Date | string | null
    firmwareVersion?: string | null
    deviceLat?: number | null
    deviceLon?: number | null
    deviceLocationTs?: Date | string | null
    deviceLocationSource?: $Enums.DeviceLocationSource | null
    deviceLocationAccuracyM?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    tenant: TenantCreateNestedOneWithoutDevicesInput
    site?: SiteCreateNestedOneWithoutDevicesInput
    sim?: SimInfoCreateNestedOneWithoutDevicesInput
    secret?: DeviceSecretCreateNestedOneWithoutDeviceInput
    telemetry?: TelemetryCreateNestedManyWithoutDeviceInput
    commands?: CommandCreateNestedManyWithoutDeviceInput
    alertEvents?: AlertEventCreateNestedManyWithoutDeviceInput
    dailyRollups?: DailyRollupCreateNestedManyWithoutDeviceInput
    entitlements?: EntitlementCreateNestedManyWithoutDeviceInput
  }

  export type DeviceUncheckedCreateWithoutTwinInput = {
    id?: string
    tenantId: string
    siteId?: string | null
    ownerUserId?: string | null
    model: string
    serialNumber: string
    name?: string | null
    notes?: string | null
    tags?: NullableJsonNullValueInput | InputJsonValue
    status?: $Enums.DeviceStatus
    lastSeenAt?: Date | string | null
    firmwareVersion?: string | null
    simIccid?: string | null
    deviceLat?: number | null
    deviceLon?: number | null
    deviceLocationTs?: Date | string | null
    deviceLocationSource?: $Enums.DeviceLocationSource | null
    deviceLocationAccuracyM?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    secret?: DeviceSecretUncheckedCreateNestedOneWithoutDeviceInput
    telemetry?: TelemetryUncheckedCreateNestedManyWithoutDeviceInput
    commands?: CommandUncheckedCreateNestedManyWithoutDeviceInput
    alertEvents?: AlertEventUncheckedCreateNestedManyWithoutDeviceInput
    dailyRollups?: DailyRollupUncheckedCreateNestedManyWithoutDeviceInput
    entitlements?: EntitlementUncheckedCreateNestedManyWithoutDeviceInput
  }

  export type DeviceCreateOrConnectWithoutTwinInput = {
    where: DeviceWhereUniqueInput
    create: XOR<DeviceCreateWithoutTwinInput, DeviceUncheckedCreateWithoutTwinInput>
  }

  export type DeviceUpsertWithoutTwinInput = {
    update: XOR<DeviceUpdateWithoutTwinInput, DeviceUncheckedUpdateWithoutTwinInput>
    create: XOR<DeviceCreateWithoutTwinInput, DeviceUncheckedCreateWithoutTwinInput>
    where?: DeviceWhereInput
  }

  export type DeviceUpdateToOneWithWhereWithoutTwinInput = {
    where?: DeviceWhereInput
    data: XOR<DeviceUpdateWithoutTwinInput, DeviceUncheckedUpdateWithoutTwinInput>
  }

  export type DeviceUpdateWithoutTwinInput = {
    id?: StringFieldUpdateOperationsInput | string
    ownerUserId?: NullableStringFieldUpdateOperationsInput | string | null
    model?: StringFieldUpdateOperationsInput | string
    serialNumber?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: NullableJsonNullValueInput | InputJsonValue
    status?: EnumDeviceStatusFieldUpdateOperationsInput | $Enums.DeviceStatus
    lastSeenAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    firmwareVersion?: NullableStringFieldUpdateOperationsInput | string | null
    deviceLat?: NullableFloatFieldUpdateOperationsInput | number | null
    deviceLon?: NullableFloatFieldUpdateOperationsInput | number | null
    deviceLocationTs?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deviceLocationSource?: NullableEnumDeviceLocationSourceFieldUpdateOperationsInput | $Enums.DeviceLocationSource | null
    deviceLocationAccuracyM?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tenant?: TenantUpdateOneRequiredWithoutDevicesNestedInput
    site?: SiteUpdateOneWithoutDevicesNestedInput
    sim?: SimInfoUpdateOneWithoutDevicesNestedInput
    secret?: DeviceSecretUpdateOneWithoutDeviceNestedInput
    telemetry?: TelemetryUpdateManyWithoutDeviceNestedInput
    commands?: CommandUpdateManyWithoutDeviceNestedInput
    alertEvents?: AlertEventUpdateManyWithoutDeviceNestedInput
    dailyRollups?: DailyRollupUpdateManyWithoutDeviceNestedInput
    entitlements?: EntitlementUpdateManyWithoutDeviceNestedInput
  }

  export type DeviceUncheckedUpdateWithoutTwinInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    siteId?: NullableStringFieldUpdateOperationsInput | string | null
    ownerUserId?: NullableStringFieldUpdateOperationsInput | string | null
    model?: StringFieldUpdateOperationsInput | string
    serialNumber?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: NullableJsonNullValueInput | InputJsonValue
    status?: EnumDeviceStatusFieldUpdateOperationsInput | $Enums.DeviceStatus
    lastSeenAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    firmwareVersion?: NullableStringFieldUpdateOperationsInput | string | null
    simIccid?: NullableStringFieldUpdateOperationsInput | string | null
    deviceLat?: NullableFloatFieldUpdateOperationsInput | number | null
    deviceLon?: NullableFloatFieldUpdateOperationsInput | number | null
    deviceLocationTs?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deviceLocationSource?: NullableEnumDeviceLocationSourceFieldUpdateOperationsInput | $Enums.DeviceLocationSource | null
    deviceLocationAccuracyM?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    secret?: DeviceSecretUncheckedUpdateOneWithoutDeviceNestedInput
    telemetry?: TelemetryUncheckedUpdateManyWithoutDeviceNestedInput
    commands?: CommandUncheckedUpdateManyWithoutDeviceNestedInput
    alertEvents?: AlertEventUncheckedUpdateManyWithoutDeviceNestedInput
    dailyRollups?: DailyRollupUncheckedUpdateManyWithoutDeviceNestedInput
    entitlements?: EntitlementUncheckedUpdateManyWithoutDeviceNestedInput
  }

  export type DeviceCreateWithoutCommandsInput = {
    id?: string
    ownerUserId?: string | null
    model: string
    serialNumber: string
    name?: string | null
    notes?: string | null
    tags?: NullableJsonNullValueInput | InputJsonValue
    status?: $Enums.DeviceStatus
    lastSeenAt?: Date | string | null
    firmwareVersion?: string | null
    deviceLat?: number | null
    deviceLon?: number | null
    deviceLocationTs?: Date | string | null
    deviceLocationSource?: $Enums.DeviceLocationSource | null
    deviceLocationAccuracyM?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    tenant: TenantCreateNestedOneWithoutDevicesInput
    site?: SiteCreateNestedOneWithoutDevicesInput
    sim?: SimInfoCreateNestedOneWithoutDevicesInput
    secret?: DeviceSecretCreateNestedOneWithoutDeviceInput
    twin?: DeviceTwinCreateNestedOneWithoutDeviceInput
    telemetry?: TelemetryCreateNestedManyWithoutDeviceInput
    alertEvents?: AlertEventCreateNestedManyWithoutDeviceInput
    dailyRollups?: DailyRollupCreateNestedManyWithoutDeviceInput
    entitlements?: EntitlementCreateNestedManyWithoutDeviceInput
  }

  export type DeviceUncheckedCreateWithoutCommandsInput = {
    id?: string
    tenantId: string
    siteId?: string | null
    ownerUserId?: string | null
    model: string
    serialNumber: string
    name?: string | null
    notes?: string | null
    tags?: NullableJsonNullValueInput | InputJsonValue
    status?: $Enums.DeviceStatus
    lastSeenAt?: Date | string | null
    firmwareVersion?: string | null
    simIccid?: string | null
    deviceLat?: number | null
    deviceLon?: number | null
    deviceLocationTs?: Date | string | null
    deviceLocationSource?: $Enums.DeviceLocationSource | null
    deviceLocationAccuracyM?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    secret?: DeviceSecretUncheckedCreateNestedOneWithoutDeviceInput
    twin?: DeviceTwinUncheckedCreateNestedOneWithoutDeviceInput
    telemetry?: TelemetryUncheckedCreateNestedManyWithoutDeviceInput
    alertEvents?: AlertEventUncheckedCreateNestedManyWithoutDeviceInput
    dailyRollups?: DailyRollupUncheckedCreateNestedManyWithoutDeviceInput
    entitlements?: EntitlementUncheckedCreateNestedManyWithoutDeviceInput
  }

  export type DeviceCreateOrConnectWithoutCommandsInput = {
    where: DeviceWhereUniqueInput
    create: XOR<DeviceCreateWithoutCommandsInput, DeviceUncheckedCreateWithoutCommandsInput>
  }

  export type UserCreateWithoutCommandsInput = {
    id?: string
    email: string
    passwordHash: string
    name: string
    status?: $Enums.UserStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    memberships?: MembershipCreateNestedManyWithoutUserInput
    otaJobs?: OtaJobCreateNestedManyWithoutCreatedByInput
    simActions?: SimActionCreateNestedManyWithoutRequestedByInput
    siteLocUpdates?: SiteCreateNestedManyWithoutLocationUpdatedByInput
  }

  export type UserUncheckedCreateWithoutCommandsInput = {
    id?: string
    email: string
    passwordHash: string
    name: string
    status?: $Enums.UserStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    memberships?: MembershipUncheckedCreateNestedManyWithoutUserInput
    otaJobs?: OtaJobUncheckedCreateNestedManyWithoutCreatedByInput
    simActions?: SimActionUncheckedCreateNestedManyWithoutRequestedByInput
    siteLocUpdates?: SiteUncheckedCreateNestedManyWithoutLocationUpdatedByInput
  }

  export type UserCreateOrConnectWithoutCommandsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutCommandsInput, UserUncheckedCreateWithoutCommandsInput>
  }

  export type DeviceUpsertWithoutCommandsInput = {
    update: XOR<DeviceUpdateWithoutCommandsInput, DeviceUncheckedUpdateWithoutCommandsInput>
    create: XOR<DeviceCreateWithoutCommandsInput, DeviceUncheckedCreateWithoutCommandsInput>
    where?: DeviceWhereInput
  }

  export type DeviceUpdateToOneWithWhereWithoutCommandsInput = {
    where?: DeviceWhereInput
    data: XOR<DeviceUpdateWithoutCommandsInput, DeviceUncheckedUpdateWithoutCommandsInput>
  }

  export type DeviceUpdateWithoutCommandsInput = {
    id?: StringFieldUpdateOperationsInput | string
    ownerUserId?: NullableStringFieldUpdateOperationsInput | string | null
    model?: StringFieldUpdateOperationsInput | string
    serialNumber?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: NullableJsonNullValueInput | InputJsonValue
    status?: EnumDeviceStatusFieldUpdateOperationsInput | $Enums.DeviceStatus
    lastSeenAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    firmwareVersion?: NullableStringFieldUpdateOperationsInput | string | null
    deviceLat?: NullableFloatFieldUpdateOperationsInput | number | null
    deviceLon?: NullableFloatFieldUpdateOperationsInput | number | null
    deviceLocationTs?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deviceLocationSource?: NullableEnumDeviceLocationSourceFieldUpdateOperationsInput | $Enums.DeviceLocationSource | null
    deviceLocationAccuracyM?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tenant?: TenantUpdateOneRequiredWithoutDevicesNestedInput
    site?: SiteUpdateOneWithoutDevicesNestedInput
    sim?: SimInfoUpdateOneWithoutDevicesNestedInput
    secret?: DeviceSecretUpdateOneWithoutDeviceNestedInput
    twin?: DeviceTwinUpdateOneWithoutDeviceNestedInput
    telemetry?: TelemetryUpdateManyWithoutDeviceNestedInput
    alertEvents?: AlertEventUpdateManyWithoutDeviceNestedInput
    dailyRollups?: DailyRollupUpdateManyWithoutDeviceNestedInput
    entitlements?: EntitlementUpdateManyWithoutDeviceNestedInput
  }

  export type DeviceUncheckedUpdateWithoutCommandsInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    siteId?: NullableStringFieldUpdateOperationsInput | string | null
    ownerUserId?: NullableStringFieldUpdateOperationsInput | string | null
    model?: StringFieldUpdateOperationsInput | string
    serialNumber?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: NullableJsonNullValueInput | InputJsonValue
    status?: EnumDeviceStatusFieldUpdateOperationsInput | $Enums.DeviceStatus
    lastSeenAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    firmwareVersion?: NullableStringFieldUpdateOperationsInput | string | null
    simIccid?: NullableStringFieldUpdateOperationsInput | string | null
    deviceLat?: NullableFloatFieldUpdateOperationsInput | number | null
    deviceLon?: NullableFloatFieldUpdateOperationsInput | number | null
    deviceLocationTs?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deviceLocationSource?: NullableEnumDeviceLocationSourceFieldUpdateOperationsInput | $Enums.DeviceLocationSource | null
    deviceLocationAccuracyM?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    secret?: DeviceSecretUncheckedUpdateOneWithoutDeviceNestedInput
    twin?: DeviceTwinUncheckedUpdateOneWithoutDeviceNestedInput
    telemetry?: TelemetryUncheckedUpdateManyWithoutDeviceNestedInput
    alertEvents?: AlertEventUncheckedUpdateManyWithoutDeviceNestedInput
    dailyRollups?: DailyRollupUncheckedUpdateManyWithoutDeviceNestedInput
    entitlements?: EntitlementUncheckedUpdateManyWithoutDeviceNestedInput
  }

  export type UserUpsertWithoutCommandsInput = {
    update: XOR<UserUpdateWithoutCommandsInput, UserUncheckedUpdateWithoutCommandsInput>
    create: XOR<UserCreateWithoutCommandsInput, UserUncheckedCreateWithoutCommandsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutCommandsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutCommandsInput, UserUncheckedUpdateWithoutCommandsInput>
  }

  export type UserUpdateWithoutCommandsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    status?: EnumUserStatusFieldUpdateOperationsInput | $Enums.UserStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    memberships?: MembershipUpdateManyWithoutUserNestedInput
    otaJobs?: OtaJobUpdateManyWithoutCreatedByNestedInput
    simActions?: SimActionUpdateManyWithoutRequestedByNestedInput
    siteLocUpdates?: SiteUpdateManyWithoutLocationUpdatedByNestedInput
  }

  export type UserUncheckedUpdateWithoutCommandsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    status?: EnumUserStatusFieldUpdateOperationsInput | $Enums.UserStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    memberships?: MembershipUncheckedUpdateManyWithoutUserNestedInput
    otaJobs?: OtaJobUncheckedUpdateManyWithoutCreatedByNestedInput
    simActions?: SimActionUncheckedUpdateManyWithoutRequestedByNestedInput
    siteLocUpdates?: SiteUncheckedUpdateManyWithoutLocationUpdatedByNestedInput
  }

  export type OtaJobCreateWithoutFirmwarePackageInput = {
    id?: string
    targetType: $Enums.OtaTargetType
    deviceId?: string | null
    groupFilter?: NullableJsonNullValueInput | InputJsonValue
    status?: $Enums.OtaJobStatus
    scheduledAt: Date | string
    startedAt?: Date | string | null
    finishedAt?: Date | string | null
    progress?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    tenant: TenantCreateNestedOneWithoutOtaJobsInput
    createdBy?: UserCreateNestedOneWithoutOtaJobsInput
  }

  export type OtaJobUncheckedCreateWithoutFirmwarePackageInput = {
    id?: string
    tenantId: string
    targetType: $Enums.OtaTargetType
    deviceId?: string | null
    groupFilter?: NullableJsonNullValueInput | InputJsonValue
    status?: $Enums.OtaJobStatus
    scheduledAt: Date | string
    startedAt?: Date | string | null
    finishedAt?: Date | string | null
    createdByUserId?: string | null
    progress?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type OtaJobCreateOrConnectWithoutFirmwarePackageInput = {
    where: OtaJobWhereUniqueInput
    create: XOR<OtaJobCreateWithoutFirmwarePackageInput, OtaJobUncheckedCreateWithoutFirmwarePackageInput>
  }

  export type OtaJobCreateManyFirmwarePackageInputEnvelope = {
    data: OtaJobCreateManyFirmwarePackageInput | OtaJobCreateManyFirmwarePackageInput[]
    skipDuplicates?: boolean
  }

  export type OtaJobUpsertWithWhereUniqueWithoutFirmwarePackageInput = {
    where: OtaJobWhereUniqueInput
    update: XOR<OtaJobUpdateWithoutFirmwarePackageInput, OtaJobUncheckedUpdateWithoutFirmwarePackageInput>
    create: XOR<OtaJobCreateWithoutFirmwarePackageInput, OtaJobUncheckedCreateWithoutFirmwarePackageInput>
  }

  export type OtaJobUpdateWithWhereUniqueWithoutFirmwarePackageInput = {
    where: OtaJobWhereUniqueInput
    data: XOR<OtaJobUpdateWithoutFirmwarePackageInput, OtaJobUncheckedUpdateWithoutFirmwarePackageInput>
  }

  export type OtaJobUpdateManyWithWhereWithoutFirmwarePackageInput = {
    where: OtaJobScalarWhereInput
    data: XOR<OtaJobUpdateManyMutationInput, OtaJobUncheckedUpdateManyWithoutFirmwarePackageInput>
  }

  export type TenantCreateWithoutOtaJobsInput = {
    id?: string
    name: string
    type: $Enums.TenantType
    status?: $Enums.TenantStatus
    settings?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    memberships?: MembershipCreateNestedManyWithoutTenantInput
    sites?: SiteCreateNestedManyWithoutTenantInput
    devices?: DeviceCreateNestedManyWithoutTenantInput
    alertRules?: AlertRuleCreateNestedManyWithoutTenantInput
    alertEvents?: AlertEventCreateNestedManyWithoutTenantInput
    notificationChannels?: NotificationChannelCreateNestedManyWithoutTenantInput
    notificationEvents?: NotificationEventCreateNestedManyWithoutTenantInput
    dailyRollups?: DailyRollupCreateNestedManyWithoutTenantInput
    entitlements?: EntitlementCreateNestedManyWithoutTenantInput
    auditLogs?: AuditLogCreateNestedManyWithoutTenantInput
    weatherData?: WeatherDataCreateNestedManyWithoutTenantInput
  }

  export type TenantUncheckedCreateWithoutOtaJobsInput = {
    id?: string
    name: string
    type: $Enums.TenantType
    status?: $Enums.TenantStatus
    settings?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    memberships?: MembershipUncheckedCreateNestedManyWithoutTenantInput
    sites?: SiteUncheckedCreateNestedManyWithoutTenantInput
    devices?: DeviceUncheckedCreateNestedManyWithoutTenantInput
    alertRules?: AlertRuleUncheckedCreateNestedManyWithoutTenantInput
    alertEvents?: AlertEventUncheckedCreateNestedManyWithoutTenantInput
    notificationChannels?: NotificationChannelUncheckedCreateNestedManyWithoutTenantInput
    notificationEvents?: NotificationEventUncheckedCreateNestedManyWithoutTenantInput
    dailyRollups?: DailyRollupUncheckedCreateNestedManyWithoutTenantInput
    entitlements?: EntitlementUncheckedCreateNestedManyWithoutTenantInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutTenantInput
    weatherData?: WeatherDataUncheckedCreateNestedManyWithoutTenantInput
  }

  export type TenantCreateOrConnectWithoutOtaJobsInput = {
    where: TenantWhereUniqueInput
    create: XOR<TenantCreateWithoutOtaJobsInput, TenantUncheckedCreateWithoutOtaJobsInput>
  }

  export type FirmwarePackageCreateWithoutOtaJobsInput = {
    id?: string
    version: string
    fileUrl: string
    checksum: string
    releaseNotes?: string | null
    createdAt?: Date | string
  }

  export type FirmwarePackageUncheckedCreateWithoutOtaJobsInput = {
    id?: string
    version: string
    fileUrl: string
    checksum: string
    releaseNotes?: string | null
    createdAt?: Date | string
  }

  export type FirmwarePackageCreateOrConnectWithoutOtaJobsInput = {
    where: FirmwarePackageWhereUniqueInput
    create: XOR<FirmwarePackageCreateWithoutOtaJobsInput, FirmwarePackageUncheckedCreateWithoutOtaJobsInput>
  }

  export type UserCreateWithoutOtaJobsInput = {
    id?: string
    email: string
    passwordHash: string
    name: string
    status?: $Enums.UserStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    memberships?: MembershipCreateNestedManyWithoutUserInput
    commands?: CommandCreateNestedManyWithoutRequestedByInput
    simActions?: SimActionCreateNestedManyWithoutRequestedByInput
    siteLocUpdates?: SiteCreateNestedManyWithoutLocationUpdatedByInput
  }

  export type UserUncheckedCreateWithoutOtaJobsInput = {
    id?: string
    email: string
    passwordHash: string
    name: string
    status?: $Enums.UserStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    memberships?: MembershipUncheckedCreateNestedManyWithoutUserInput
    commands?: CommandUncheckedCreateNestedManyWithoutRequestedByInput
    simActions?: SimActionUncheckedCreateNestedManyWithoutRequestedByInput
    siteLocUpdates?: SiteUncheckedCreateNestedManyWithoutLocationUpdatedByInput
  }

  export type UserCreateOrConnectWithoutOtaJobsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutOtaJobsInput, UserUncheckedCreateWithoutOtaJobsInput>
  }

  export type TenantUpsertWithoutOtaJobsInput = {
    update: XOR<TenantUpdateWithoutOtaJobsInput, TenantUncheckedUpdateWithoutOtaJobsInput>
    create: XOR<TenantCreateWithoutOtaJobsInput, TenantUncheckedCreateWithoutOtaJobsInput>
    where?: TenantWhereInput
  }

  export type TenantUpdateToOneWithWhereWithoutOtaJobsInput = {
    where?: TenantWhereInput
    data: XOR<TenantUpdateWithoutOtaJobsInput, TenantUncheckedUpdateWithoutOtaJobsInput>
  }

  export type TenantUpdateWithoutOtaJobsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumTenantTypeFieldUpdateOperationsInput | $Enums.TenantType
    status?: EnumTenantStatusFieldUpdateOperationsInput | $Enums.TenantStatus
    settings?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    memberships?: MembershipUpdateManyWithoutTenantNestedInput
    sites?: SiteUpdateManyWithoutTenantNestedInput
    devices?: DeviceUpdateManyWithoutTenantNestedInput
    alertRules?: AlertRuleUpdateManyWithoutTenantNestedInput
    alertEvents?: AlertEventUpdateManyWithoutTenantNestedInput
    notificationChannels?: NotificationChannelUpdateManyWithoutTenantNestedInput
    notificationEvents?: NotificationEventUpdateManyWithoutTenantNestedInput
    dailyRollups?: DailyRollupUpdateManyWithoutTenantNestedInput
    entitlements?: EntitlementUpdateManyWithoutTenantNestedInput
    auditLogs?: AuditLogUpdateManyWithoutTenantNestedInput
    weatherData?: WeatherDataUpdateManyWithoutTenantNestedInput
  }

  export type TenantUncheckedUpdateWithoutOtaJobsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumTenantTypeFieldUpdateOperationsInput | $Enums.TenantType
    status?: EnumTenantStatusFieldUpdateOperationsInput | $Enums.TenantStatus
    settings?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    memberships?: MembershipUncheckedUpdateManyWithoutTenantNestedInput
    sites?: SiteUncheckedUpdateManyWithoutTenantNestedInput
    devices?: DeviceUncheckedUpdateManyWithoutTenantNestedInput
    alertRules?: AlertRuleUncheckedUpdateManyWithoutTenantNestedInput
    alertEvents?: AlertEventUncheckedUpdateManyWithoutTenantNestedInput
    notificationChannels?: NotificationChannelUncheckedUpdateManyWithoutTenantNestedInput
    notificationEvents?: NotificationEventUncheckedUpdateManyWithoutTenantNestedInput
    dailyRollups?: DailyRollupUncheckedUpdateManyWithoutTenantNestedInput
    entitlements?: EntitlementUncheckedUpdateManyWithoutTenantNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutTenantNestedInput
    weatherData?: WeatherDataUncheckedUpdateManyWithoutTenantNestedInput
  }

  export type FirmwarePackageUpsertWithoutOtaJobsInput = {
    update: XOR<FirmwarePackageUpdateWithoutOtaJobsInput, FirmwarePackageUncheckedUpdateWithoutOtaJobsInput>
    create: XOR<FirmwarePackageCreateWithoutOtaJobsInput, FirmwarePackageUncheckedCreateWithoutOtaJobsInput>
    where?: FirmwarePackageWhereInput
  }

  export type FirmwarePackageUpdateToOneWithWhereWithoutOtaJobsInput = {
    where?: FirmwarePackageWhereInput
    data: XOR<FirmwarePackageUpdateWithoutOtaJobsInput, FirmwarePackageUncheckedUpdateWithoutOtaJobsInput>
  }

  export type FirmwarePackageUpdateWithoutOtaJobsInput = {
    id?: StringFieldUpdateOperationsInput | string
    version?: StringFieldUpdateOperationsInput | string
    fileUrl?: StringFieldUpdateOperationsInput | string
    checksum?: StringFieldUpdateOperationsInput | string
    releaseNotes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FirmwarePackageUncheckedUpdateWithoutOtaJobsInput = {
    id?: StringFieldUpdateOperationsInput | string
    version?: StringFieldUpdateOperationsInput | string
    fileUrl?: StringFieldUpdateOperationsInput | string
    checksum?: StringFieldUpdateOperationsInput | string
    releaseNotes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserUpsertWithoutOtaJobsInput = {
    update: XOR<UserUpdateWithoutOtaJobsInput, UserUncheckedUpdateWithoutOtaJobsInput>
    create: XOR<UserCreateWithoutOtaJobsInput, UserUncheckedCreateWithoutOtaJobsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutOtaJobsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutOtaJobsInput, UserUncheckedUpdateWithoutOtaJobsInput>
  }

  export type UserUpdateWithoutOtaJobsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    status?: EnumUserStatusFieldUpdateOperationsInput | $Enums.UserStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    memberships?: MembershipUpdateManyWithoutUserNestedInput
    commands?: CommandUpdateManyWithoutRequestedByNestedInput
    simActions?: SimActionUpdateManyWithoutRequestedByNestedInput
    siteLocUpdates?: SiteUpdateManyWithoutLocationUpdatedByNestedInput
  }

  export type UserUncheckedUpdateWithoutOtaJobsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    status?: EnumUserStatusFieldUpdateOperationsInput | $Enums.UserStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    memberships?: MembershipUncheckedUpdateManyWithoutUserNestedInput
    commands?: CommandUncheckedUpdateManyWithoutRequestedByNestedInput
    simActions?: SimActionUncheckedUpdateManyWithoutRequestedByNestedInput
    siteLocUpdates?: SiteUncheckedUpdateManyWithoutLocationUpdatedByNestedInput
  }

  export type DeviceCreateWithoutSimInput = {
    id?: string
    ownerUserId?: string | null
    model: string
    serialNumber: string
    name?: string | null
    notes?: string | null
    tags?: NullableJsonNullValueInput | InputJsonValue
    status?: $Enums.DeviceStatus
    lastSeenAt?: Date | string | null
    firmwareVersion?: string | null
    deviceLat?: number | null
    deviceLon?: number | null
    deviceLocationTs?: Date | string | null
    deviceLocationSource?: $Enums.DeviceLocationSource | null
    deviceLocationAccuracyM?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    tenant: TenantCreateNestedOneWithoutDevicesInput
    site?: SiteCreateNestedOneWithoutDevicesInput
    secret?: DeviceSecretCreateNestedOneWithoutDeviceInput
    twin?: DeviceTwinCreateNestedOneWithoutDeviceInput
    telemetry?: TelemetryCreateNestedManyWithoutDeviceInput
    commands?: CommandCreateNestedManyWithoutDeviceInput
    alertEvents?: AlertEventCreateNestedManyWithoutDeviceInput
    dailyRollups?: DailyRollupCreateNestedManyWithoutDeviceInput
    entitlements?: EntitlementCreateNestedManyWithoutDeviceInput
  }

  export type DeviceUncheckedCreateWithoutSimInput = {
    id?: string
    tenantId: string
    siteId?: string | null
    ownerUserId?: string | null
    model: string
    serialNumber: string
    name?: string | null
    notes?: string | null
    tags?: NullableJsonNullValueInput | InputJsonValue
    status?: $Enums.DeviceStatus
    lastSeenAt?: Date | string | null
    firmwareVersion?: string | null
    deviceLat?: number | null
    deviceLon?: number | null
    deviceLocationTs?: Date | string | null
    deviceLocationSource?: $Enums.DeviceLocationSource | null
    deviceLocationAccuracyM?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    secret?: DeviceSecretUncheckedCreateNestedOneWithoutDeviceInput
    twin?: DeviceTwinUncheckedCreateNestedOneWithoutDeviceInput
    telemetry?: TelemetryUncheckedCreateNestedManyWithoutDeviceInput
    commands?: CommandUncheckedCreateNestedManyWithoutDeviceInput
    alertEvents?: AlertEventUncheckedCreateNestedManyWithoutDeviceInput
    dailyRollups?: DailyRollupUncheckedCreateNestedManyWithoutDeviceInput
    entitlements?: EntitlementUncheckedCreateNestedManyWithoutDeviceInput
  }

  export type DeviceCreateOrConnectWithoutSimInput = {
    where: DeviceWhereUniqueInput
    create: XOR<DeviceCreateWithoutSimInput, DeviceUncheckedCreateWithoutSimInput>
  }

  export type DeviceCreateManySimInputEnvelope = {
    data: DeviceCreateManySimInput | DeviceCreateManySimInput[]
    skipDuplicates?: boolean
  }

  export type SimActionCreateWithoutSimInput = {
    id?: string
    action: $Enums.SimActionType
    requestedAt?: Date | string
    status?: $Enums.SimActionStatus
    providerRef?: string | null
    errorMsg?: string | null
    requestedBy?: UserCreateNestedOneWithoutSimActionsInput
  }

  export type SimActionUncheckedCreateWithoutSimInput = {
    id?: string
    action: $Enums.SimActionType
    requestedByUserId?: string | null
    requestedAt?: Date | string
    status?: $Enums.SimActionStatus
    providerRef?: string | null
    errorMsg?: string | null
  }

  export type SimActionCreateOrConnectWithoutSimInput = {
    where: SimActionWhereUniqueInput
    create: XOR<SimActionCreateWithoutSimInput, SimActionUncheckedCreateWithoutSimInput>
  }

  export type SimActionCreateManySimInputEnvelope = {
    data: SimActionCreateManySimInput | SimActionCreateManySimInput[]
    skipDuplicates?: boolean
  }

  export type DeviceUpsertWithWhereUniqueWithoutSimInput = {
    where: DeviceWhereUniqueInput
    update: XOR<DeviceUpdateWithoutSimInput, DeviceUncheckedUpdateWithoutSimInput>
    create: XOR<DeviceCreateWithoutSimInput, DeviceUncheckedCreateWithoutSimInput>
  }

  export type DeviceUpdateWithWhereUniqueWithoutSimInput = {
    where: DeviceWhereUniqueInput
    data: XOR<DeviceUpdateWithoutSimInput, DeviceUncheckedUpdateWithoutSimInput>
  }

  export type DeviceUpdateManyWithWhereWithoutSimInput = {
    where: DeviceScalarWhereInput
    data: XOR<DeviceUpdateManyMutationInput, DeviceUncheckedUpdateManyWithoutSimInput>
  }

  export type SimActionUpsertWithWhereUniqueWithoutSimInput = {
    where: SimActionWhereUniqueInput
    update: XOR<SimActionUpdateWithoutSimInput, SimActionUncheckedUpdateWithoutSimInput>
    create: XOR<SimActionCreateWithoutSimInput, SimActionUncheckedCreateWithoutSimInput>
  }

  export type SimActionUpdateWithWhereUniqueWithoutSimInput = {
    where: SimActionWhereUniqueInput
    data: XOR<SimActionUpdateWithoutSimInput, SimActionUncheckedUpdateWithoutSimInput>
  }

  export type SimActionUpdateManyWithWhereWithoutSimInput = {
    where: SimActionScalarWhereInput
    data: XOR<SimActionUpdateManyMutationInput, SimActionUncheckedUpdateManyWithoutSimInput>
  }

  export type SimInfoCreateWithoutSimActionsInput = {
    iccid: string
    carrier?: string | null
    planName?: string | null
    status?: $Enums.SimStatus
    lastSyncAt?: Date | string | null
    dataUsageMb?: number | null
    msisdn?: string | null
    imsi?: string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    devices?: DeviceCreateNestedManyWithoutSimInput
  }

  export type SimInfoUncheckedCreateWithoutSimActionsInput = {
    iccid: string
    carrier?: string | null
    planName?: string | null
    status?: $Enums.SimStatus
    lastSyncAt?: Date | string | null
    dataUsageMb?: number | null
    msisdn?: string | null
    imsi?: string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    devices?: DeviceUncheckedCreateNestedManyWithoutSimInput
  }

  export type SimInfoCreateOrConnectWithoutSimActionsInput = {
    where: SimInfoWhereUniqueInput
    create: XOR<SimInfoCreateWithoutSimActionsInput, SimInfoUncheckedCreateWithoutSimActionsInput>
  }

  export type UserCreateWithoutSimActionsInput = {
    id?: string
    email: string
    passwordHash: string
    name: string
    status?: $Enums.UserStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    memberships?: MembershipCreateNestedManyWithoutUserInput
    commands?: CommandCreateNestedManyWithoutRequestedByInput
    otaJobs?: OtaJobCreateNestedManyWithoutCreatedByInput
    siteLocUpdates?: SiteCreateNestedManyWithoutLocationUpdatedByInput
  }

  export type UserUncheckedCreateWithoutSimActionsInput = {
    id?: string
    email: string
    passwordHash: string
    name: string
    status?: $Enums.UserStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    memberships?: MembershipUncheckedCreateNestedManyWithoutUserInput
    commands?: CommandUncheckedCreateNestedManyWithoutRequestedByInput
    otaJobs?: OtaJobUncheckedCreateNestedManyWithoutCreatedByInput
    siteLocUpdates?: SiteUncheckedCreateNestedManyWithoutLocationUpdatedByInput
  }

  export type UserCreateOrConnectWithoutSimActionsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutSimActionsInput, UserUncheckedCreateWithoutSimActionsInput>
  }

  export type SimInfoUpsertWithoutSimActionsInput = {
    update: XOR<SimInfoUpdateWithoutSimActionsInput, SimInfoUncheckedUpdateWithoutSimActionsInput>
    create: XOR<SimInfoCreateWithoutSimActionsInput, SimInfoUncheckedCreateWithoutSimActionsInput>
    where?: SimInfoWhereInput
  }

  export type SimInfoUpdateToOneWithWhereWithoutSimActionsInput = {
    where?: SimInfoWhereInput
    data: XOR<SimInfoUpdateWithoutSimActionsInput, SimInfoUncheckedUpdateWithoutSimActionsInput>
  }

  export type SimInfoUpdateWithoutSimActionsInput = {
    iccid?: StringFieldUpdateOperationsInput | string
    carrier?: NullableStringFieldUpdateOperationsInput | string | null
    planName?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumSimStatusFieldUpdateOperationsInput | $Enums.SimStatus
    lastSyncAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dataUsageMb?: NullableFloatFieldUpdateOperationsInput | number | null
    msisdn?: NullableStringFieldUpdateOperationsInput | string | null
    imsi?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    devices?: DeviceUpdateManyWithoutSimNestedInput
  }

  export type SimInfoUncheckedUpdateWithoutSimActionsInput = {
    iccid?: StringFieldUpdateOperationsInput | string
    carrier?: NullableStringFieldUpdateOperationsInput | string | null
    planName?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumSimStatusFieldUpdateOperationsInput | $Enums.SimStatus
    lastSyncAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dataUsageMb?: NullableFloatFieldUpdateOperationsInput | number | null
    msisdn?: NullableStringFieldUpdateOperationsInput | string | null
    imsi?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    devices?: DeviceUncheckedUpdateManyWithoutSimNestedInput
  }

  export type UserUpsertWithoutSimActionsInput = {
    update: XOR<UserUpdateWithoutSimActionsInput, UserUncheckedUpdateWithoutSimActionsInput>
    create: XOR<UserCreateWithoutSimActionsInput, UserUncheckedCreateWithoutSimActionsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutSimActionsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutSimActionsInput, UserUncheckedUpdateWithoutSimActionsInput>
  }

  export type UserUpdateWithoutSimActionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    status?: EnumUserStatusFieldUpdateOperationsInput | $Enums.UserStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    memberships?: MembershipUpdateManyWithoutUserNestedInput
    commands?: CommandUpdateManyWithoutRequestedByNestedInput
    otaJobs?: OtaJobUpdateManyWithoutCreatedByNestedInput
    siteLocUpdates?: SiteUpdateManyWithoutLocationUpdatedByNestedInput
  }

  export type UserUncheckedUpdateWithoutSimActionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    status?: EnumUserStatusFieldUpdateOperationsInput | $Enums.UserStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    memberships?: MembershipUncheckedUpdateManyWithoutUserNestedInput
    commands?: CommandUncheckedUpdateManyWithoutRequestedByNestedInput
    otaJobs?: OtaJobUncheckedUpdateManyWithoutCreatedByNestedInput
    siteLocUpdates?: SiteUncheckedUpdateManyWithoutLocationUpdatedByNestedInput
  }

  export type TenantCreateWithoutAlertRulesInput = {
    id?: string
    name: string
    type: $Enums.TenantType
    status?: $Enums.TenantStatus
    settings?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    memberships?: MembershipCreateNestedManyWithoutTenantInput
    sites?: SiteCreateNestedManyWithoutTenantInput
    devices?: DeviceCreateNestedManyWithoutTenantInput
    alertEvents?: AlertEventCreateNestedManyWithoutTenantInput
    notificationChannels?: NotificationChannelCreateNestedManyWithoutTenantInput
    notificationEvents?: NotificationEventCreateNestedManyWithoutTenantInput
    dailyRollups?: DailyRollupCreateNestedManyWithoutTenantInput
    entitlements?: EntitlementCreateNestedManyWithoutTenantInput
    auditLogs?: AuditLogCreateNestedManyWithoutTenantInput
    otaJobs?: OtaJobCreateNestedManyWithoutTenantInput
    weatherData?: WeatherDataCreateNestedManyWithoutTenantInput
  }

  export type TenantUncheckedCreateWithoutAlertRulesInput = {
    id?: string
    name: string
    type: $Enums.TenantType
    status?: $Enums.TenantStatus
    settings?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    memberships?: MembershipUncheckedCreateNestedManyWithoutTenantInput
    sites?: SiteUncheckedCreateNestedManyWithoutTenantInput
    devices?: DeviceUncheckedCreateNestedManyWithoutTenantInput
    alertEvents?: AlertEventUncheckedCreateNestedManyWithoutTenantInput
    notificationChannels?: NotificationChannelUncheckedCreateNestedManyWithoutTenantInput
    notificationEvents?: NotificationEventUncheckedCreateNestedManyWithoutTenantInput
    dailyRollups?: DailyRollupUncheckedCreateNestedManyWithoutTenantInput
    entitlements?: EntitlementUncheckedCreateNestedManyWithoutTenantInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutTenantInput
    otaJobs?: OtaJobUncheckedCreateNestedManyWithoutTenantInput
    weatherData?: WeatherDataUncheckedCreateNestedManyWithoutTenantInput
  }

  export type TenantCreateOrConnectWithoutAlertRulesInput = {
    where: TenantWhereUniqueInput
    create: XOR<TenantCreateWithoutAlertRulesInput, TenantUncheckedCreateWithoutAlertRulesInput>
  }

  export type AlertEventCreateWithoutRuleInput = {
    id?: string
    severity: $Enums.AlertSeverity
    status?: $Enums.AlertEventStatus
    openedAt?: Date | string
    acknowledgedAt?: Date | string | null
    closedAt?: Date | string | null
    details?: NullableJsonNullValueInput | InputJsonValue
    dedupeKey?: string | null
    tenant: TenantCreateNestedOneWithoutAlertEventsInput
    device: DeviceCreateNestedOneWithoutAlertEventsInput
    notificationEvents?: NotificationEventCreateNestedManyWithoutAlertEventInput
  }

  export type AlertEventUncheckedCreateWithoutRuleInput = {
    id?: string
    tenantId: string
    deviceId: string
    severity: $Enums.AlertSeverity
    status?: $Enums.AlertEventStatus
    openedAt?: Date | string
    acknowledgedAt?: Date | string | null
    closedAt?: Date | string | null
    details?: NullableJsonNullValueInput | InputJsonValue
    dedupeKey?: string | null
    notificationEvents?: NotificationEventUncheckedCreateNestedManyWithoutAlertEventInput
  }

  export type AlertEventCreateOrConnectWithoutRuleInput = {
    where: AlertEventWhereUniqueInput
    create: XOR<AlertEventCreateWithoutRuleInput, AlertEventUncheckedCreateWithoutRuleInput>
  }

  export type AlertEventCreateManyRuleInputEnvelope = {
    data: AlertEventCreateManyRuleInput | AlertEventCreateManyRuleInput[]
    skipDuplicates?: boolean
  }

  export type TenantUpsertWithoutAlertRulesInput = {
    update: XOR<TenantUpdateWithoutAlertRulesInput, TenantUncheckedUpdateWithoutAlertRulesInput>
    create: XOR<TenantCreateWithoutAlertRulesInput, TenantUncheckedCreateWithoutAlertRulesInput>
    where?: TenantWhereInput
  }

  export type TenantUpdateToOneWithWhereWithoutAlertRulesInput = {
    where?: TenantWhereInput
    data: XOR<TenantUpdateWithoutAlertRulesInput, TenantUncheckedUpdateWithoutAlertRulesInput>
  }

  export type TenantUpdateWithoutAlertRulesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumTenantTypeFieldUpdateOperationsInput | $Enums.TenantType
    status?: EnumTenantStatusFieldUpdateOperationsInput | $Enums.TenantStatus
    settings?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    memberships?: MembershipUpdateManyWithoutTenantNestedInput
    sites?: SiteUpdateManyWithoutTenantNestedInput
    devices?: DeviceUpdateManyWithoutTenantNestedInput
    alertEvents?: AlertEventUpdateManyWithoutTenantNestedInput
    notificationChannels?: NotificationChannelUpdateManyWithoutTenantNestedInput
    notificationEvents?: NotificationEventUpdateManyWithoutTenantNestedInput
    dailyRollups?: DailyRollupUpdateManyWithoutTenantNestedInput
    entitlements?: EntitlementUpdateManyWithoutTenantNestedInput
    auditLogs?: AuditLogUpdateManyWithoutTenantNestedInput
    otaJobs?: OtaJobUpdateManyWithoutTenantNestedInput
    weatherData?: WeatherDataUpdateManyWithoutTenantNestedInput
  }

  export type TenantUncheckedUpdateWithoutAlertRulesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumTenantTypeFieldUpdateOperationsInput | $Enums.TenantType
    status?: EnumTenantStatusFieldUpdateOperationsInput | $Enums.TenantStatus
    settings?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    memberships?: MembershipUncheckedUpdateManyWithoutTenantNestedInput
    sites?: SiteUncheckedUpdateManyWithoutTenantNestedInput
    devices?: DeviceUncheckedUpdateManyWithoutTenantNestedInput
    alertEvents?: AlertEventUncheckedUpdateManyWithoutTenantNestedInput
    notificationChannels?: NotificationChannelUncheckedUpdateManyWithoutTenantNestedInput
    notificationEvents?: NotificationEventUncheckedUpdateManyWithoutTenantNestedInput
    dailyRollups?: DailyRollupUncheckedUpdateManyWithoutTenantNestedInput
    entitlements?: EntitlementUncheckedUpdateManyWithoutTenantNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutTenantNestedInput
    otaJobs?: OtaJobUncheckedUpdateManyWithoutTenantNestedInput
    weatherData?: WeatherDataUncheckedUpdateManyWithoutTenantNestedInput
  }

  export type AlertEventUpsertWithWhereUniqueWithoutRuleInput = {
    where: AlertEventWhereUniqueInput
    update: XOR<AlertEventUpdateWithoutRuleInput, AlertEventUncheckedUpdateWithoutRuleInput>
    create: XOR<AlertEventCreateWithoutRuleInput, AlertEventUncheckedCreateWithoutRuleInput>
  }

  export type AlertEventUpdateWithWhereUniqueWithoutRuleInput = {
    where: AlertEventWhereUniqueInput
    data: XOR<AlertEventUpdateWithoutRuleInput, AlertEventUncheckedUpdateWithoutRuleInput>
  }

  export type AlertEventUpdateManyWithWhereWithoutRuleInput = {
    where: AlertEventScalarWhereInput
    data: XOR<AlertEventUpdateManyMutationInput, AlertEventUncheckedUpdateManyWithoutRuleInput>
  }

  export type TenantCreateWithoutAlertEventsInput = {
    id?: string
    name: string
    type: $Enums.TenantType
    status?: $Enums.TenantStatus
    settings?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    memberships?: MembershipCreateNestedManyWithoutTenantInput
    sites?: SiteCreateNestedManyWithoutTenantInput
    devices?: DeviceCreateNestedManyWithoutTenantInput
    alertRules?: AlertRuleCreateNestedManyWithoutTenantInput
    notificationChannels?: NotificationChannelCreateNestedManyWithoutTenantInput
    notificationEvents?: NotificationEventCreateNestedManyWithoutTenantInput
    dailyRollups?: DailyRollupCreateNestedManyWithoutTenantInput
    entitlements?: EntitlementCreateNestedManyWithoutTenantInput
    auditLogs?: AuditLogCreateNestedManyWithoutTenantInput
    otaJobs?: OtaJobCreateNestedManyWithoutTenantInput
    weatherData?: WeatherDataCreateNestedManyWithoutTenantInput
  }

  export type TenantUncheckedCreateWithoutAlertEventsInput = {
    id?: string
    name: string
    type: $Enums.TenantType
    status?: $Enums.TenantStatus
    settings?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    memberships?: MembershipUncheckedCreateNestedManyWithoutTenantInput
    sites?: SiteUncheckedCreateNestedManyWithoutTenantInput
    devices?: DeviceUncheckedCreateNestedManyWithoutTenantInput
    alertRules?: AlertRuleUncheckedCreateNestedManyWithoutTenantInput
    notificationChannels?: NotificationChannelUncheckedCreateNestedManyWithoutTenantInput
    notificationEvents?: NotificationEventUncheckedCreateNestedManyWithoutTenantInput
    dailyRollups?: DailyRollupUncheckedCreateNestedManyWithoutTenantInput
    entitlements?: EntitlementUncheckedCreateNestedManyWithoutTenantInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutTenantInput
    otaJobs?: OtaJobUncheckedCreateNestedManyWithoutTenantInput
    weatherData?: WeatherDataUncheckedCreateNestedManyWithoutTenantInput
  }

  export type TenantCreateOrConnectWithoutAlertEventsInput = {
    where: TenantWhereUniqueInput
    create: XOR<TenantCreateWithoutAlertEventsInput, TenantUncheckedCreateWithoutAlertEventsInput>
  }

  export type DeviceCreateWithoutAlertEventsInput = {
    id?: string
    ownerUserId?: string | null
    model: string
    serialNumber: string
    name?: string | null
    notes?: string | null
    tags?: NullableJsonNullValueInput | InputJsonValue
    status?: $Enums.DeviceStatus
    lastSeenAt?: Date | string | null
    firmwareVersion?: string | null
    deviceLat?: number | null
    deviceLon?: number | null
    deviceLocationTs?: Date | string | null
    deviceLocationSource?: $Enums.DeviceLocationSource | null
    deviceLocationAccuracyM?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    tenant: TenantCreateNestedOneWithoutDevicesInput
    site?: SiteCreateNestedOneWithoutDevicesInput
    sim?: SimInfoCreateNestedOneWithoutDevicesInput
    secret?: DeviceSecretCreateNestedOneWithoutDeviceInput
    twin?: DeviceTwinCreateNestedOneWithoutDeviceInput
    telemetry?: TelemetryCreateNestedManyWithoutDeviceInput
    commands?: CommandCreateNestedManyWithoutDeviceInput
    dailyRollups?: DailyRollupCreateNestedManyWithoutDeviceInput
    entitlements?: EntitlementCreateNestedManyWithoutDeviceInput
  }

  export type DeviceUncheckedCreateWithoutAlertEventsInput = {
    id?: string
    tenantId: string
    siteId?: string | null
    ownerUserId?: string | null
    model: string
    serialNumber: string
    name?: string | null
    notes?: string | null
    tags?: NullableJsonNullValueInput | InputJsonValue
    status?: $Enums.DeviceStatus
    lastSeenAt?: Date | string | null
    firmwareVersion?: string | null
    simIccid?: string | null
    deviceLat?: number | null
    deviceLon?: number | null
    deviceLocationTs?: Date | string | null
    deviceLocationSource?: $Enums.DeviceLocationSource | null
    deviceLocationAccuracyM?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    secret?: DeviceSecretUncheckedCreateNestedOneWithoutDeviceInput
    twin?: DeviceTwinUncheckedCreateNestedOneWithoutDeviceInput
    telemetry?: TelemetryUncheckedCreateNestedManyWithoutDeviceInput
    commands?: CommandUncheckedCreateNestedManyWithoutDeviceInput
    dailyRollups?: DailyRollupUncheckedCreateNestedManyWithoutDeviceInput
    entitlements?: EntitlementUncheckedCreateNestedManyWithoutDeviceInput
  }

  export type DeviceCreateOrConnectWithoutAlertEventsInput = {
    where: DeviceWhereUniqueInput
    create: XOR<DeviceCreateWithoutAlertEventsInput, DeviceUncheckedCreateWithoutAlertEventsInput>
  }

  export type AlertRuleCreateWithoutAlertEventsInput = {
    id?: string
    name: string
    enabled?: boolean
    type: $Enums.AlertRuleType
    params: JsonNullValueInput | InputJsonValue
    severity?: $Enums.AlertSeverity
    createdAt?: Date | string
    updatedAt?: Date | string
    tenant: TenantCreateNestedOneWithoutAlertRulesInput
  }

  export type AlertRuleUncheckedCreateWithoutAlertEventsInput = {
    id?: string
    tenantId: string
    name: string
    enabled?: boolean
    type: $Enums.AlertRuleType
    params: JsonNullValueInput | InputJsonValue
    severity?: $Enums.AlertSeverity
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AlertRuleCreateOrConnectWithoutAlertEventsInput = {
    where: AlertRuleWhereUniqueInput
    create: XOR<AlertRuleCreateWithoutAlertEventsInput, AlertRuleUncheckedCreateWithoutAlertEventsInput>
  }

  export type NotificationEventCreateWithoutAlertEventInput = {
    id?: string
    status?: $Enums.NotificationEventStatus
    payload: JsonNullValueInput | InputJsonValue
    sentAt?: Date | string | null
    errorMsg?: string | null
    createdAt?: Date | string
    tenant: TenantCreateNestedOneWithoutNotificationEventsInput
    channel: NotificationChannelCreateNestedOneWithoutNotificationEventsInput
  }

  export type NotificationEventUncheckedCreateWithoutAlertEventInput = {
    id?: string
    tenantId: string
    channelId: string
    status?: $Enums.NotificationEventStatus
    payload: JsonNullValueInput | InputJsonValue
    sentAt?: Date | string | null
    errorMsg?: string | null
    createdAt?: Date | string
  }

  export type NotificationEventCreateOrConnectWithoutAlertEventInput = {
    where: NotificationEventWhereUniqueInput
    create: XOR<NotificationEventCreateWithoutAlertEventInput, NotificationEventUncheckedCreateWithoutAlertEventInput>
  }

  export type NotificationEventCreateManyAlertEventInputEnvelope = {
    data: NotificationEventCreateManyAlertEventInput | NotificationEventCreateManyAlertEventInput[]
    skipDuplicates?: boolean
  }

  export type TenantUpsertWithoutAlertEventsInput = {
    update: XOR<TenantUpdateWithoutAlertEventsInput, TenantUncheckedUpdateWithoutAlertEventsInput>
    create: XOR<TenantCreateWithoutAlertEventsInput, TenantUncheckedCreateWithoutAlertEventsInput>
    where?: TenantWhereInput
  }

  export type TenantUpdateToOneWithWhereWithoutAlertEventsInput = {
    where?: TenantWhereInput
    data: XOR<TenantUpdateWithoutAlertEventsInput, TenantUncheckedUpdateWithoutAlertEventsInput>
  }

  export type TenantUpdateWithoutAlertEventsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumTenantTypeFieldUpdateOperationsInput | $Enums.TenantType
    status?: EnumTenantStatusFieldUpdateOperationsInput | $Enums.TenantStatus
    settings?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    memberships?: MembershipUpdateManyWithoutTenantNestedInput
    sites?: SiteUpdateManyWithoutTenantNestedInput
    devices?: DeviceUpdateManyWithoutTenantNestedInput
    alertRules?: AlertRuleUpdateManyWithoutTenantNestedInput
    notificationChannels?: NotificationChannelUpdateManyWithoutTenantNestedInput
    notificationEvents?: NotificationEventUpdateManyWithoutTenantNestedInput
    dailyRollups?: DailyRollupUpdateManyWithoutTenantNestedInput
    entitlements?: EntitlementUpdateManyWithoutTenantNestedInput
    auditLogs?: AuditLogUpdateManyWithoutTenantNestedInput
    otaJobs?: OtaJobUpdateManyWithoutTenantNestedInput
    weatherData?: WeatherDataUpdateManyWithoutTenantNestedInput
  }

  export type TenantUncheckedUpdateWithoutAlertEventsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumTenantTypeFieldUpdateOperationsInput | $Enums.TenantType
    status?: EnumTenantStatusFieldUpdateOperationsInput | $Enums.TenantStatus
    settings?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    memberships?: MembershipUncheckedUpdateManyWithoutTenantNestedInput
    sites?: SiteUncheckedUpdateManyWithoutTenantNestedInput
    devices?: DeviceUncheckedUpdateManyWithoutTenantNestedInput
    alertRules?: AlertRuleUncheckedUpdateManyWithoutTenantNestedInput
    notificationChannels?: NotificationChannelUncheckedUpdateManyWithoutTenantNestedInput
    notificationEvents?: NotificationEventUncheckedUpdateManyWithoutTenantNestedInput
    dailyRollups?: DailyRollupUncheckedUpdateManyWithoutTenantNestedInput
    entitlements?: EntitlementUncheckedUpdateManyWithoutTenantNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutTenantNestedInput
    otaJobs?: OtaJobUncheckedUpdateManyWithoutTenantNestedInput
    weatherData?: WeatherDataUncheckedUpdateManyWithoutTenantNestedInput
  }

  export type DeviceUpsertWithoutAlertEventsInput = {
    update: XOR<DeviceUpdateWithoutAlertEventsInput, DeviceUncheckedUpdateWithoutAlertEventsInput>
    create: XOR<DeviceCreateWithoutAlertEventsInput, DeviceUncheckedCreateWithoutAlertEventsInput>
    where?: DeviceWhereInput
  }

  export type DeviceUpdateToOneWithWhereWithoutAlertEventsInput = {
    where?: DeviceWhereInput
    data: XOR<DeviceUpdateWithoutAlertEventsInput, DeviceUncheckedUpdateWithoutAlertEventsInput>
  }

  export type DeviceUpdateWithoutAlertEventsInput = {
    id?: StringFieldUpdateOperationsInput | string
    ownerUserId?: NullableStringFieldUpdateOperationsInput | string | null
    model?: StringFieldUpdateOperationsInput | string
    serialNumber?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: NullableJsonNullValueInput | InputJsonValue
    status?: EnumDeviceStatusFieldUpdateOperationsInput | $Enums.DeviceStatus
    lastSeenAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    firmwareVersion?: NullableStringFieldUpdateOperationsInput | string | null
    deviceLat?: NullableFloatFieldUpdateOperationsInput | number | null
    deviceLon?: NullableFloatFieldUpdateOperationsInput | number | null
    deviceLocationTs?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deviceLocationSource?: NullableEnumDeviceLocationSourceFieldUpdateOperationsInput | $Enums.DeviceLocationSource | null
    deviceLocationAccuracyM?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tenant?: TenantUpdateOneRequiredWithoutDevicesNestedInput
    site?: SiteUpdateOneWithoutDevicesNestedInput
    sim?: SimInfoUpdateOneWithoutDevicesNestedInput
    secret?: DeviceSecretUpdateOneWithoutDeviceNestedInput
    twin?: DeviceTwinUpdateOneWithoutDeviceNestedInput
    telemetry?: TelemetryUpdateManyWithoutDeviceNestedInput
    commands?: CommandUpdateManyWithoutDeviceNestedInput
    dailyRollups?: DailyRollupUpdateManyWithoutDeviceNestedInput
    entitlements?: EntitlementUpdateManyWithoutDeviceNestedInput
  }

  export type DeviceUncheckedUpdateWithoutAlertEventsInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    siteId?: NullableStringFieldUpdateOperationsInput | string | null
    ownerUserId?: NullableStringFieldUpdateOperationsInput | string | null
    model?: StringFieldUpdateOperationsInput | string
    serialNumber?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: NullableJsonNullValueInput | InputJsonValue
    status?: EnumDeviceStatusFieldUpdateOperationsInput | $Enums.DeviceStatus
    lastSeenAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    firmwareVersion?: NullableStringFieldUpdateOperationsInput | string | null
    simIccid?: NullableStringFieldUpdateOperationsInput | string | null
    deviceLat?: NullableFloatFieldUpdateOperationsInput | number | null
    deviceLon?: NullableFloatFieldUpdateOperationsInput | number | null
    deviceLocationTs?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deviceLocationSource?: NullableEnumDeviceLocationSourceFieldUpdateOperationsInput | $Enums.DeviceLocationSource | null
    deviceLocationAccuracyM?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    secret?: DeviceSecretUncheckedUpdateOneWithoutDeviceNestedInput
    twin?: DeviceTwinUncheckedUpdateOneWithoutDeviceNestedInput
    telemetry?: TelemetryUncheckedUpdateManyWithoutDeviceNestedInput
    commands?: CommandUncheckedUpdateManyWithoutDeviceNestedInput
    dailyRollups?: DailyRollupUncheckedUpdateManyWithoutDeviceNestedInput
    entitlements?: EntitlementUncheckedUpdateManyWithoutDeviceNestedInput
  }

  export type AlertRuleUpsertWithoutAlertEventsInput = {
    update: XOR<AlertRuleUpdateWithoutAlertEventsInput, AlertRuleUncheckedUpdateWithoutAlertEventsInput>
    create: XOR<AlertRuleCreateWithoutAlertEventsInput, AlertRuleUncheckedCreateWithoutAlertEventsInput>
    where?: AlertRuleWhereInput
  }

  export type AlertRuleUpdateToOneWithWhereWithoutAlertEventsInput = {
    where?: AlertRuleWhereInput
    data: XOR<AlertRuleUpdateWithoutAlertEventsInput, AlertRuleUncheckedUpdateWithoutAlertEventsInput>
  }

  export type AlertRuleUpdateWithoutAlertEventsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    enabled?: BoolFieldUpdateOperationsInput | boolean
    type?: EnumAlertRuleTypeFieldUpdateOperationsInput | $Enums.AlertRuleType
    params?: JsonNullValueInput | InputJsonValue
    severity?: EnumAlertSeverityFieldUpdateOperationsInput | $Enums.AlertSeverity
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tenant?: TenantUpdateOneRequiredWithoutAlertRulesNestedInput
  }

  export type AlertRuleUncheckedUpdateWithoutAlertEventsInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    enabled?: BoolFieldUpdateOperationsInput | boolean
    type?: EnumAlertRuleTypeFieldUpdateOperationsInput | $Enums.AlertRuleType
    params?: JsonNullValueInput | InputJsonValue
    severity?: EnumAlertSeverityFieldUpdateOperationsInput | $Enums.AlertSeverity
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationEventUpsertWithWhereUniqueWithoutAlertEventInput = {
    where: NotificationEventWhereUniqueInput
    update: XOR<NotificationEventUpdateWithoutAlertEventInput, NotificationEventUncheckedUpdateWithoutAlertEventInput>
    create: XOR<NotificationEventCreateWithoutAlertEventInput, NotificationEventUncheckedCreateWithoutAlertEventInput>
  }

  export type NotificationEventUpdateWithWhereUniqueWithoutAlertEventInput = {
    where: NotificationEventWhereUniqueInput
    data: XOR<NotificationEventUpdateWithoutAlertEventInput, NotificationEventUncheckedUpdateWithoutAlertEventInput>
  }

  export type NotificationEventUpdateManyWithWhereWithoutAlertEventInput = {
    where: NotificationEventScalarWhereInput
    data: XOR<NotificationEventUpdateManyMutationInput, NotificationEventUncheckedUpdateManyWithoutAlertEventInput>
  }

  export type TenantCreateWithoutNotificationChannelsInput = {
    id?: string
    name: string
    type: $Enums.TenantType
    status?: $Enums.TenantStatus
    settings?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    memberships?: MembershipCreateNestedManyWithoutTenantInput
    sites?: SiteCreateNestedManyWithoutTenantInput
    devices?: DeviceCreateNestedManyWithoutTenantInput
    alertRules?: AlertRuleCreateNestedManyWithoutTenantInput
    alertEvents?: AlertEventCreateNestedManyWithoutTenantInput
    notificationEvents?: NotificationEventCreateNestedManyWithoutTenantInput
    dailyRollups?: DailyRollupCreateNestedManyWithoutTenantInput
    entitlements?: EntitlementCreateNestedManyWithoutTenantInput
    auditLogs?: AuditLogCreateNestedManyWithoutTenantInput
    otaJobs?: OtaJobCreateNestedManyWithoutTenantInput
    weatherData?: WeatherDataCreateNestedManyWithoutTenantInput
  }

  export type TenantUncheckedCreateWithoutNotificationChannelsInput = {
    id?: string
    name: string
    type: $Enums.TenantType
    status?: $Enums.TenantStatus
    settings?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    memberships?: MembershipUncheckedCreateNestedManyWithoutTenantInput
    sites?: SiteUncheckedCreateNestedManyWithoutTenantInput
    devices?: DeviceUncheckedCreateNestedManyWithoutTenantInput
    alertRules?: AlertRuleUncheckedCreateNestedManyWithoutTenantInput
    alertEvents?: AlertEventUncheckedCreateNestedManyWithoutTenantInput
    notificationEvents?: NotificationEventUncheckedCreateNestedManyWithoutTenantInput
    dailyRollups?: DailyRollupUncheckedCreateNestedManyWithoutTenantInput
    entitlements?: EntitlementUncheckedCreateNestedManyWithoutTenantInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutTenantInput
    otaJobs?: OtaJobUncheckedCreateNestedManyWithoutTenantInput
    weatherData?: WeatherDataUncheckedCreateNestedManyWithoutTenantInput
  }

  export type TenantCreateOrConnectWithoutNotificationChannelsInput = {
    where: TenantWhereUniqueInput
    create: XOR<TenantCreateWithoutNotificationChannelsInput, TenantUncheckedCreateWithoutNotificationChannelsInput>
  }

  export type NotificationEventCreateWithoutChannelInput = {
    id?: string
    status?: $Enums.NotificationEventStatus
    payload: JsonNullValueInput | InputJsonValue
    sentAt?: Date | string | null
    errorMsg?: string | null
    createdAt?: Date | string
    tenant: TenantCreateNestedOneWithoutNotificationEventsInput
    alertEvent?: AlertEventCreateNestedOneWithoutNotificationEventsInput
  }

  export type NotificationEventUncheckedCreateWithoutChannelInput = {
    id?: string
    tenantId: string
    alertEventId?: string | null
    status?: $Enums.NotificationEventStatus
    payload: JsonNullValueInput | InputJsonValue
    sentAt?: Date | string | null
    errorMsg?: string | null
    createdAt?: Date | string
  }

  export type NotificationEventCreateOrConnectWithoutChannelInput = {
    where: NotificationEventWhereUniqueInput
    create: XOR<NotificationEventCreateWithoutChannelInput, NotificationEventUncheckedCreateWithoutChannelInput>
  }

  export type NotificationEventCreateManyChannelInputEnvelope = {
    data: NotificationEventCreateManyChannelInput | NotificationEventCreateManyChannelInput[]
    skipDuplicates?: boolean
  }

  export type TenantUpsertWithoutNotificationChannelsInput = {
    update: XOR<TenantUpdateWithoutNotificationChannelsInput, TenantUncheckedUpdateWithoutNotificationChannelsInput>
    create: XOR<TenantCreateWithoutNotificationChannelsInput, TenantUncheckedCreateWithoutNotificationChannelsInput>
    where?: TenantWhereInput
  }

  export type TenantUpdateToOneWithWhereWithoutNotificationChannelsInput = {
    where?: TenantWhereInput
    data: XOR<TenantUpdateWithoutNotificationChannelsInput, TenantUncheckedUpdateWithoutNotificationChannelsInput>
  }

  export type TenantUpdateWithoutNotificationChannelsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumTenantTypeFieldUpdateOperationsInput | $Enums.TenantType
    status?: EnumTenantStatusFieldUpdateOperationsInput | $Enums.TenantStatus
    settings?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    memberships?: MembershipUpdateManyWithoutTenantNestedInput
    sites?: SiteUpdateManyWithoutTenantNestedInput
    devices?: DeviceUpdateManyWithoutTenantNestedInput
    alertRules?: AlertRuleUpdateManyWithoutTenantNestedInput
    alertEvents?: AlertEventUpdateManyWithoutTenantNestedInput
    notificationEvents?: NotificationEventUpdateManyWithoutTenantNestedInput
    dailyRollups?: DailyRollupUpdateManyWithoutTenantNestedInput
    entitlements?: EntitlementUpdateManyWithoutTenantNestedInput
    auditLogs?: AuditLogUpdateManyWithoutTenantNestedInput
    otaJobs?: OtaJobUpdateManyWithoutTenantNestedInput
    weatherData?: WeatherDataUpdateManyWithoutTenantNestedInput
  }

  export type TenantUncheckedUpdateWithoutNotificationChannelsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumTenantTypeFieldUpdateOperationsInput | $Enums.TenantType
    status?: EnumTenantStatusFieldUpdateOperationsInput | $Enums.TenantStatus
    settings?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    memberships?: MembershipUncheckedUpdateManyWithoutTenantNestedInput
    sites?: SiteUncheckedUpdateManyWithoutTenantNestedInput
    devices?: DeviceUncheckedUpdateManyWithoutTenantNestedInput
    alertRules?: AlertRuleUncheckedUpdateManyWithoutTenantNestedInput
    alertEvents?: AlertEventUncheckedUpdateManyWithoutTenantNestedInput
    notificationEvents?: NotificationEventUncheckedUpdateManyWithoutTenantNestedInput
    dailyRollups?: DailyRollupUncheckedUpdateManyWithoutTenantNestedInput
    entitlements?: EntitlementUncheckedUpdateManyWithoutTenantNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutTenantNestedInput
    otaJobs?: OtaJobUncheckedUpdateManyWithoutTenantNestedInput
    weatherData?: WeatherDataUncheckedUpdateManyWithoutTenantNestedInput
  }

  export type NotificationEventUpsertWithWhereUniqueWithoutChannelInput = {
    where: NotificationEventWhereUniqueInput
    update: XOR<NotificationEventUpdateWithoutChannelInput, NotificationEventUncheckedUpdateWithoutChannelInput>
    create: XOR<NotificationEventCreateWithoutChannelInput, NotificationEventUncheckedCreateWithoutChannelInput>
  }

  export type NotificationEventUpdateWithWhereUniqueWithoutChannelInput = {
    where: NotificationEventWhereUniqueInput
    data: XOR<NotificationEventUpdateWithoutChannelInput, NotificationEventUncheckedUpdateWithoutChannelInput>
  }

  export type NotificationEventUpdateManyWithWhereWithoutChannelInput = {
    where: NotificationEventScalarWhereInput
    data: XOR<NotificationEventUpdateManyMutationInput, NotificationEventUncheckedUpdateManyWithoutChannelInput>
  }

  export type TenantCreateWithoutNotificationEventsInput = {
    id?: string
    name: string
    type: $Enums.TenantType
    status?: $Enums.TenantStatus
    settings?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    memberships?: MembershipCreateNestedManyWithoutTenantInput
    sites?: SiteCreateNestedManyWithoutTenantInput
    devices?: DeviceCreateNestedManyWithoutTenantInput
    alertRules?: AlertRuleCreateNestedManyWithoutTenantInput
    alertEvents?: AlertEventCreateNestedManyWithoutTenantInput
    notificationChannels?: NotificationChannelCreateNestedManyWithoutTenantInput
    dailyRollups?: DailyRollupCreateNestedManyWithoutTenantInput
    entitlements?: EntitlementCreateNestedManyWithoutTenantInput
    auditLogs?: AuditLogCreateNestedManyWithoutTenantInput
    otaJobs?: OtaJobCreateNestedManyWithoutTenantInput
    weatherData?: WeatherDataCreateNestedManyWithoutTenantInput
  }

  export type TenantUncheckedCreateWithoutNotificationEventsInput = {
    id?: string
    name: string
    type: $Enums.TenantType
    status?: $Enums.TenantStatus
    settings?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    memberships?: MembershipUncheckedCreateNestedManyWithoutTenantInput
    sites?: SiteUncheckedCreateNestedManyWithoutTenantInput
    devices?: DeviceUncheckedCreateNestedManyWithoutTenantInput
    alertRules?: AlertRuleUncheckedCreateNestedManyWithoutTenantInput
    alertEvents?: AlertEventUncheckedCreateNestedManyWithoutTenantInput
    notificationChannels?: NotificationChannelUncheckedCreateNestedManyWithoutTenantInput
    dailyRollups?: DailyRollupUncheckedCreateNestedManyWithoutTenantInput
    entitlements?: EntitlementUncheckedCreateNestedManyWithoutTenantInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutTenantInput
    otaJobs?: OtaJobUncheckedCreateNestedManyWithoutTenantInput
    weatherData?: WeatherDataUncheckedCreateNestedManyWithoutTenantInput
  }

  export type TenantCreateOrConnectWithoutNotificationEventsInput = {
    where: TenantWhereUniqueInput
    create: XOR<TenantCreateWithoutNotificationEventsInput, TenantUncheckedCreateWithoutNotificationEventsInput>
  }

  export type NotificationChannelCreateWithoutNotificationEventsInput = {
    id?: string
    type: $Enums.NotificationChannelType
    config: JsonNullValueInput | InputJsonValue
    enabled?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    tenant: TenantCreateNestedOneWithoutNotificationChannelsInput
  }

  export type NotificationChannelUncheckedCreateWithoutNotificationEventsInput = {
    id?: string
    tenantId: string
    type: $Enums.NotificationChannelType
    config: JsonNullValueInput | InputJsonValue
    enabled?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type NotificationChannelCreateOrConnectWithoutNotificationEventsInput = {
    where: NotificationChannelWhereUniqueInput
    create: XOR<NotificationChannelCreateWithoutNotificationEventsInput, NotificationChannelUncheckedCreateWithoutNotificationEventsInput>
  }

  export type AlertEventCreateWithoutNotificationEventsInput = {
    id?: string
    severity: $Enums.AlertSeverity
    status?: $Enums.AlertEventStatus
    openedAt?: Date | string
    acknowledgedAt?: Date | string | null
    closedAt?: Date | string | null
    details?: NullableJsonNullValueInput | InputJsonValue
    dedupeKey?: string | null
    tenant: TenantCreateNestedOneWithoutAlertEventsInput
    device: DeviceCreateNestedOneWithoutAlertEventsInput
    rule: AlertRuleCreateNestedOneWithoutAlertEventsInput
  }

  export type AlertEventUncheckedCreateWithoutNotificationEventsInput = {
    id?: string
    tenantId: string
    deviceId: string
    ruleId: string
    severity: $Enums.AlertSeverity
    status?: $Enums.AlertEventStatus
    openedAt?: Date | string
    acknowledgedAt?: Date | string | null
    closedAt?: Date | string | null
    details?: NullableJsonNullValueInput | InputJsonValue
    dedupeKey?: string | null
  }

  export type AlertEventCreateOrConnectWithoutNotificationEventsInput = {
    where: AlertEventWhereUniqueInput
    create: XOR<AlertEventCreateWithoutNotificationEventsInput, AlertEventUncheckedCreateWithoutNotificationEventsInput>
  }

  export type TenantUpsertWithoutNotificationEventsInput = {
    update: XOR<TenantUpdateWithoutNotificationEventsInput, TenantUncheckedUpdateWithoutNotificationEventsInput>
    create: XOR<TenantCreateWithoutNotificationEventsInput, TenantUncheckedCreateWithoutNotificationEventsInput>
    where?: TenantWhereInput
  }

  export type TenantUpdateToOneWithWhereWithoutNotificationEventsInput = {
    where?: TenantWhereInput
    data: XOR<TenantUpdateWithoutNotificationEventsInput, TenantUncheckedUpdateWithoutNotificationEventsInput>
  }

  export type TenantUpdateWithoutNotificationEventsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumTenantTypeFieldUpdateOperationsInput | $Enums.TenantType
    status?: EnumTenantStatusFieldUpdateOperationsInput | $Enums.TenantStatus
    settings?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    memberships?: MembershipUpdateManyWithoutTenantNestedInput
    sites?: SiteUpdateManyWithoutTenantNestedInput
    devices?: DeviceUpdateManyWithoutTenantNestedInput
    alertRules?: AlertRuleUpdateManyWithoutTenantNestedInput
    alertEvents?: AlertEventUpdateManyWithoutTenantNestedInput
    notificationChannels?: NotificationChannelUpdateManyWithoutTenantNestedInput
    dailyRollups?: DailyRollupUpdateManyWithoutTenantNestedInput
    entitlements?: EntitlementUpdateManyWithoutTenantNestedInput
    auditLogs?: AuditLogUpdateManyWithoutTenantNestedInput
    otaJobs?: OtaJobUpdateManyWithoutTenantNestedInput
    weatherData?: WeatherDataUpdateManyWithoutTenantNestedInput
  }

  export type TenantUncheckedUpdateWithoutNotificationEventsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumTenantTypeFieldUpdateOperationsInput | $Enums.TenantType
    status?: EnumTenantStatusFieldUpdateOperationsInput | $Enums.TenantStatus
    settings?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    memberships?: MembershipUncheckedUpdateManyWithoutTenantNestedInput
    sites?: SiteUncheckedUpdateManyWithoutTenantNestedInput
    devices?: DeviceUncheckedUpdateManyWithoutTenantNestedInput
    alertRules?: AlertRuleUncheckedUpdateManyWithoutTenantNestedInput
    alertEvents?: AlertEventUncheckedUpdateManyWithoutTenantNestedInput
    notificationChannels?: NotificationChannelUncheckedUpdateManyWithoutTenantNestedInput
    dailyRollups?: DailyRollupUncheckedUpdateManyWithoutTenantNestedInput
    entitlements?: EntitlementUncheckedUpdateManyWithoutTenantNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutTenantNestedInput
    otaJobs?: OtaJobUncheckedUpdateManyWithoutTenantNestedInput
    weatherData?: WeatherDataUncheckedUpdateManyWithoutTenantNestedInput
  }

  export type NotificationChannelUpsertWithoutNotificationEventsInput = {
    update: XOR<NotificationChannelUpdateWithoutNotificationEventsInput, NotificationChannelUncheckedUpdateWithoutNotificationEventsInput>
    create: XOR<NotificationChannelCreateWithoutNotificationEventsInput, NotificationChannelUncheckedCreateWithoutNotificationEventsInput>
    where?: NotificationChannelWhereInput
  }

  export type NotificationChannelUpdateToOneWithWhereWithoutNotificationEventsInput = {
    where?: NotificationChannelWhereInput
    data: XOR<NotificationChannelUpdateWithoutNotificationEventsInput, NotificationChannelUncheckedUpdateWithoutNotificationEventsInput>
  }

  export type NotificationChannelUpdateWithoutNotificationEventsInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumNotificationChannelTypeFieldUpdateOperationsInput | $Enums.NotificationChannelType
    config?: JsonNullValueInput | InputJsonValue
    enabled?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tenant?: TenantUpdateOneRequiredWithoutNotificationChannelsNestedInput
  }

  export type NotificationChannelUncheckedUpdateWithoutNotificationEventsInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    type?: EnumNotificationChannelTypeFieldUpdateOperationsInput | $Enums.NotificationChannelType
    config?: JsonNullValueInput | InputJsonValue
    enabled?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AlertEventUpsertWithoutNotificationEventsInput = {
    update: XOR<AlertEventUpdateWithoutNotificationEventsInput, AlertEventUncheckedUpdateWithoutNotificationEventsInput>
    create: XOR<AlertEventCreateWithoutNotificationEventsInput, AlertEventUncheckedCreateWithoutNotificationEventsInput>
    where?: AlertEventWhereInput
  }

  export type AlertEventUpdateToOneWithWhereWithoutNotificationEventsInput = {
    where?: AlertEventWhereInput
    data: XOR<AlertEventUpdateWithoutNotificationEventsInput, AlertEventUncheckedUpdateWithoutNotificationEventsInput>
  }

  export type AlertEventUpdateWithoutNotificationEventsInput = {
    id?: StringFieldUpdateOperationsInput | string
    severity?: EnumAlertSeverityFieldUpdateOperationsInput | $Enums.AlertSeverity
    status?: EnumAlertEventStatusFieldUpdateOperationsInput | $Enums.AlertEventStatus
    openedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    acknowledgedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    closedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    details?: NullableJsonNullValueInput | InputJsonValue
    dedupeKey?: NullableStringFieldUpdateOperationsInput | string | null
    tenant?: TenantUpdateOneRequiredWithoutAlertEventsNestedInput
    device?: DeviceUpdateOneRequiredWithoutAlertEventsNestedInput
    rule?: AlertRuleUpdateOneRequiredWithoutAlertEventsNestedInput
  }

  export type AlertEventUncheckedUpdateWithoutNotificationEventsInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    deviceId?: StringFieldUpdateOperationsInput | string
    ruleId?: StringFieldUpdateOperationsInput | string
    severity?: EnumAlertSeverityFieldUpdateOperationsInput | $Enums.AlertSeverity
    status?: EnumAlertEventStatusFieldUpdateOperationsInput | $Enums.AlertEventStatus
    openedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    acknowledgedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    closedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    details?: NullableJsonNullValueInput | InputJsonValue
    dedupeKey?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type TenantCreateWithoutDailyRollupsInput = {
    id?: string
    name: string
    type: $Enums.TenantType
    status?: $Enums.TenantStatus
    settings?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    memberships?: MembershipCreateNestedManyWithoutTenantInput
    sites?: SiteCreateNestedManyWithoutTenantInput
    devices?: DeviceCreateNestedManyWithoutTenantInput
    alertRules?: AlertRuleCreateNestedManyWithoutTenantInput
    alertEvents?: AlertEventCreateNestedManyWithoutTenantInput
    notificationChannels?: NotificationChannelCreateNestedManyWithoutTenantInput
    notificationEvents?: NotificationEventCreateNestedManyWithoutTenantInput
    entitlements?: EntitlementCreateNestedManyWithoutTenantInput
    auditLogs?: AuditLogCreateNestedManyWithoutTenantInput
    otaJobs?: OtaJobCreateNestedManyWithoutTenantInput
    weatherData?: WeatherDataCreateNestedManyWithoutTenantInput
  }

  export type TenantUncheckedCreateWithoutDailyRollupsInput = {
    id?: string
    name: string
    type: $Enums.TenantType
    status?: $Enums.TenantStatus
    settings?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    memberships?: MembershipUncheckedCreateNestedManyWithoutTenantInput
    sites?: SiteUncheckedCreateNestedManyWithoutTenantInput
    devices?: DeviceUncheckedCreateNestedManyWithoutTenantInput
    alertRules?: AlertRuleUncheckedCreateNestedManyWithoutTenantInput
    alertEvents?: AlertEventUncheckedCreateNestedManyWithoutTenantInput
    notificationChannels?: NotificationChannelUncheckedCreateNestedManyWithoutTenantInput
    notificationEvents?: NotificationEventUncheckedCreateNestedManyWithoutTenantInput
    entitlements?: EntitlementUncheckedCreateNestedManyWithoutTenantInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutTenantInput
    otaJobs?: OtaJobUncheckedCreateNestedManyWithoutTenantInput
    weatherData?: WeatherDataUncheckedCreateNestedManyWithoutTenantInput
  }

  export type TenantCreateOrConnectWithoutDailyRollupsInput = {
    where: TenantWhereUniqueInput
    create: XOR<TenantCreateWithoutDailyRollupsInput, TenantUncheckedCreateWithoutDailyRollupsInput>
  }

  export type DeviceCreateWithoutDailyRollupsInput = {
    id?: string
    ownerUserId?: string | null
    model: string
    serialNumber: string
    name?: string | null
    notes?: string | null
    tags?: NullableJsonNullValueInput | InputJsonValue
    status?: $Enums.DeviceStatus
    lastSeenAt?: Date | string | null
    firmwareVersion?: string | null
    deviceLat?: number | null
    deviceLon?: number | null
    deviceLocationTs?: Date | string | null
    deviceLocationSource?: $Enums.DeviceLocationSource | null
    deviceLocationAccuracyM?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    tenant: TenantCreateNestedOneWithoutDevicesInput
    site?: SiteCreateNestedOneWithoutDevicesInput
    sim?: SimInfoCreateNestedOneWithoutDevicesInput
    secret?: DeviceSecretCreateNestedOneWithoutDeviceInput
    twin?: DeviceTwinCreateNestedOneWithoutDeviceInput
    telemetry?: TelemetryCreateNestedManyWithoutDeviceInput
    commands?: CommandCreateNestedManyWithoutDeviceInput
    alertEvents?: AlertEventCreateNestedManyWithoutDeviceInput
    entitlements?: EntitlementCreateNestedManyWithoutDeviceInput
  }

  export type DeviceUncheckedCreateWithoutDailyRollupsInput = {
    id?: string
    tenantId: string
    siteId?: string | null
    ownerUserId?: string | null
    model: string
    serialNumber: string
    name?: string | null
    notes?: string | null
    tags?: NullableJsonNullValueInput | InputJsonValue
    status?: $Enums.DeviceStatus
    lastSeenAt?: Date | string | null
    firmwareVersion?: string | null
    simIccid?: string | null
    deviceLat?: number | null
    deviceLon?: number | null
    deviceLocationTs?: Date | string | null
    deviceLocationSource?: $Enums.DeviceLocationSource | null
    deviceLocationAccuracyM?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    secret?: DeviceSecretUncheckedCreateNestedOneWithoutDeviceInput
    twin?: DeviceTwinUncheckedCreateNestedOneWithoutDeviceInput
    telemetry?: TelemetryUncheckedCreateNestedManyWithoutDeviceInput
    commands?: CommandUncheckedCreateNestedManyWithoutDeviceInput
    alertEvents?: AlertEventUncheckedCreateNestedManyWithoutDeviceInput
    entitlements?: EntitlementUncheckedCreateNestedManyWithoutDeviceInput
  }

  export type DeviceCreateOrConnectWithoutDailyRollupsInput = {
    where: DeviceWhereUniqueInput
    create: XOR<DeviceCreateWithoutDailyRollupsInput, DeviceUncheckedCreateWithoutDailyRollupsInput>
  }

  export type TenantUpsertWithoutDailyRollupsInput = {
    update: XOR<TenantUpdateWithoutDailyRollupsInput, TenantUncheckedUpdateWithoutDailyRollupsInput>
    create: XOR<TenantCreateWithoutDailyRollupsInput, TenantUncheckedCreateWithoutDailyRollupsInput>
    where?: TenantWhereInput
  }

  export type TenantUpdateToOneWithWhereWithoutDailyRollupsInput = {
    where?: TenantWhereInput
    data: XOR<TenantUpdateWithoutDailyRollupsInput, TenantUncheckedUpdateWithoutDailyRollupsInput>
  }

  export type TenantUpdateWithoutDailyRollupsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumTenantTypeFieldUpdateOperationsInput | $Enums.TenantType
    status?: EnumTenantStatusFieldUpdateOperationsInput | $Enums.TenantStatus
    settings?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    memberships?: MembershipUpdateManyWithoutTenantNestedInput
    sites?: SiteUpdateManyWithoutTenantNestedInput
    devices?: DeviceUpdateManyWithoutTenantNestedInput
    alertRules?: AlertRuleUpdateManyWithoutTenantNestedInput
    alertEvents?: AlertEventUpdateManyWithoutTenantNestedInput
    notificationChannels?: NotificationChannelUpdateManyWithoutTenantNestedInput
    notificationEvents?: NotificationEventUpdateManyWithoutTenantNestedInput
    entitlements?: EntitlementUpdateManyWithoutTenantNestedInput
    auditLogs?: AuditLogUpdateManyWithoutTenantNestedInput
    otaJobs?: OtaJobUpdateManyWithoutTenantNestedInput
    weatherData?: WeatherDataUpdateManyWithoutTenantNestedInput
  }

  export type TenantUncheckedUpdateWithoutDailyRollupsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumTenantTypeFieldUpdateOperationsInput | $Enums.TenantType
    status?: EnumTenantStatusFieldUpdateOperationsInput | $Enums.TenantStatus
    settings?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    memberships?: MembershipUncheckedUpdateManyWithoutTenantNestedInput
    sites?: SiteUncheckedUpdateManyWithoutTenantNestedInput
    devices?: DeviceUncheckedUpdateManyWithoutTenantNestedInput
    alertRules?: AlertRuleUncheckedUpdateManyWithoutTenantNestedInput
    alertEvents?: AlertEventUncheckedUpdateManyWithoutTenantNestedInput
    notificationChannels?: NotificationChannelUncheckedUpdateManyWithoutTenantNestedInput
    notificationEvents?: NotificationEventUncheckedUpdateManyWithoutTenantNestedInput
    entitlements?: EntitlementUncheckedUpdateManyWithoutTenantNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutTenantNestedInput
    otaJobs?: OtaJobUncheckedUpdateManyWithoutTenantNestedInput
    weatherData?: WeatherDataUncheckedUpdateManyWithoutTenantNestedInput
  }

  export type DeviceUpsertWithoutDailyRollupsInput = {
    update: XOR<DeviceUpdateWithoutDailyRollupsInput, DeviceUncheckedUpdateWithoutDailyRollupsInput>
    create: XOR<DeviceCreateWithoutDailyRollupsInput, DeviceUncheckedCreateWithoutDailyRollupsInput>
    where?: DeviceWhereInput
  }

  export type DeviceUpdateToOneWithWhereWithoutDailyRollupsInput = {
    where?: DeviceWhereInput
    data: XOR<DeviceUpdateWithoutDailyRollupsInput, DeviceUncheckedUpdateWithoutDailyRollupsInput>
  }

  export type DeviceUpdateWithoutDailyRollupsInput = {
    id?: StringFieldUpdateOperationsInput | string
    ownerUserId?: NullableStringFieldUpdateOperationsInput | string | null
    model?: StringFieldUpdateOperationsInput | string
    serialNumber?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: NullableJsonNullValueInput | InputJsonValue
    status?: EnumDeviceStatusFieldUpdateOperationsInput | $Enums.DeviceStatus
    lastSeenAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    firmwareVersion?: NullableStringFieldUpdateOperationsInput | string | null
    deviceLat?: NullableFloatFieldUpdateOperationsInput | number | null
    deviceLon?: NullableFloatFieldUpdateOperationsInput | number | null
    deviceLocationTs?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deviceLocationSource?: NullableEnumDeviceLocationSourceFieldUpdateOperationsInput | $Enums.DeviceLocationSource | null
    deviceLocationAccuracyM?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tenant?: TenantUpdateOneRequiredWithoutDevicesNestedInput
    site?: SiteUpdateOneWithoutDevicesNestedInput
    sim?: SimInfoUpdateOneWithoutDevicesNestedInput
    secret?: DeviceSecretUpdateOneWithoutDeviceNestedInput
    twin?: DeviceTwinUpdateOneWithoutDeviceNestedInput
    telemetry?: TelemetryUpdateManyWithoutDeviceNestedInput
    commands?: CommandUpdateManyWithoutDeviceNestedInput
    alertEvents?: AlertEventUpdateManyWithoutDeviceNestedInput
    entitlements?: EntitlementUpdateManyWithoutDeviceNestedInput
  }

  export type DeviceUncheckedUpdateWithoutDailyRollupsInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    siteId?: NullableStringFieldUpdateOperationsInput | string | null
    ownerUserId?: NullableStringFieldUpdateOperationsInput | string | null
    model?: StringFieldUpdateOperationsInput | string
    serialNumber?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: NullableJsonNullValueInput | InputJsonValue
    status?: EnumDeviceStatusFieldUpdateOperationsInput | $Enums.DeviceStatus
    lastSeenAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    firmwareVersion?: NullableStringFieldUpdateOperationsInput | string | null
    simIccid?: NullableStringFieldUpdateOperationsInput | string | null
    deviceLat?: NullableFloatFieldUpdateOperationsInput | number | null
    deviceLon?: NullableFloatFieldUpdateOperationsInput | number | null
    deviceLocationTs?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deviceLocationSource?: NullableEnumDeviceLocationSourceFieldUpdateOperationsInput | $Enums.DeviceLocationSource | null
    deviceLocationAccuracyM?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    secret?: DeviceSecretUncheckedUpdateOneWithoutDeviceNestedInput
    twin?: DeviceTwinUncheckedUpdateOneWithoutDeviceNestedInput
    telemetry?: TelemetryUncheckedUpdateManyWithoutDeviceNestedInput
    commands?: CommandUncheckedUpdateManyWithoutDeviceNestedInput
    alertEvents?: AlertEventUncheckedUpdateManyWithoutDeviceNestedInput
    entitlements?: EntitlementUncheckedUpdateManyWithoutDeviceNestedInput
  }

  export type TenantCreateWithoutEntitlementsInput = {
    id?: string
    name: string
    type: $Enums.TenantType
    status?: $Enums.TenantStatus
    settings?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    memberships?: MembershipCreateNestedManyWithoutTenantInput
    sites?: SiteCreateNestedManyWithoutTenantInput
    devices?: DeviceCreateNestedManyWithoutTenantInput
    alertRules?: AlertRuleCreateNestedManyWithoutTenantInput
    alertEvents?: AlertEventCreateNestedManyWithoutTenantInput
    notificationChannels?: NotificationChannelCreateNestedManyWithoutTenantInput
    notificationEvents?: NotificationEventCreateNestedManyWithoutTenantInput
    dailyRollups?: DailyRollupCreateNestedManyWithoutTenantInput
    auditLogs?: AuditLogCreateNestedManyWithoutTenantInput
    otaJobs?: OtaJobCreateNestedManyWithoutTenantInput
    weatherData?: WeatherDataCreateNestedManyWithoutTenantInput
  }

  export type TenantUncheckedCreateWithoutEntitlementsInput = {
    id?: string
    name: string
    type: $Enums.TenantType
    status?: $Enums.TenantStatus
    settings?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    memberships?: MembershipUncheckedCreateNestedManyWithoutTenantInput
    sites?: SiteUncheckedCreateNestedManyWithoutTenantInput
    devices?: DeviceUncheckedCreateNestedManyWithoutTenantInput
    alertRules?: AlertRuleUncheckedCreateNestedManyWithoutTenantInput
    alertEvents?: AlertEventUncheckedCreateNestedManyWithoutTenantInput
    notificationChannels?: NotificationChannelUncheckedCreateNestedManyWithoutTenantInput
    notificationEvents?: NotificationEventUncheckedCreateNestedManyWithoutTenantInput
    dailyRollups?: DailyRollupUncheckedCreateNestedManyWithoutTenantInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutTenantInput
    otaJobs?: OtaJobUncheckedCreateNestedManyWithoutTenantInput
    weatherData?: WeatherDataUncheckedCreateNestedManyWithoutTenantInput
  }

  export type TenantCreateOrConnectWithoutEntitlementsInput = {
    where: TenantWhereUniqueInput
    create: XOR<TenantCreateWithoutEntitlementsInput, TenantUncheckedCreateWithoutEntitlementsInput>
  }

  export type DeviceCreateWithoutEntitlementsInput = {
    id?: string
    ownerUserId?: string | null
    model: string
    serialNumber: string
    name?: string | null
    notes?: string | null
    tags?: NullableJsonNullValueInput | InputJsonValue
    status?: $Enums.DeviceStatus
    lastSeenAt?: Date | string | null
    firmwareVersion?: string | null
    deviceLat?: number | null
    deviceLon?: number | null
    deviceLocationTs?: Date | string | null
    deviceLocationSource?: $Enums.DeviceLocationSource | null
    deviceLocationAccuracyM?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    tenant: TenantCreateNestedOneWithoutDevicesInput
    site?: SiteCreateNestedOneWithoutDevicesInput
    sim?: SimInfoCreateNestedOneWithoutDevicesInput
    secret?: DeviceSecretCreateNestedOneWithoutDeviceInput
    twin?: DeviceTwinCreateNestedOneWithoutDeviceInput
    telemetry?: TelemetryCreateNestedManyWithoutDeviceInput
    commands?: CommandCreateNestedManyWithoutDeviceInput
    alertEvents?: AlertEventCreateNestedManyWithoutDeviceInput
    dailyRollups?: DailyRollupCreateNestedManyWithoutDeviceInput
  }

  export type DeviceUncheckedCreateWithoutEntitlementsInput = {
    id?: string
    tenantId: string
    siteId?: string | null
    ownerUserId?: string | null
    model: string
    serialNumber: string
    name?: string | null
    notes?: string | null
    tags?: NullableJsonNullValueInput | InputJsonValue
    status?: $Enums.DeviceStatus
    lastSeenAt?: Date | string | null
    firmwareVersion?: string | null
    simIccid?: string | null
    deviceLat?: number | null
    deviceLon?: number | null
    deviceLocationTs?: Date | string | null
    deviceLocationSource?: $Enums.DeviceLocationSource | null
    deviceLocationAccuracyM?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    secret?: DeviceSecretUncheckedCreateNestedOneWithoutDeviceInput
    twin?: DeviceTwinUncheckedCreateNestedOneWithoutDeviceInput
    telemetry?: TelemetryUncheckedCreateNestedManyWithoutDeviceInput
    commands?: CommandUncheckedCreateNestedManyWithoutDeviceInput
    alertEvents?: AlertEventUncheckedCreateNestedManyWithoutDeviceInput
    dailyRollups?: DailyRollupUncheckedCreateNestedManyWithoutDeviceInput
  }

  export type DeviceCreateOrConnectWithoutEntitlementsInput = {
    where: DeviceWhereUniqueInput
    create: XOR<DeviceCreateWithoutEntitlementsInput, DeviceUncheckedCreateWithoutEntitlementsInput>
  }

  export type TenantUpsertWithoutEntitlementsInput = {
    update: XOR<TenantUpdateWithoutEntitlementsInput, TenantUncheckedUpdateWithoutEntitlementsInput>
    create: XOR<TenantCreateWithoutEntitlementsInput, TenantUncheckedCreateWithoutEntitlementsInput>
    where?: TenantWhereInput
  }

  export type TenantUpdateToOneWithWhereWithoutEntitlementsInput = {
    where?: TenantWhereInput
    data: XOR<TenantUpdateWithoutEntitlementsInput, TenantUncheckedUpdateWithoutEntitlementsInput>
  }

  export type TenantUpdateWithoutEntitlementsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumTenantTypeFieldUpdateOperationsInput | $Enums.TenantType
    status?: EnumTenantStatusFieldUpdateOperationsInput | $Enums.TenantStatus
    settings?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    memberships?: MembershipUpdateManyWithoutTenantNestedInput
    sites?: SiteUpdateManyWithoutTenantNestedInput
    devices?: DeviceUpdateManyWithoutTenantNestedInput
    alertRules?: AlertRuleUpdateManyWithoutTenantNestedInput
    alertEvents?: AlertEventUpdateManyWithoutTenantNestedInput
    notificationChannels?: NotificationChannelUpdateManyWithoutTenantNestedInput
    notificationEvents?: NotificationEventUpdateManyWithoutTenantNestedInput
    dailyRollups?: DailyRollupUpdateManyWithoutTenantNestedInput
    auditLogs?: AuditLogUpdateManyWithoutTenantNestedInput
    otaJobs?: OtaJobUpdateManyWithoutTenantNestedInput
    weatherData?: WeatherDataUpdateManyWithoutTenantNestedInput
  }

  export type TenantUncheckedUpdateWithoutEntitlementsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumTenantTypeFieldUpdateOperationsInput | $Enums.TenantType
    status?: EnumTenantStatusFieldUpdateOperationsInput | $Enums.TenantStatus
    settings?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    memberships?: MembershipUncheckedUpdateManyWithoutTenantNestedInput
    sites?: SiteUncheckedUpdateManyWithoutTenantNestedInput
    devices?: DeviceUncheckedUpdateManyWithoutTenantNestedInput
    alertRules?: AlertRuleUncheckedUpdateManyWithoutTenantNestedInput
    alertEvents?: AlertEventUncheckedUpdateManyWithoutTenantNestedInput
    notificationChannels?: NotificationChannelUncheckedUpdateManyWithoutTenantNestedInput
    notificationEvents?: NotificationEventUncheckedUpdateManyWithoutTenantNestedInput
    dailyRollups?: DailyRollupUncheckedUpdateManyWithoutTenantNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutTenantNestedInput
    otaJobs?: OtaJobUncheckedUpdateManyWithoutTenantNestedInput
    weatherData?: WeatherDataUncheckedUpdateManyWithoutTenantNestedInput
  }

  export type DeviceUpsertWithoutEntitlementsInput = {
    update: XOR<DeviceUpdateWithoutEntitlementsInput, DeviceUncheckedUpdateWithoutEntitlementsInput>
    create: XOR<DeviceCreateWithoutEntitlementsInput, DeviceUncheckedCreateWithoutEntitlementsInput>
    where?: DeviceWhereInput
  }

  export type DeviceUpdateToOneWithWhereWithoutEntitlementsInput = {
    where?: DeviceWhereInput
    data: XOR<DeviceUpdateWithoutEntitlementsInput, DeviceUncheckedUpdateWithoutEntitlementsInput>
  }

  export type DeviceUpdateWithoutEntitlementsInput = {
    id?: StringFieldUpdateOperationsInput | string
    ownerUserId?: NullableStringFieldUpdateOperationsInput | string | null
    model?: StringFieldUpdateOperationsInput | string
    serialNumber?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: NullableJsonNullValueInput | InputJsonValue
    status?: EnumDeviceStatusFieldUpdateOperationsInput | $Enums.DeviceStatus
    lastSeenAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    firmwareVersion?: NullableStringFieldUpdateOperationsInput | string | null
    deviceLat?: NullableFloatFieldUpdateOperationsInput | number | null
    deviceLon?: NullableFloatFieldUpdateOperationsInput | number | null
    deviceLocationTs?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deviceLocationSource?: NullableEnumDeviceLocationSourceFieldUpdateOperationsInput | $Enums.DeviceLocationSource | null
    deviceLocationAccuracyM?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tenant?: TenantUpdateOneRequiredWithoutDevicesNestedInput
    site?: SiteUpdateOneWithoutDevicesNestedInput
    sim?: SimInfoUpdateOneWithoutDevicesNestedInput
    secret?: DeviceSecretUpdateOneWithoutDeviceNestedInput
    twin?: DeviceTwinUpdateOneWithoutDeviceNestedInput
    telemetry?: TelemetryUpdateManyWithoutDeviceNestedInput
    commands?: CommandUpdateManyWithoutDeviceNestedInput
    alertEvents?: AlertEventUpdateManyWithoutDeviceNestedInput
    dailyRollups?: DailyRollupUpdateManyWithoutDeviceNestedInput
  }

  export type DeviceUncheckedUpdateWithoutEntitlementsInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    siteId?: NullableStringFieldUpdateOperationsInput | string | null
    ownerUserId?: NullableStringFieldUpdateOperationsInput | string | null
    model?: StringFieldUpdateOperationsInput | string
    serialNumber?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: NullableJsonNullValueInput | InputJsonValue
    status?: EnumDeviceStatusFieldUpdateOperationsInput | $Enums.DeviceStatus
    lastSeenAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    firmwareVersion?: NullableStringFieldUpdateOperationsInput | string | null
    simIccid?: NullableStringFieldUpdateOperationsInput | string | null
    deviceLat?: NullableFloatFieldUpdateOperationsInput | number | null
    deviceLon?: NullableFloatFieldUpdateOperationsInput | number | null
    deviceLocationTs?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deviceLocationSource?: NullableEnumDeviceLocationSourceFieldUpdateOperationsInput | $Enums.DeviceLocationSource | null
    deviceLocationAccuracyM?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    secret?: DeviceSecretUncheckedUpdateOneWithoutDeviceNestedInput
    twin?: DeviceTwinUncheckedUpdateOneWithoutDeviceNestedInput
    telemetry?: TelemetryUncheckedUpdateManyWithoutDeviceNestedInput
    commands?: CommandUncheckedUpdateManyWithoutDeviceNestedInput
    alertEvents?: AlertEventUncheckedUpdateManyWithoutDeviceNestedInput
    dailyRollups?: DailyRollupUncheckedUpdateManyWithoutDeviceNestedInput
  }

  export type TenantCreateWithoutAuditLogsInput = {
    id?: string
    name: string
    type: $Enums.TenantType
    status?: $Enums.TenantStatus
    settings?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    memberships?: MembershipCreateNestedManyWithoutTenantInput
    sites?: SiteCreateNestedManyWithoutTenantInput
    devices?: DeviceCreateNestedManyWithoutTenantInput
    alertRules?: AlertRuleCreateNestedManyWithoutTenantInput
    alertEvents?: AlertEventCreateNestedManyWithoutTenantInput
    notificationChannels?: NotificationChannelCreateNestedManyWithoutTenantInput
    notificationEvents?: NotificationEventCreateNestedManyWithoutTenantInput
    dailyRollups?: DailyRollupCreateNestedManyWithoutTenantInput
    entitlements?: EntitlementCreateNestedManyWithoutTenantInput
    otaJobs?: OtaJobCreateNestedManyWithoutTenantInput
    weatherData?: WeatherDataCreateNestedManyWithoutTenantInput
  }

  export type TenantUncheckedCreateWithoutAuditLogsInput = {
    id?: string
    name: string
    type: $Enums.TenantType
    status?: $Enums.TenantStatus
    settings?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    memberships?: MembershipUncheckedCreateNestedManyWithoutTenantInput
    sites?: SiteUncheckedCreateNestedManyWithoutTenantInput
    devices?: DeviceUncheckedCreateNestedManyWithoutTenantInput
    alertRules?: AlertRuleUncheckedCreateNestedManyWithoutTenantInput
    alertEvents?: AlertEventUncheckedCreateNestedManyWithoutTenantInput
    notificationChannels?: NotificationChannelUncheckedCreateNestedManyWithoutTenantInput
    notificationEvents?: NotificationEventUncheckedCreateNestedManyWithoutTenantInput
    dailyRollups?: DailyRollupUncheckedCreateNestedManyWithoutTenantInput
    entitlements?: EntitlementUncheckedCreateNestedManyWithoutTenantInput
    otaJobs?: OtaJobUncheckedCreateNestedManyWithoutTenantInput
    weatherData?: WeatherDataUncheckedCreateNestedManyWithoutTenantInput
  }

  export type TenantCreateOrConnectWithoutAuditLogsInput = {
    where: TenantWhereUniqueInput
    create: XOR<TenantCreateWithoutAuditLogsInput, TenantUncheckedCreateWithoutAuditLogsInput>
  }

  export type TenantUpsertWithoutAuditLogsInput = {
    update: XOR<TenantUpdateWithoutAuditLogsInput, TenantUncheckedUpdateWithoutAuditLogsInput>
    create: XOR<TenantCreateWithoutAuditLogsInput, TenantUncheckedCreateWithoutAuditLogsInput>
    where?: TenantWhereInput
  }

  export type TenantUpdateToOneWithWhereWithoutAuditLogsInput = {
    where?: TenantWhereInput
    data: XOR<TenantUpdateWithoutAuditLogsInput, TenantUncheckedUpdateWithoutAuditLogsInput>
  }

  export type TenantUpdateWithoutAuditLogsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumTenantTypeFieldUpdateOperationsInput | $Enums.TenantType
    status?: EnumTenantStatusFieldUpdateOperationsInput | $Enums.TenantStatus
    settings?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    memberships?: MembershipUpdateManyWithoutTenantNestedInput
    sites?: SiteUpdateManyWithoutTenantNestedInput
    devices?: DeviceUpdateManyWithoutTenantNestedInput
    alertRules?: AlertRuleUpdateManyWithoutTenantNestedInput
    alertEvents?: AlertEventUpdateManyWithoutTenantNestedInput
    notificationChannels?: NotificationChannelUpdateManyWithoutTenantNestedInput
    notificationEvents?: NotificationEventUpdateManyWithoutTenantNestedInput
    dailyRollups?: DailyRollupUpdateManyWithoutTenantNestedInput
    entitlements?: EntitlementUpdateManyWithoutTenantNestedInput
    otaJobs?: OtaJobUpdateManyWithoutTenantNestedInput
    weatherData?: WeatherDataUpdateManyWithoutTenantNestedInput
  }

  export type TenantUncheckedUpdateWithoutAuditLogsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumTenantTypeFieldUpdateOperationsInput | $Enums.TenantType
    status?: EnumTenantStatusFieldUpdateOperationsInput | $Enums.TenantStatus
    settings?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    memberships?: MembershipUncheckedUpdateManyWithoutTenantNestedInput
    sites?: SiteUncheckedUpdateManyWithoutTenantNestedInput
    devices?: DeviceUncheckedUpdateManyWithoutTenantNestedInput
    alertRules?: AlertRuleUncheckedUpdateManyWithoutTenantNestedInput
    alertEvents?: AlertEventUncheckedUpdateManyWithoutTenantNestedInput
    notificationChannels?: NotificationChannelUncheckedUpdateManyWithoutTenantNestedInput
    notificationEvents?: NotificationEventUncheckedUpdateManyWithoutTenantNestedInput
    dailyRollups?: DailyRollupUncheckedUpdateManyWithoutTenantNestedInput
    entitlements?: EntitlementUncheckedUpdateManyWithoutTenantNestedInput
    otaJobs?: OtaJobUncheckedUpdateManyWithoutTenantNestedInput
    weatherData?: WeatherDataUncheckedUpdateManyWithoutTenantNestedInput
  }

  export type TenantCreateWithoutWeatherDataInput = {
    id?: string
    name: string
    type: $Enums.TenantType
    status?: $Enums.TenantStatus
    settings?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    memberships?: MembershipCreateNestedManyWithoutTenantInput
    sites?: SiteCreateNestedManyWithoutTenantInput
    devices?: DeviceCreateNestedManyWithoutTenantInput
    alertRules?: AlertRuleCreateNestedManyWithoutTenantInput
    alertEvents?: AlertEventCreateNestedManyWithoutTenantInput
    notificationChannels?: NotificationChannelCreateNestedManyWithoutTenantInput
    notificationEvents?: NotificationEventCreateNestedManyWithoutTenantInput
    dailyRollups?: DailyRollupCreateNestedManyWithoutTenantInput
    entitlements?: EntitlementCreateNestedManyWithoutTenantInput
    auditLogs?: AuditLogCreateNestedManyWithoutTenantInput
    otaJobs?: OtaJobCreateNestedManyWithoutTenantInput
  }

  export type TenantUncheckedCreateWithoutWeatherDataInput = {
    id?: string
    name: string
    type: $Enums.TenantType
    status?: $Enums.TenantStatus
    settings?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    memberships?: MembershipUncheckedCreateNestedManyWithoutTenantInput
    sites?: SiteUncheckedCreateNestedManyWithoutTenantInput
    devices?: DeviceUncheckedCreateNestedManyWithoutTenantInput
    alertRules?: AlertRuleUncheckedCreateNestedManyWithoutTenantInput
    alertEvents?: AlertEventUncheckedCreateNestedManyWithoutTenantInput
    notificationChannels?: NotificationChannelUncheckedCreateNestedManyWithoutTenantInput
    notificationEvents?: NotificationEventUncheckedCreateNestedManyWithoutTenantInput
    dailyRollups?: DailyRollupUncheckedCreateNestedManyWithoutTenantInput
    entitlements?: EntitlementUncheckedCreateNestedManyWithoutTenantInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutTenantInput
    otaJobs?: OtaJobUncheckedCreateNestedManyWithoutTenantInput
  }

  export type TenantCreateOrConnectWithoutWeatherDataInput = {
    where: TenantWhereUniqueInput
    create: XOR<TenantCreateWithoutWeatherDataInput, TenantUncheckedCreateWithoutWeatherDataInput>
  }

  export type SiteCreateWithoutWeatherDataInput = {
    id?: string
    name: string
    addressLine1?: string | null
    addressLine2?: string | null
    city?: string | null
    region?: string | null
    postalCode?: string | null
    country?: string | null
    lat?: number | null
    lon?: number | null
    locationSource?: $Enums.LocationSource | null
    locationAccuracyM?: number | null
    locationConfidence?: number | null
    locationUpdatedAt?: Date | string | null
    locationLock?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    tenant: TenantCreateNestedOneWithoutSitesInput
    locationUpdatedBy?: UserCreateNestedOneWithoutSiteLocUpdatesInput
    devices?: DeviceCreateNestedManyWithoutSiteInput
  }

  export type SiteUncheckedCreateWithoutWeatherDataInput = {
    id?: string
    tenantId: string
    name: string
    addressLine1?: string | null
    addressLine2?: string | null
    city?: string | null
    region?: string | null
    postalCode?: string | null
    country?: string | null
    lat?: number | null
    lon?: number | null
    locationSource?: $Enums.LocationSource | null
    locationAccuracyM?: number | null
    locationConfidence?: number | null
    locationUpdatedAt?: Date | string | null
    locationUpdatedByUserId?: string | null
    locationLock?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    devices?: DeviceUncheckedCreateNestedManyWithoutSiteInput
  }

  export type SiteCreateOrConnectWithoutWeatherDataInput = {
    where: SiteWhereUniqueInput
    create: XOR<SiteCreateWithoutWeatherDataInput, SiteUncheckedCreateWithoutWeatherDataInput>
  }

  export type TenantUpsertWithoutWeatherDataInput = {
    update: XOR<TenantUpdateWithoutWeatherDataInput, TenantUncheckedUpdateWithoutWeatherDataInput>
    create: XOR<TenantCreateWithoutWeatherDataInput, TenantUncheckedCreateWithoutWeatherDataInput>
    where?: TenantWhereInput
  }

  export type TenantUpdateToOneWithWhereWithoutWeatherDataInput = {
    where?: TenantWhereInput
    data: XOR<TenantUpdateWithoutWeatherDataInput, TenantUncheckedUpdateWithoutWeatherDataInput>
  }

  export type TenantUpdateWithoutWeatherDataInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumTenantTypeFieldUpdateOperationsInput | $Enums.TenantType
    status?: EnumTenantStatusFieldUpdateOperationsInput | $Enums.TenantStatus
    settings?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    memberships?: MembershipUpdateManyWithoutTenantNestedInput
    sites?: SiteUpdateManyWithoutTenantNestedInput
    devices?: DeviceUpdateManyWithoutTenantNestedInput
    alertRules?: AlertRuleUpdateManyWithoutTenantNestedInput
    alertEvents?: AlertEventUpdateManyWithoutTenantNestedInput
    notificationChannels?: NotificationChannelUpdateManyWithoutTenantNestedInput
    notificationEvents?: NotificationEventUpdateManyWithoutTenantNestedInput
    dailyRollups?: DailyRollupUpdateManyWithoutTenantNestedInput
    entitlements?: EntitlementUpdateManyWithoutTenantNestedInput
    auditLogs?: AuditLogUpdateManyWithoutTenantNestedInput
    otaJobs?: OtaJobUpdateManyWithoutTenantNestedInput
  }

  export type TenantUncheckedUpdateWithoutWeatherDataInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumTenantTypeFieldUpdateOperationsInput | $Enums.TenantType
    status?: EnumTenantStatusFieldUpdateOperationsInput | $Enums.TenantStatus
    settings?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    memberships?: MembershipUncheckedUpdateManyWithoutTenantNestedInput
    sites?: SiteUncheckedUpdateManyWithoutTenantNestedInput
    devices?: DeviceUncheckedUpdateManyWithoutTenantNestedInput
    alertRules?: AlertRuleUncheckedUpdateManyWithoutTenantNestedInput
    alertEvents?: AlertEventUncheckedUpdateManyWithoutTenantNestedInput
    notificationChannels?: NotificationChannelUncheckedUpdateManyWithoutTenantNestedInput
    notificationEvents?: NotificationEventUncheckedUpdateManyWithoutTenantNestedInput
    dailyRollups?: DailyRollupUncheckedUpdateManyWithoutTenantNestedInput
    entitlements?: EntitlementUncheckedUpdateManyWithoutTenantNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutTenantNestedInput
    otaJobs?: OtaJobUncheckedUpdateManyWithoutTenantNestedInput
  }

  export type SiteUpsertWithoutWeatherDataInput = {
    update: XOR<SiteUpdateWithoutWeatherDataInput, SiteUncheckedUpdateWithoutWeatherDataInput>
    create: XOR<SiteCreateWithoutWeatherDataInput, SiteUncheckedCreateWithoutWeatherDataInput>
    where?: SiteWhereInput
  }

  export type SiteUpdateToOneWithWhereWithoutWeatherDataInput = {
    where?: SiteWhereInput
    data: XOR<SiteUpdateWithoutWeatherDataInput, SiteUncheckedUpdateWithoutWeatherDataInput>
  }

  export type SiteUpdateWithoutWeatherDataInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    addressLine1?: NullableStringFieldUpdateOperationsInput | string | null
    addressLine2?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    region?: NullableStringFieldUpdateOperationsInput | string | null
    postalCode?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    lat?: NullableFloatFieldUpdateOperationsInput | number | null
    lon?: NullableFloatFieldUpdateOperationsInput | number | null
    locationSource?: NullableEnumLocationSourceFieldUpdateOperationsInput | $Enums.LocationSource | null
    locationAccuracyM?: NullableFloatFieldUpdateOperationsInput | number | null
    locationConfidence?: NullableFloatFieldUpdateOperationsInput | number | null
    locationUpdatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    locationLock?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tenant?: TenantUpdateOneRequiredWithoutSitesNestedInput
    locationUpdatedBy?: UserUpdateOneWithoutSiteLocUpdatesNestedInput
    devices?: DeviceUpdateManyWithoutSiteNestedInput
  }

  export type SiteUncheckedUpdateWithoutWeatherDataInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    addressLine1?: NullableStringFieldUpdateOperationsInput | string | null
    addressLine2?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    region?: NullableStringFieldUpdateOperationsInput | string | null
    postalCode?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    lat?: NullableFloatFieldUpdateOperationsInput | number | null
    lon?: NullableFloatFieldUpdateOperationsInput | number | null
    locationSource?: NullableEnumLocationSourceFieldUpdateOperationsInput | $Enums.LocationSource | null
    locationAccuracyM?: NullableFloatFieldUpdateOperationsInput | number | null
    locationConfidence?: NullableFloatFieldUpdateOperationsInput | number | null
    locationUpdatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    locationUpdatedByUserId?: NullableStringFieldUpdateOperationsInput | string | null
    locationLock?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    devices?: DeviceUncheckedUpdateManyWithoutSiteNestedInput
  }

  export type MembershipCreateManyTenantInput = {
    id?: string
    userId: string
    role: $Enums.MembershipRole
    createdAt?: Date | string
  }

  export type SiteCreateManyTenantInput = {
    id?: string
    name: string
    addressLine1?: string | null
    addressLine2?: string | null
    city?: string | null
    region?: string | null
    postalCode?: string | null
    country?: string | null
    lat?: number | null
    lon?: number | null
    locationSource?: $Enums.LocationSource | null
    locationAccuracyM?: number | null
    locationConfidence?: number | null
    locationUpdatedAt?: Date | string | null
    locationUpdatedByUserId?: string | null
    locationLock?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type DeviceCreateManyTenantInput = {
    id?: string
    siteId?: string | null
    ownerUserId?: string | null
    model: string
    serialNumber: string
    name?: string | null
    notes?: string | null
    tags?: NullableJsonNullValueInput | InputJsonValue
    status?: $Enums.DeviceStatus
    lastSeenAt?: Date | string | null
    firmwareVersion?: string | null
    simIccid?: string | null
    deviceLat?: number | null
    deviceLon?: number | null
    deviceLocationTs?: Date | string | null
    deviceLocationSource?: $Enums.DeviceLocationSource | null
    deviceLocationAccuracyM?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AlertRuleCreateManyTenantInput = {
    id?: string
    name: string
    enabled?: boolean
    type: $Enums.AlertRuleType
    params: JsonNullValueInput | InputJsonValue
    severity?: $Enums.AlertSeverity
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AlertEventCreateManyTenantInput = {
    id?: string
    deviceId: string
    ruleId: string
    severity: $Enums.AlertSeverity
    status?: $Enums.AlertEventStatus
    openedAt?: Date | string
    acknowledgedAt?: Date | string | null
    closedAt?: Date | string | null
    details?: NullableJsonNullValueInput | InputJsonValue
    dedupeKey?: string | null
  }

  export type NotificationChannelCreateManyTenantInput = {
    id?: string
    type: $Enums.NotificationChannelType
    config: JsonNullValueInput | InputJsonValue
    enabled?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type NotificationEventCreateManyTenantInput = {
    id?: string
    channelId: string
    alertEventId?: string | null
    status?: $Enums.NotificationEventStatus
    payload: JsonNullValueInput | InputJsonValue
    sentAt?: Date | string | null
    errorMsg?: string | null
    createdAt?: Date | string
  }

  export type DailyRollupCreateManyTenantInput = {
    id?: string
    deviceId: string
    dayDate: Date | string
    energyKwhDay?: number | null
    hotWaterUsageLitersDay?: number | null
    heaterOnMinutesDay?: number | null
    tankTempMinC?: number | null
    tankTempMaxC?: number | null
    ambientTempAvgC?: number | null
    createdAt?: Date | string
  }

  export type EntitlementCreateManyTenantInput = {
    id?: string
    scope: $Enums.EntitlementScope
    deviceId?: string | null
    key: $Enums.EntitlementKey
    enabled?: boolean
    updatedAt?: Date | string
  }

  export type AuditLogCreateManyTenantInput = {
    id?: string
    actorUserId?: string | null
    actorType?: $Enums.ActorType
    action: string
    entityType: string
    entityId: string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type OtaJobCreateManyTenantInput = {
    id?: string
    targetType: $Enums.OtaTargetType
    deviceId?: string | null
    groupFilter?: NullableJsonNullValueInput | InputJsonValue
    firmwarePackageId: string
    status?: $Enums.OtaJobStatus
    scheduledAt: Date | string
    startedAt?: Date | string | null
    finishedAt?: Date | string | null
    createdByUserId?: string | null
    progress?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type WeatherDataCreateManyTenantInput = {
    id?: string
    siteId: string
    date: Date | string
    summary: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type MembershipUpdateWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    role?: EnumMembershipRoleFieldUpdateOperationsInput | $Enums.MembershipRole
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutMembershipsNestedInput
  }

  export type MembershipUncheckedUpdateWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    role?: EnumMembershipRoleFieldUpdateOperationsInput | $Enums.MembershipRole
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MembershipUncheckedUpdateManyWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    role?: EnumMembershipRoleFieldUpdateOperationsInput | $Enums.MembershipRole
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SiteUpdateWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    addressLine1?: NullableStringFieldUpdateOperationsInput | string | null
    addressLine2?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    region?: NullableStringFieldUpdateOperationsInput | string | null
    postalCode?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    lat?: NullableFloatFieldUpdateOperationsInput | number | null
    lon?: NullableFloatFieldUpdateOperationsInput | number | null
    locationSource?: NullableEnumLocationSourceFieldUpdateOperationsInput | $Enums.LocationSource | null
    locationAccuracyM?: NullableFloatFieldUpdateOperationsInput | number | null
    locationConfidence?: NullableFloatFieldUpdateOperationsInput | number | null
    locationUpdatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    locationLock?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    locationUpdatedBy?: UserUpdateOneWithoutSiteLocUpdatesNestedInput
    devices?: DeviceUpdateManyWithoutSiteNestedInput
    weatherData?: WeatherDataUpdateManyWithoutSiteNestedInput
  }

  export type SiteUncheckedUpdateWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    addressLine1?: NullableStringFieldUpdateOperationsInput | string | null
    addressLine2?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    region?: NullableStringFieldUpdateOperationsInput | string | null
    postalCode?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    lat?: NullableFloatFieldUpdateOperationsInput | number | null
    lon?: NullableFloatFieldUpdateOperationsInput | number | null
    locationSource?: NullableEnumLocationSourceFieldUpdateOperationsInput | $Enums.LocationSource | null
    locationAccuracyM?: NullableFloatFieldUpdateOperationsInput | number | null
    locationConfidence?: NullableFloatFieldUpdateOperationsInput | number | null
    locationUpdatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    locationUpdatedByUserId?: NullableStringFieldUpdateOperationsInput | string | null
    locationLock?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    devices?: DeviceUncheckedUpdateManyWithoutSiteNestedInput
    weatherData?: WeatherDataUncheckedUpdateManyWithoutSiteNestedInput
  }

  export type SiteUncheckedUpdateManyWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    addressLine1?: NullableStringFieldUpdateOperationsInput | string | null
    addressLine2?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    region?: NullableStringFieldUpdateOperationsInput | string | null
    postalCode?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    lat?: NullableFloatFieldUpdateOperationsInput | number | null
    lon?: NullableFloatFieldUpdateOperationsInput | number | null
    locationSource?: NullableEnumLocationSourceFieldUpdateOperationsInput | $Enums.LocationSource | null
    locationAccuracyM?: NullableFloatFieldUpdateOperationsInput | number | null
    locationConfidence?: NullableFloatFieldUpdateOperationsInput | number | null
    locationUpdatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    locationUpdatedByUserId?: NullableStringFieldUpdateOperationsInput | string | null
    locationLock?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DeviceUpdateWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    ownerUserId?: NullableStringFieldUpdateOperationsInput | string | null
    model?: StringFieldUpdateOperationsInput | string
    serialNumber?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: NullableJsonNullValueInput | InputJsonValue
    status?: EnumDeviceStatusFieldUpdateOperationsInput | $Enums.DeviceStatus
    lastSeenAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    firmwareVersion?: NullableStringFieldUpdateOperationsInput | string | null
    deviceLat?: NullableFloatFieldUpdateOperationsInput | number | null
    deviceLon?: NullableFloatFieldUpdateOperationsInput | number | null
    deviceLocationTs?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deviceLocationSource?: NullableEnumDeviceLocationSourceFieldUpdateOperationsInput | $Enums.DeviceLocationSource | null
    deviceLocationAccuracyM?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    site?: SiteUpdateOneWithoutDevicesNestedInput
    sim?: SimInfoUpdateOneWithoutDevicesNestedInput
    secret?: DeviceSecretUpdateOneWithoutDeviceNestedInput
    twin?: DeviceTwinUpdateOneWithoutDeviceNestedInput
    telemetry?: TelemetryUpdateManyWithoutDeviceNestedInput
    commands?: CommandUpdateManyWithoutDeviceNestedInput
    alertEvents?: AlertEventUpdateManyWithoutDeviceNestedInput
    dailyRollups?: DailyRollupUpdateManyWithoutDeviceNestedInput
    entitlements?: EntitlementUpdateManyWithoutDeviceNestedInput
  }

  export type DeviceUncheckedUpdateWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    siteId?: NullableStringFieldUpdateOperationsInput | string | null
    ownerUserId?: NullableStringFieldUpdateOperationsInput | string | null
    model?: StringFieldUpdateOperationsInput | string
    serialNumber?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: NullableJsonNullValueInput | InputJsonValue
    status?: EnumDeviceStatusFieldUpdateOperationsInput | $Enums.DeviceStatus
    lastSeenAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    firmwareVersion?: NullableStringFieldUpdateOperationsInput | string | null
    simIccid?: NullableStringFieldUpdateOperationsInput | string | null
    deviceLat?: NullableFloatFieldUpdateOperationsInput | number | null
    deviceLon?: NullableFloatFieldUpdateOperationsInput | number | null
    deviceLocationTs?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deviceLocationSource?: NullableEnumDeviceLocationSourceFieldUpdateOperationsInput | $Enums.DeviceLocationSource | null
    deviceLocationAccuracyM?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    secret?: DeviceSecretUncheckedUpdateOneWithoutDeviceNestedInput
    twin?: DeviceTwinUncheckedUpdateOneWithoutDeviceNestedInput
    telemetry?: TelemetryUncheckedUpdateManyWithoutDeviceNestedInput
    commands?: CommandUncheckedUpdateManyWithoutDeviceNestedInput
    alertEvents?: AlertEventUncheckedUpdateManyWithoutDeviceNestedInput
    dailyRollups?: DailyRollupUncheckedUpdateManyWithoutDeviceNestedInput
    entitlements?: EntitlementUncheckedUpdateManyWithoutDeviceNestedInput
  }

  export type DeviceUncheckedUpdateManyWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    siteId?: NullableStringFieldUpdateOperationsInput | string | null
    ownerUserId?: NullableStringFieldUpdateOperationsInput | string | null
    model?: StringFieldUpdateOperationsInput | string
    serialNumber?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: NullableJsonNullValueInput | InputJsonValue
    status?: EnumDeviceStatusFieldUpdateOperationsInput | $Enums.DeviceStatus
    lastSeenAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    firmwareVersion?: NullableStringFieldUpdateOperationsInput | string | null
    simIccid?: NullableStringFieldUpdateOperationsInput | string | null
    deviceLat?: NullableFloatFieldUpdateOperationsInput | number | null
    deviceLon?: NullableFloatFieldUpdateOperationsInput | number | null
    deviceLocationTs?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deviceLocationSource?: NullableEnumDeviceLocationSourceFieldUpdateOperationsInput | $Enums.DeviceLocationSource | null
    deviceLocationAccuracyM?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AlertRuleUpdateWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    enabled?: BoolFieldUpdateOperationsInput | boolean
    type?: EnumAlertRuleTypeFieldUpdateOperationsInput | $Enums.AlertRuleType
    params?: JsonNullValueInput | InputJsonValue
    severity?: EnumAlertSeverityFieldUpdateOperationsInput | $Enums.AlertSeverity
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    alertEvents?: AlertEventUpdateManyWithoutRuleNestedInput
  }

  export type AlertRuleUncheckedUpdateWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    enabled?: BoolFieldUpdateOperationsInput | boolean
    type?: EnumAlertRuleTypeFieldUpdateOperationsInput | $Enums.AlertRuleType
    params?: JsonNullValueInput | InputJsonValue
    severity?: EnumAlertSeverityFieldUpdateOperationsInput | $Enums.AlertSeverity
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    alertEvents?: AlertEventUncheckedUpdateManyWithoutRuleNestedInput
  }

  export type AlertRuleUncheckedUpdateManyWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    enabled?: BoolFieldUpdateOperationsInput | boolean
    type?: EnumAlertRuleTypeFieldUpdateOperationsInput | $Enums.AlertRuleType
    params?: JsonNullValueInput | InputJsonValue
    severity?: EnumAlertSeverityFieldUpdateOperationsInput | $Enums.AlertSeverity
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AlertEventUpdateWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    severity?: EnumAlertSeverityFieldUpdateOperationsInput | $Enums.AlertSeverity
    status?: EnumAlertEventStatusFieldUpdateOperationsInput | $Enums.AlertEventStatus
    openedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    acknowledgedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    closedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    details?: NullableJsonNullValueInput | InputJsonValue
    dedupeKey?: NullableStringFieldUpdateOperationsInput | string | null
    device?: DeviceUpdateOneRequiredWithoutAlertEventsNestedInput
    rule?: AlertRuleUpdateOneRequiredWithoutAlertEventsNestedInput
    notificationEvents?: NotificationEventUpdateManyWithoutAlertEventNestedInput
  }

  export type AlertEventUncheckedUpdateWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    deviceId?: StringFieldUpdateOperationsInput | string
    ruleId?: StringFieldUpdateOperationsInput | string
    severity?: EnumAlertSeverityFieldUpdateOperationsInput | $Enums.AlertSeverity
    status?: EnumAlertEventStatusFieldUpdateOperationsInput | $Enums.AlertEventStatus
    openedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    acknowledgedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    closedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    details?: NullableJsonNullValueInput | InputJsonValue
    dedupeKey?: NullableStringFieldUpdateOperationsInput | string | null
    notificationEvents?: NotificationEventUncheckedUpdateManyWithoutAlertEventNestedInput
  }

  export type AlertEventUncheckedUpdateManyWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    deviceId?: StringFieldUpdateOperationsInput | string
    ruleId?: StringFieldUpdateOperationsInput | string
    severity?: EnumAlertSeverityFieldUpdateOperationsInput | $Enums.AlertSeverity
    status?: EnumAlertEventStatusFieldUpdateOperationsInput | $Enums.AlertEventStatus
    openedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    acknowledgedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    closedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    details?: NullableJsonNullValueInput | InputJsonValue
    dedupeKey?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type NotificationChannelUpdateWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumNotificationChannelTypeFieldUpdateOperationsInput | $Enums.NotificationChannelType
    config?: JsonNullValueInput | InputJsonValue
    enabled?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    notificationEvents?: NotificationEventUpdateManyWithoutChannelNestedInput
  }

  export type NotificationChannelUncheckedUpdateWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumNotificationChannelTypeFieldUpdateOperationsInput | $Enums.NotificationChannelType
    config?: JsonNullValueInput | InputJsonValue
    enabled?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    notificationEvents?: NotificationEventUncheckedUpdateManyWithoutChannelNestedInput
  }

  export type NotificationChannelUncheckedUpdateManyWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumNotificationChannelTypeFieldUpdateOperationsInput | $Enums.NotificationChannelType
    config?: JsonNullValueInput | InputJsonValue
    enabled?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationEventUpdateWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: EnumNotificationEventStatusFieldUpdateOperationsInput | $Enums.NotificationEventStatus
    payload?: JsonNullValueInput | InputJsonValue
    sentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    errorMsg?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    channel?: NotificationChannelUpdateOneRequiredWithoutNotificationEventsNestedInput
    alertEvent?: AlertEventUpdateOneWithoutNotificationEventsNestedInput
  }

  export type NotificationEventUncheckedUpdateWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    channelId?: StringFieldUpdateOperationsInput | string
    alertEventId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumNotificationEventStatusFieldUpdateOperationsInput | $Enums.NotificationEventStatus
    payload?: JsonNullValueInput | InputJsonValue
    sentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    errorMsg?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationEventUncheckedUpdateManyWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    channelId?: StringFieldUpdateOperationsInput | string
    alertEventId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumNotificationEventStatusFieldUpdateOperationsInput | $Enums.NotificationEventStatus
    payload?: JsonNullValueInput | InputJsonValue
    sentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    errorMsg?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DailyRollupUpdateWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    dayDate?: DateTimeFieldUpdateOperationsInput | Date | string
    energyKwhDay?: NullableFloatFieldUpdateOperationsInput | number | null
    hotWaterUsageLitersDay?: NullableFloatFieldUpdateOperationsInput | number | null
    heaterOnMinutesDay?: NullableFloatFieldUpdateOperationsInput | number | null
    tankTempMinC?: NullableFloatFieldUpdateOperationsInput | number | null
    tankTempMaxC?: NullableFloatFieldUpdateOperationsInput | number | null
    ambientTempAvgC?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    device?: DeviceUpdateOneRequiredWithoutDailyRollupsNestedInput
  }

  export type DailyRollupUncheckedUpdateWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    deviceId?: StringFieldUpdateOperationsInput | string
    dayDate?: DateTimeFieldUpdateOperationsInput | Date | string
    energyKwhDay?: NullableFloatFieldUpdateOperationsInput | number | null
    hotWaterUsageLitersDay?: NullableFloatFieldUpdateOperationsInput | number | null
    heaterOnMinutesDay?: NullableFloatFieldUpdateOperationsInput | number | null
    tankTempMinC?: NullableFloatFieldUpdateOperationsInput | number | null
    tankTempMaxC?: NullableFloatFieldUpdateOperationsInput | number | null
    ambientTempAvgC?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DailyRollupUncheckedUpdateManyWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    deviceId?: StringFieldUpdateOperationsInput | string
    dayDate?: DateTimeFieldUpdateOperationsInput | Date | string
    energyKwhDay?: NullableFloatFieldUpdateOperationsInput | number | null
    hotWaterUsageLitersDay?: NullableFloatFieldUpdateOperationsInput | number | null
    heaterOnMinutesDay?: NullableFloatFieldUpdateOperationsInput | number | null
    tankTempMinC?: NullableFloatFieldUpdateOperationsInput | number | null
    tankTempMaxC?: NullableFloatFieldUpdateOperationsInput | number | null
    ambientTempAvgC?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EntitlementUpdateWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    scope?: EnumEntitlementScopeFieldUpdateOperationsInput | $Enums.EntitlementScope
    key?: EnumEntitlementKeyFieldUpdateOperationsInput | $Enums.EntitlementKey
    enabled?: BoolFieldUpdateOperationsInput | boolean
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    device?: DeviceUpdateOneWithoutEntitlementsNestedInput
  }

  export type EntitlementUncheckedUpdateWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    scope?: EnumEntitlementScopeFieldUpdateOperationsInput | $Enums.EntitlementScope
    deviceId?: NullableStringFieldUpdateOperationsInput | string | null
    key?: EnumEntitlementKeyFieldUpdateOperationsInput | $Enums.EntitlementKey
    enabled?: BoolFieldUpdateOperationsInput | boolean
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EntitlementUncheckedUpdateManyWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    scope?: EnumEntitlementScopeFieldUpdateOperationsInput | $Enums.EntitlementScope
    deviceId?: NullableStringFieldUpdateOperationsInput | string | null
    key?: EnumEntitlementKeyFieldUpdateOperationsInput | $Enums.EntitlementKey
    enabled?: BoolFieldUpdateOperationsInput | boolean
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AuditLogUpdateWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    actorUserId?: NullableStringFieldUpdateOperationsInput | string | null
    actorType?: EnumActorTypeFieldUpdateOperationsInput | $Enums.ActorType
    action?: StringFieldUpdateOperationsInput | string
    entityType?: StringFieldUpdateOperationsInput | string
    entityId?: StringFieldUpdateOperationsInput | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AuditLogUncheckedUpdateWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    actorUserId?: NullableStringFieldUpdateOperationsInput | string | null
    actorType?: EnumActorTypeFieldUpdateOperationsInput | $Enums.ActorType
    action?: StringFieldUpdateOperationsInput | string
    entityType?: StringFieldUpdateOperationsInput | string
    entityId?: StringFieldUpdateOperationsInput | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AuditLogUncheckedUpdateManyWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    actorUserId?: NullableStringFieldUpdateOperationsInput | string | null
    actorType?: EnumActorTypeFieldUpdateOperationsInput | $Enums.ActorType
    action?: StringFieldUpdateOperationsInput | string
    entityType?: StringFieldUpdateOperationsInput | string
    entityId?: StringFieldUpdateOperationsInput | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OtaJobUpdateWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    targetType?: EnumOtaTargetTypeFieldUpdateOperationsInput | $Enums.OtaTargetType
    deviceId?: NullableStringFieldUpdateOperationsInput | string | null
    groupFilter?: NullableJsonNullValueInput | InputJsonValue
    status?: EnumOtaJobStatusFieldUpdateOperationsInput | $Enums.OtaJobStatus
    scheduledAt?: DateTimeFieldUpdateOperationsInput | Date | string
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    finishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    progress?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    firmwarePackage?: FirmwarePackageUpdateOneRequiredWithoutOtaJobsNestedInput
    createdBy?: UserUpdateOneWithoutOtaJobsNestedInput
  }

  export type OtaJobUncheckedUpdateWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    targetType?: EnumOtaTargetTypeFieldUpdateOperationsInput | $Enums.OtaTargetType
    deviceId?: NullableStringFieldUpdateOperationsInput | string | null
    groupFilter?: NullableJsonNullValueInput | InputJsonValue
    firmwarePackageId?: StringFieldUpdateOperationsInput | string
    status?: EnumOtaJobStatusFieldUpdateOperationsInput | $Enums.OtaJobStatus
    scheduledAt?: DateTimeFieldUpdateOperationsInput | Date | string
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    finishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdByUserId?: NullableStringFieldUpdateOperationsInput | string | null
    progress?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OtaJobUncheckedUpdateManyWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    targetType?: EnumOtaTargetTypeFieldUpdateOperationsInput | $Enums.OtaTargetType
    deviceId?: NullableStringFieldUpdateOperationsInput | string | null
    groupFilter?: NullableJsonNullValueInput | InputJsonValue
    firmwarePackageId?: StringFieldUpdateOperationsInput | string
    status?: EnumOtaJobStatusFieldUpdateOperationsInput | $Enums.OtaJobStatus
    scheduledAt?: DateTimeFieldUpdateOperationsInput | Date | string
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    finishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdByUserId?: NullableStringFieldUpdateOperationsInput | string | null
    progress?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WeatherDataUpdateWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    summary?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    site?: SiteUpdateOneRequiredWithoutWeatherDataNestedInput
  }

  export type WeatherDataUncheckedUpdateWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    siteId?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    summary?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WeatherDataUncheckedUpdateManyWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    siteId?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    summary?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MembershipCreateManyUserInput = {
    id?: string
    tenantId: string
    role: $Enums.MembershipRole
    createdAt?: Date | string
  }

  export type CommandCreateManyRequestedByInput = {
    id?: string
    deviceId: string
    type: $Enums.CommandType
    payload: JsonNullValueInput | InputJsonValue
    status?: $Enums.CommandStatus
    requestedAt?: Date | string
    deliveredAt?: Date | string | null
    ackAt?: Date | string | null
    errorMsg?: string | null
  }

  export type OtaJobCreateManyCreatedByInput = {
    id?: string
    tenantId: string
    targetType: $Enums.OtaTargetType
    deviceId?: string | null
    groupFilter?: NullableJsonNullValueInput | InputJsonValue
    firmwarePackageId: string
    status?: $Enums.OtaJobStatus
    scheduledAt: Date | string
    startedAt?: Date | string | null
    finishedAt?: Date | string | null
    progress?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type SimActionCreateManyRequestedByInput = {
    id?: string
    iccid: string
    action: $Enums.SimActionType
    requestedAt?: Date | string
    status?: $Enums.SimActionStatus
    providerRef?: string | null
    errorMsg?: string | null
  }

  export type SiteCreateManyLocationUpdatedByInput = {
    id?: string
    tenantId: string
    name: string
    addressLine1?: string | null
    addressLine2?: string | null
    city?: string | null
    region?: string | null
    postalCode?: string | null
    country?: string | null
    lat?: number | null
    lon?: number | null
    locationSource?: $Enums.LocationSource | null
    locationAccuracyM?: number | null
    locationConfidence?: number | null
    locationUpdatedAt?: Date | string | null
    locationLock?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type MembershipUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    role?: EnumMembershipRoleFieldUpdateOperationsInput | $Enums.MembershipRole
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tenant?: TenantUpdateOneRequiredWithoutMembershipsNestedInput
  }

  export type MembershipUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    role?: EnumMembershipRoleFieldUpdateOperationsInput | $Enums.MembershipRole
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MembershipUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    role?: EnumMembershipRoleFieldUpdateOperationsInput | $Enums.MembershipRole
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CommandUpdateWithoutRequestedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumCommandTypeFieldUpdateOperationsInput | $Enums.CommandType
    payload?: JsonNullValueInput | InputJsonValue
    status?: EnumCommandStatusFieldUpdateOperationsInput | $Enums.CommandStatus
    requestedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deliveredAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ackAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    errorMsg?: NullableStringFieldUpdateOperationsInput | string | null
    device?: DeviceUpdateOneRequiredWithoutCommandsNestedInput
  }

  export type CommandUncheckedUpdateWithoutRequestedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    deviceId?: StringFieldUpdateOperationsInput | string
    type?: EnumCommandTypeFieldUpdateOperationsInput | $Enums.CommandType
    payload?: JsonNullValueInput | InputJsonValue
    status?: EnumCommandStatusFieldUpdateOperationsInput | $Enums.CommandStatus
    requestedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deliveredAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ackAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    errorMsg?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type CommandUncheckedUpdateManyWithoutRequestedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    deviceId?: StringFieldUpdateOperationsInput | string
    type?: EnumCommandTypeFieldUpdateOperationsInput | $Enums.CommandType
    payload?: JsonNullValueInput | InputJsonValue
    status?: EnumCommandStatusFieldUpdateOperationsInput | $Enums.CommandStatus
    requestedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deliveredAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ackAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    errorMsg?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type OtaJobUpdateWithoutCreatedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    targetType?: EnumOtaTargetTypeFieldUpdateOperationsInput | $Enums.OtaTargetType
    deviceId?: NullableStringFieldUpdateOperationsInput | string | null
    groupFilter?: NullableJsonNullValueInput | InputJsonValue
    status?: EnumOtaJobStatusFieldUpdateOperationsInput | $Enums.OtaJobStatus
    scheduledAt?: DateTimeFieldUpdateOperationsInput | Date | string
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    finishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    progress?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tenant?: TenantUpdateOneRequiredWithoutOtaJobsNestedInput
    firmwarePackage?: FirmwarePackageUpdateOneRequiredWithoutOtaJobsNestedInput
  }

  export type OtaJobUncheckedUpdateWithoutCreatedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    targetType?: EnumOtaTargetTypeFieldUpdateOperationsInput | $Enums.OtaTargetType
    deviceId?: NullableStringFieldUpdateOperationsInput | string | null
    groupFilter?: NullableJsonNullValueInput | InputJsonValue
    firmwarePackageId?: StringFieldUpdateOperationsInput | string
    status?: EnumOtaJobStatusFieldUpdateOperationsInput | $Enums.OtaJobStatus
    scheduledAt?: DateTimeFieldUpdateOperationsInput | Date | string
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    finishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    progress?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OtaJobUncheckedUpdateManyWithoutCreatedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    targetType?: EnumOtaTargetTypeFieldUpdateOperationsInput | $Enums.OtaTargetType
    deviceId?: NullableStringFieldUpdateOperationsInput | string | null
    groupFilter?: NullableJsonNullValueInput | InputJsonValue
    firmwarePackageId?: StringFieldUpdateOperationsInput | string
    status?: EnumOtaJobStatusFieldUpdateOperationsInput | $Enums.OtaJobStatus
    scheduledAt?: DateTimeFieldUpdateOperationsInput | Date | string
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    finishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    progress?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SimActionUpdateWithoutRequestedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    action?: EnumSimActionTypeFieldUpdateOperationsInput | $Enums.SimActionType
    requestedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumSimActionStatusFieldUpdateOperationsInput | $Enums.SimActionStatus
    providerRef?: NullableStringFieldUpdateOperationsInput | string | null
    errorMsg?: NullableStringFieldUpdateOperationsInput | string | null
    sim?: SimInfoUpdateOneRequiredWithoutSimActionsNestedInput
  }

  export type SimActionUncheckedUpdateWithoutRequestedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    iccid?: StringFieldUpdateOperationsInput | string
    action?: EnumSimActionTypeFieldUpdateOperationsInput | $Enums.SimActionType
    requestedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumSimActionStatusFieldUpdateOperationsInput | $Enums.SimActionStatus
    providerRef?: NullableStringFieldUpdateOperationsInput | string | null
    errorMsg?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type SimActionUncheckedUpdateManyWithoutRequestedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    iccid?: StringFieldUpdateOperationsInput | string
    action?: EnumSimActionTypeFieldUpdateOperationsInput | $Enums.SimActionType
    requestedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumSimActionStatusFieldUpdateOperationsInput | $Enums.SimActionStatus
    providerRef?: NullableStringFieldUpdateOperationsInput | string | null
    errorMsg?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type SiteUpdateWithoutLocationUpdatedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    addressLine1?: NullableStringFieldUpdateOperationsInput | string | null
    addressLine2?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    region?: NullableStringFieldUpdateOperationsInput | string | null
    postalCode?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    lat?: NullableFloatFieldUpdateOperationsInput | number | null
    lon?: NullableFloatFieldUpdateOperationsInput | number | null
    locationSource?: NullableEnumLocationSourceFieldUpdateOperationsInput | $Enums.LocationSource | null
    locationAccuracyM?: NullableFloatFieldUpdateOperationsInput | number | null
    locationConfidence?: NullableFloatFieldUpdateOperationsInput | number | null
    locationUpdatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    locationLock?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tenant?: TenantUpdateOneRequiredWithoutSitesNestedInput
    devices?: DeviceUpdateManyWithoutSiteNestedInput
    weatherData?: WeatherDataUpdateManyWithoutSiteNestedInput
  }

  export type SiteUncheckedUpdateWithoutLocationUpdatedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    addressLine1?: NullableStringFieldUpdateOperationsInput | string | null
    addressLine2?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    region?: NullableStringFieldUpdateOperationsInput | string | null
    postalCode?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    lat?: NullableFloatFieldUpdateOperationsInput | number | null
    lon?: NullableFloatFieldUpdateOperationsInput | number | null
    locationSource?: NullableEnumLocationSourceFieldUpdateOperationsInput | $Enums.LocationSource | null
    locationAccuracyM?: NullableFloatFieldUpdateOperationsInput | number | null
    locationConfidence?: NullableFloatFieldUpdateOperationsInput | number | null
    locationUpdatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    locationLock?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    devices?: DeviceUncheckedUpdateManyWithoutSiteNestedInput
    weatherData?: WeatherDataUncheckedUpdateManyWithoutSiteNestedInput
  }

  export type SiteUncheckedUpdateManyWithoutLocationUpdatedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    addressLine1?: NullableStringFieldUpdateOperationsInput | string | null
    addressLine2?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    region?: NullableStringFieldUpdateOperationsInput | string | null
    postalCode?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    lat?: NullableFloatFieldUpdateOperationsInput | number | null
    lon?: NullableFloatFieldUpdateOperationsInput | number | null
    locationSource?: NullableEnumLocationSourceFieldUpdateOperationsInput | $Enums.LocationSource | null
    locationAccuracyM?: NullableFloatFieldUpdateOperationsInput | number | null
    locationConfidence?: NullableFloatFieldUpdateOperationsInput | number | null
    locationUpdatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    locationLock?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DeviceCreateManySiteInput = {
    id?: string
    tenantId: string
    ownerUserId?: string | null
    model: string
    serialNumber: string
    name?: string | null
    notes?: string | null
    tags?: NullableJsonNullValueInput | InputJsonValue
    status?: $Enums.DeviceStatus
    lastSeenAt?: Date | string | null
    firmwareVersion?: string | null
    simIccid?: string | null
    deviceLat?: number | null
    deviceLon?: number | null
    deviceLocationTs?: Date | string | null
    deviceLocationSource?: $Enums.DeviceLocationSource | null
    deviceLocationAccuracyM?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type WeatherDataCreateManySiteInput = {
    id?: string
    tenantId: string
    date: Date | string
    summary: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type DeviceUpdateWithoutSiteInput = {
    id?: StringFieldUpdateOperationsInput | string
    ownerUserId?: NullableStringFieldUpdateOperationsInput | string | null
    model?: StringFieldUpdateOperationsInput | string
    serialNumber?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: NullableJsonNullValueInput | InputJsonValue
    status?: EnumDeviceStatusFieldUpdateOperationsInput | $Enums.DeviceStatus
    lastSeenAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    firmwareVersion?: NullableStringFieldUpdateOperationsInput | string | null
    deviceLat?: NullableFloatFieldUpdateOperationsInput | number | null
    deviceLon?: NullableFloatFieldUpdateOperationsInput | number | null
    deviceLocationTs?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deviceLocationSource?: NullableEnumDeviceLocationSourceFieldUpdateOperationsInput | $Enums.DeviceLocationSource | null
    deviceLocationAccuracyM?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tenant?: TenantUpdateOneRequiredWithoutDevicesNestedInput
    sim?: SimInfoUpdateOneWithoutDevicesNestedInput
    secret?: DeviceSecretUpdateOneWithoutDeviceNestedInput
    twin?: DeviceTwinUpdateOneWithoutDeviceNestedInput
    telemetry?: TelemetryUpdateManyWithoutDeviceNestedInput
    commands?: CommandUpdateManyWithoutDeviceNestedInput
    alertEvents?: AlertEventUpdateManyWithoutDeviceNestedInput
    dailyRollups?: DailyRollupUpdateManyWithoutDeviceNestedInput
    entitlements?: EntitlementUpdateManyWithoutDeviceNestedInput
  }

  export type DeviceUncheckedUpdateWithoutSiteInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    ownerUserId?: NullableStringFieldUpdateOperationsInput | string | null
    model?: StringFieldUpdateOperationsInput | string
    serialNumber?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: NullableJsonNullValueInput | InputJsonValue
    status?: EnumDeviceStatusFieldUpdateOperationsInput | $Enums.DeviceStatus
    lastSeenAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    firmwareVersion?: NullableStringFieldUpdateOperationsInput | string | null
    simIccid?: NullableStringFieldUpdateOperationsInput | string | null
    deviceLat?: NullableFloatFieldUpdateOperationsInput | number | null
    deviceLon?: NullableFloatFieldUpdateOperationsInput | number | null
    deviceLocationTs?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deviceLocationSource?: NullableEnumDeviceLocationSourceFieldUpdateOperationsInput | $Enums.DeviceLocationSource | null
    deviceLocationAccuracyM?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    secret?: DeviceSecretUncheckedUpdateOneWithoutDeviceNestedInput
    twin?: DeviceTwinUncheckedUpdateOneWithoutDeviceNestedInput
    telemetry?: TelemetryUncheckedUpdateManyWithoutDeviceNestedInput
    commands?: CommandUncheckedUpdateManyWithoutDeviceNestedInput
    alertEvents?: AlertEventUncheckedUpdateManyWithoutDeviceNestedInput
    dailyRollups?: DailyRollupUncheckedUpdateManyWithoutDeviceNestedInput
    entitlements?: EntitlementUncheckedUpdateManyWithoutDeviceNestedInput
  }

  export type DeviceUncheckedUpdateManyWithoutSiteInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    ownerUserId?: NullableStringFieldUpdateOperationsInput | string | null
    model?: StringFieldUpdateOperationsInput | string
    serialNumber?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: NullableJsonNullValueInput | InputJsonValue
    status?: EnumDeviceStatusFieldUpdateOperationsInput | $Enums.DeviceStatus
    lastSeenAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    firmwareVersion?: NullableStringFieldUpdateOperationsInput | string | null
    simIccid?: NullableStringFieldUpdateOperationsInput | string | null
    deviceLat?: NullableFloatFieldUpdateOperationsInput | number | null
    deviceLon?: NullableFloatFieldUpdateOperationsInput | number | null
    deviceLocationTs?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deviceLocationSource?: NullableEnumDeviceLocationSourceFieldUpdateOperationsInput | $Enums.DeviceLocationSource | null
    deviceLocationAccuracyM?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WeatherDataUpdateWithoutSiteInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    summary?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tenant?: TenantUpdateOneRequiredWithoutWeatherDataNestedInput
  }

  export type WeatherDataUncheckedUpdateWithoutSiteInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    summary?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WeatherDataUncheckedUpdateManyWithoutSiteInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    summary?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TelemetryCreateManyDeviceInput = {
    id?: string
    ts: Date | string
    metrics: JsonNullValueInput | InputJsonValue
    geo?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type CommandCreateManyDeviceInput = {
    id?: string
    type: $Enums.CommandType
    payload: JsonNullValueInput | InputJsonValue
    status?: $Enums.CommandStatus
    requestedByUserId?: string | null
    requestedAt?: Date | string
    deliveredAt?: Date | string | null
    ackAt?: Date | string | null
    errorMsg?: string | null
  }

  export type AlertEventCreateManyDeviceInput = {
    id?: string
    tenantId: string
    ruleId: string
    severity: $Enums.AlertSeverity
    status?: $Enums.AlertEventStatus
    openedAt?: Date | string
    acknowledgedAt?: Date | string | null
    closedAt?: Date | string | null
    details?: NullableJsonNullValueInput | InputJsonValue
    dedupeKey?: string | null
  }

  export type DailyRollupCreateManyDeviceInput = {
    id?: string
    tenantId: string
    dayDate: Date | string
    energyKwhDay?: number | null
    hotWaterUsageLitersDay?: number | null
    heaterOnMinutesDay?: number | null
    tankTempMinC?: number | null
    tankTempMaxC?: number | null
    ambientTempAvgC?: number | null
    createdAt?: Date | string
  }

  export type EntitlementCreateManyDeviceInput = {
    id?: string
    tenantId: string
    scope: $Enums.EntitlementScope
    key: $Enums.EntitlementKey
    enabled?: boolean
    updatedAt?: Date | string
  }

  export type TelemetryUpdateWithoutDeviceInput = {
    id?: StringFieldUpdateOperationsInput | string
    ts?: DateTimeFieldUpdateOperationsInput | Date | string
    metrics?: JsonNullValueInput | InputJsonValue
    geo?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TelemetryUncheckedUpdateWithoutDeviceInput = {
    id?: StringFieldUpdateOperationsInput | string
    ts?: DateTimeFieldUpdateOperationsInput | Date | string
    metrics?: JsonNullValueInput | InputJsonValue
    geo?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TelemetryUncheckedUpdateManyWithoutDeviceInput = {
    id?: StringFieldUpdateOperationsInput | string
    ts?: DateTimeFieldUpdateOperationsInput | Date | string
    metrics?: JsonNullValueInput | InputJsonValue
    geo?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CommandUpdateWithoutDeviceInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumCommandTypeFieldUpdateOperationsInput | $Enums.CommandType
    payload?: JsonNullValueInput | InputJsonValue
    status?: EnumCommandStatusFieldUpdateOperationsInput | $Enums.CommandStatus
    requestedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deliveredAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ackAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    errorMsg?: NullableStringFieldUpdateOperationsInput | string | null
    requestedBy?: UserUpdateOneWithoutCommandsNestedInput
  }

  export type CommandUncheckedUpdateWithoutDeviceInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumCommandTypeFieldUpdateOperationsInput | $Enums.CommandType
    payload?: JsonNullValueInput | InputJsonValue
    status?: EnumCommandStatusFieldUpdateOperationsInput | $Enums.CommandStatus
    requestedByUserId?: NullableStringFieldUpdateOperationsInput | string | null
    requestedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deliveredAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ackAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    errorMsg?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type CommandUncheckedUpdateManyWithoutDeviceInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumCommandTypeFieldUpdateOperationsInput | $Enums.CommandType
    payload?: JsonNullValueInput | InputJsonValue
    status?: EnumCommandStatusFieldUpdateOperationsInput | $Enums.CommandStatus
    requestedByUserId?: NullableStringFieldUpdateOperationsInput | string | null
    requestedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deliveredAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ackAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    errorMsg?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type AlertEventUpdateWithoutDeviceInput = {
    id?: StringFieldUpdateOperationsInput | string
    severity?: EnumAlertSeverityFieldUpdateOperationsInput | $Enums.AlertSeverity
    status?: EnumAlertEventStatusFieldUpdateOperationsInput | $Enums.AlertEventStatus
    openedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    acknowledgedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    closedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    details?: NullableJsonNullValueInput | InputJsonValue
    dedupeKey?: NullableStringFieldUpdateOperationsInput | string | null
    tenant?: TenantUpdateOneRequiredWithoutAlertEventsNestedInput
    rule?: AlertRuleUpdateOneRequiredWithoutAlertEventsNestedInput
    notificationEvents?: NotificationEventUpdateManyWithoutAlertEventNestedInput
  }

  export type AlertEventUncheckedUpdateWithoutDeviceInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    ruleId?: StringFieldUpdateOperationsInput | string
    severity?: EnumAlertSeverityFieldUpdateOperationsInput | $Enums.AlertSeverity
    status?: EnumAlertEventStatusFieldUpdateOperationsInput | $Enums.AlertEventStatus
    openedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    acknowledgedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    closedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    details?: NullableJsonNullValueInput | InputJsonValue
    dedupeKey?: NullableStringFieldUpdateOperationsInput | string | null
    notificationEvents?: NotificationEventUncheckedUpdateManyWithoutAlertEventNestedInput
  }

  export type AlertEventUncheckedUpdateManyWithoutDeviceInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    ruleId?: StringFieldUpdateOperationsInput | string
    severity?: EnumAlertSeverityFieldUpdateOperationsInput | $Enums.AlertSeverity
    status?: EnumAlertEventStatusFieldUpdateOperationsInput | $Enums.AlertEventStatus
    openedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    acknowledgedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    closedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    details?: NullableJsonNullValueInput | InputJsonValue
    dedupeKey?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type DailyRollupUpdateWithoutDeviceInput = {
    id?: StringFieldUpdateOperationsInput | string
    dayDate?: DateTimeFieldUpdateOperationsInput | Date | string
    energyKwhDay?: NullableFloatFieldUpdateOperationsInput | number | null
    hotWaterUsageLitersDay?: NullableFloatFieldUpdateOperationsInput | number | null
    heaterOnMinutesDay?: NullableFloatFieldUpdateOperationsInput | number | null
    tankTempMinC?: NullableFloatFieldUpdateOperationsInput | number | null
    tankTempMaxC?: NullableFloatFieldUpdateOperationsInput | number | null
    ambientTempAvgC?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tenant?: TenantUpdateOneRequiredWithoutDailyRollupsNestedInput
  }

  export type DailyRollupUncheckedUpdateWithoutDeviceInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    dayDate?: DateTimeFieldUpdateOperationsInput | Date | string
    energyKwhDay?: NullableFloatFieldUpdateOperationsInput | number | null
    hotWaterUsageLitersDay?: NullableFloatFieldUpdateOperationsInput | number | null
    heaterOnMinutesDay?: NullableFloatFieldUpdateOperationsInput | number | null
    tankTempMinC?: NullableFloatFieldUpdateOperationsInput | number | null
    tankTempMaxC?: NullableFloatFieldUpdateOperationsInput | number | null
    ambientTempAvgC?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DailyRollupUncheckedUpdateManyWithoutDeviceInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    dayDate?: DateTimeFieldUpdateOperationsInput | Date | string
    energyKwhDay?: NullableFloatFieldUpdateOperationsInput | number | null
    hotWaterUsageLitersDay?: NullableFloatFieldUpdateOperationsInput | number | null
    heaterOnMinutesDay?: NullableFloatFieldUpdateOperationsInput | number | null
    tankTempMinC?: NullableFloatFieldUpdateOperationsInput | number | null
    tankTempMaxC?: NullableFloatFieldUpdateOperationsInput | number | null
    ambientTempAvgC?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EntitlementUpdateWithoutDeviceInput = {
    id?: StringFieldUpdateOperationsInput | string
    scope?: EnumEntitlementScopeFieldUpdateOperationsInput | $Enums.EntitlementScope
    key?: EnumEntitlementKeyFieldUpdateOperationsInput | $Enums.EntitlementKey
    enabled?: BoolFieldUpdateOperationsInput | boolean
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tenant?: TenantUpdateOneRequiredWithoutEntitlementsNestedInput
  }

  export type EntitlementUncheckedUpdateWithoutDeviceInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    scope?: EnumEntitlementScopeFieldUpdateOperationsInput | $Enums.EntitlementScope
    key?: EnumEntitlementKeyFieldUpdateOperationsInput | $Enums.EntitlementKey
    enabled?: BoolFieldUpdateOperationsInput | boolean
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EntitlementUncheckedUpdateManyWithoutDeviceInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    scope?: EnumEntitlementScopeFieldUpdateOperationsInput | $Enums.EntitlementScope
    key?: EnumEntitlementKeyFieldUpdateOperationsInput | $Enums.EntitlementKey
    enabled?: BoolFieldUpdateOperationsInput | boolean
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OtaJobCreateManyFirmwarePackageInput = {
    id?: string
    tenantId: string
    targetType: $Enums.OtaTargetType
    deviceId?: string | null
    groupFilter?: NullableJsonNullValueInput | InputJsonValue
    status?: $Enums.OtaJobStatus
    scheduledAt: Date | string
    startedAt?: Date | string | null
    finishedAt?: Date | string | null
    createdByUserId?: string | null
    progress?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type OtaJobUpdateWithoutFirmwarePackageInput = {
    id?: StringFieldUpdateOperationsInput | string
    targetType?: EnumOtaTargetTypeFieldUpdateOperationsInput | $Enums.OtaTargetType
    deviceId?: NullableStringFieldUpdateOperationsInput | string | null
    groupFilter?: NullableJsonNullValueInput | InputJsonValue
    status?: EnumOtaJobStatusFieldUpdateOperationsInput | $Enums.OtaJobStatus
    scheduledAt?: DateTimeFieldUpdateOperationsInput | Date | string
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    finishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    progress?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tenant?: TenantUpdateOneRequiredWithoutOtaJobsNestedInput
    createdBy?: UserUpdateOneWithoutOtaJobsNestedInput
  }

  export type OtaJobUncheckedUpdateWithoutFirmwarePackageInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    targetType?: EnumOtaTargetTypeFieldUpdateOperationsInput | $Enums.OtaTargetType
    deviceId?: NullableStringFieldUpdateOperationsInput | string | null
    groupFilter?: NullableJsonNullValueInput | InputJsonValue
    status?: EnumOtaJobStatusFieldUpdateOperationsInput | $Enums.OtaJobStatus
    scheduledAt?: DateTimeFieldUpdateOperationsInput | Date | string
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    finishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdByUserId?: NullableStringFieldUpdateOperationsInput | string | null
    progress?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OtaJobUncheckedUpdateManyWithoutFirmwarePackageInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    targetType?: EnumOtaTargetTypeFieldUpdateOperationsInput | $Enums.OtaTargetType
    deviceId?: NullableStringFieldUpdateOperationsInput | string | null
    groupFilter?: NullableJsonNullValueInput | InputJsonValue
    status?: EnumOtaJobStatusFieldUpdateOperationsInput | $Enums.OtaJobStatus
    scheduledAt?: DateTimeFieldUpdateOperationsInput | Date | string
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    finishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdByUserId?: NullableStringFieldUpdateOperationsInput | string | null
    progress?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DeviceCreateManySimInput = {
    id?: string
    tenantId: string
    siteId?: string | null
    ownerUserId?: string | null
    model: string
    serialNumber: string
    name?: string | null
    notes?: string | null
    tags?: NullableJsonNullValueInput | InputJsonValue
    status?: $Enums.DeviceStatus
    lastSeenAt?: Date | string | null
    firmwareVersion?: string | null
    deviceLat?: number | null
    deviceLon?: number | null
    deviceLocationTs?: Date | string | null
    deviceLocationSource?: $Enums.DeviceLocationSource | null
    deviceLocationAccuracyM?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SimActionCreateManySimInput = {
    id?: string
    action: $Enums.SimActionType
    requestedByUserId?: string | null
    requestedAt?: Date | string
    status?: $Enums.SimActionStatus
    providerRef?: string | null
    errorMsg?: string | null
  }

  export type DeviceUpdateWithoutSimInput = {
    id?: StringFieldUpdateOperationsInput | string
    ownerUserId?: NullableStringFieldUpdateOperationsInput | string | null
    model?: StringFieldUpdateOperationsInput | string
    serialNumber?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: NullableJsonNullValueInput | InputJsonValue
    status?: EnumDeviceStatusFieldUpdateOperationsInput | $Enums.DeviceStatus
    lastSeenAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    firmwareVersion?: NullableStringFieldUpdateOperationsInput | string | null
    deviceLat?: NullableFloatFieldUpdateOperationsInput | number | null
    deviceLon?: NullableFloatFieldUpdateOperationsInput | number | null
    deviceLocationTs?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deviceLocationSource?: NullableEnumDeviceLocationSourceFieldUpdateOperationsInput | $Enums.DeviceLocationSource | null
    deviceLocationAccuracyM?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tenant?: TenantUpdateOneRequiredWithoutDevicesNestedInput
    site?: SiteUpdateOneWithoutDevicesNestedInput
    secret?: DeviceSecretUpdateOneWithoutDeviceNestedInput
    twin?: DeviceTwinUpdateOneWithoutDeviceNestedInput
    telemetry?: TelemetryUpdateManyWithoutDeviceNestedInput
    commands?: CommandUpdateManyWithoutDeviceNestedInput
    alertEvents?: AlertEventUpdateManyWithoutDeviceNestedInput
    dailyRollups?: DailyRollupUpdateManyWithoutDeviceNestedInput
    entitlements?: EntitlementUpdateManyWithoutDeviceNestedInput
  }

  export type DeviceUncheckedUpdateWithoutSimInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    siteId?: NullableStringFieldUpdateOperationsInput | string | null
    ownerUserId?: NullableStringFieldUpdateOperationsInput | string | null
    model?: StringFieldUpdateOperationsInput | string
    serialNumber?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: NullableJsonNullValueInput | InputJsonValue
    status?: EnumDeviceStatusFieldUpdateOperationsInput | $Enums.DeviceStatus
    lastSeenAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    firmwareVersion?: NullableStringFieldUpdateOperationsInput | string | null
    deviceLat?: NullableFloatFieldUpdateOperationsInput | number | null
    deviceLon?: NullableFloatFieldUpdateOperationsInput | number | null
    deviceLocationTs?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deviceLocationSource?: NullableEnumDeviceLocationSourceFieldUpdateOperationsInput | $Enums.DeviceLocationSource | null
    deviceLocationAccuracyM?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    secret?: DeviceSecretUncheckedUpdateOneWithoutDeviceNestedInput
    twin?: DeviceTwinUncheckedUpdateOneWithoutDeviceNestedInput
    telemetry?: TelemetryUncheckedUpdateManyWithoutDeviceNestedInput
    commands?: CommandUncheckedUpdateManyWithoutDeviceNestedInput
    alertEvents?: AlertEventUncheckedUpdateManyWithoutDeviceNestedInput
    dailyRollups?: DailyRollupUncheckedUpdateManyWithoutDeviceNestedInput
    entitlements?: EntitlementUncheckedUpdateManyWithoutDeviceNestedInput
  }

  export type DeviceUncheckedUpdateManyWithoutSimInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    siteId?: NullableStringFieldUpdateOperationsInput | string | null
    ownerUserId?: NullableStringFieldUpdateOperationsInput | string | null
    model?: StringFieldUpdateOperationsInput | string
    serialNumber?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: NullableJsonNullValueInput | InputJsonValue
    status?: EnumDeviceStatusFieldUpdateOperationsInput | $Enums.DeviceStatus
    lastSeenAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    firmwareVersion?: NullableStringFieldUpdateOperationsInput | string | null
    deviceLat?: NullableFloatFieldUpdateOperationsInput | number | null
    deviceLon?: NullableFloatFieldUpdateOperationsInput | number | null
    deviceLocationTs?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deviceLocationSource?: NullableEnumDeviceLocationSourceFieldUpdateOperationsInput | $Enums.DeviceLocationSource | null
    deviceLocationAccuracyM?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SimActionUpdateWithoutSimInput = {
    id?: StringFieldUpdateOperationsInput | string
    action?: EnumSimActionTypeFieldUpdateOperationsInput | $Enums.SimActionType
    requestedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumSimActionStatusFieldUpdateOperationsInput | $Enums.SimActionStatus
    providerRef?: NullableStringFieldUpdateOperationsInput | string | null
    errorMsg?: NullableStringFieldUpdateOperationsInput | string | null
    requestedBy?: UserUpdateOneWithoutSimActionsNestedInput
  }

  export type SimActionUncheckedUpdateWithoutSimInput = {
    id?: StringFieldUpdateOperationsInput | string
    action?: EnumSimActionTypeFieldUpdateOperationsInput | $Enums.SimActionType
    requestedByUserId?: NullableStringFieldUpdateOperationsInput | string | null
    requestedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumSimActionStatusFieldUpdateOperationsInput | $Enums.SimActionStatus
    providerRef?: NullableStringFieldUpdateOperationsInput | string | null
    errorMsg?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type SimActionUncheckedUpdateManyWithoutSimInput = {
    id?: StringFieldUpdateOperationsInput | string
    action?: EnumSimActionTypeFieldUpdateOperationsInput | $Enums.SimActionType
    requestedByUserId?: NullableStringFieldUpdateOperationsInput | string | null
    requestedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumSimActionStatusFieldUpdateOperationsInput | $Enums.SimActionStatus
    providerRef?: NullableStringFieldUpdateOperationsInput | string | null
    errorMsg?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type AlertEventCreateManyRuleInput = {
    id?: string
    tenantId: string
    deviceId: string
    severity: $Enums.AlertSeverity
    status?: $Enums.AlertEventStatus
    openedAt?: Date | string
    acknowledgedAt?: Date | string | null
    closedAt?: Date | string | null
    details?: NullableJsonNullValueInput | InputJsonValue
    dedupeKey?: string | null
  }

  export type AlertEventUpdateWithoutRuleInput = {
    id?: StringFieldUpdateOperationsInput | string
    severity?: EnumAlertSeverityFieldUpdateOperationsInput | $Enums.AlertSeverity
    status?: EnumAlertEventStatusFieldUpdateOperationsInput | $Enums.AlertEventStatus
    openedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    acknowledgedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    closedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    details?: NullableJsonNullValueInput | InputJsonValue
    dedupeKey?: NullableStringFieldUpdateOperationsInput | string | null
    tenant?: TenantUpdateOneRequiredWithoutAlertEventsNestedInput
    device?: DeviceUpdateOneRequiredWithoutAlertEventsNestedInput
    notificationEvents?: NotificationEventUpdateManyWithoutAlertEventNestedInput
  }

  export type AlertEventUncheckedUpdateWithoutRuleInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    deviceId?: StringFieldUpdateOperationsInput | string
    severity?: EnumAlertSeverityFieldUpdateOperationsInput | $Enums.AlertSeverity
    status?: EnumAlertEventStatusFieldUpdateOperationsInput | $Enums.AlertEventStatus
    openedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    acknowledgedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    closedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    details?: NullableJsonNullValueInput | InputJsonValue
    dedupeKey?: NullableStringFieldUpdateOperationsInput | string | null
    notificationEvents?: NotificationEventUncheckedUpdateManyWithoutAlertEventNestedInput
  }

  export type AlertEventUncheckedUpdateManyWithoutRuleInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    deviceId?: StringFieldUpdateOperationsInput | string
    severity?: EnumAlertSeverityFieldUpdateOperationsInput | $Enums.AlertSeverity
    status?: EnumAlertEventStatusFieldUpdateOperationsInput | $Enums.AlertEventStatus
    openedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    acknowledgedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    closedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    details?: NullableJsonNullValueInput | InputJsonValue
    dedupeKey?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type NotificationEventCreateManyAlertEventInput = {
    id?: string
    tenantId: string
    channelId: string
    status?: $Enums.NotificationEventStatus
    payload: JsonNullValueInput | InputJsonValue
    sentAt?: Date | string | null
    errorMsg?: string | null
    createdAt?: Date | string
  }

  export type NotificationEventUpdateWithoutAlertEventInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: EnumNotificationEventStatusFieldUpdateOperationsInput | $Enums.NotificationEventStatus
    payload?: JsonNullValueInput | InputJsonValue
    sentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    errorMsg?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tenant?: TenantUpdateOneRequiredWithoutNotificationEventsNestedInput
    channel?: NotificationChannelUpdateOneRequiredWithoutNotificationEventsNestedInput
  }

  export type NotificationEventUncheckedUpdateWithoutAlertEventInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    channelId?: StringFieldUpdateOperationsInput | string
    status?: EnumNotificationEventStatusFieldUpdateOperationsInput | $Enums.NotificationEventStatus
    payload?: JsonNullValueInput | InputJsonValue
    sentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    errorMsg?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationEventUncheckedUpdateManyWithoutAlertEventInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    channelId?: StringFieldUpdateOperationsInput | string
    status?: EnumNotificationEventStatusFieldUpdateOperationsInput | $Enums.NotificationEventStatus
    payload?: JsonNullValueInput | InputJsonValue
    sentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    errorMsg?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationEventCreateManyChannelInput = {
    id?: string
    tenantId: string
    alertEventId?: string | null
    status?: $Enums.NotificationEventStatus
    payload: JsonNullValueInput | InputJsonValue
    sentAt?: Date | string | null
    errorMsg?: string | null
    createdAt?: Date | string
  }

  export type NotificationEventUpdateWithoutChannelInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: EnumNotificationEventStatusFieldUpdateOperationsInput | $Enums.NotificationEventStatus
    payload?: JsonNullValueInput | InputJsonValue
    sentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    errorMsg?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tenant?: TenantUpdateOneRequiredWithoutNotificationEventsNestedInput
    alertEvent?: AlertEventUpdateOneWithoutNotificationEventsNestedInput
  }

  export type NotificationEventUncheckedUpdateWithoutChannelInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    alertEventId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumNotificationEventStatusFieldUpdateOperationsInput | $Enums.NotificationEventStatus
    payload?: JsonNullValueInput | InputJsonValue
    sentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    errorMsg?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationEventUncheckedUpdateManyWithoutChannelInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    alertEventId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumNotificationEventStatusFieldUpdateOperationsInput | $Enums.NotificationEventStatus
    payload?: JsonNullValueInput | InputJsonValue
    sentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    errorMsg?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }



  /**
   * Aliases for legacy arg types
   */
    /**
     * @deprecated Use TenantCountOutputTypeDefaultArgs instead
     */
    export type TenantCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = TenantCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use UserCountOutputTypeDefaultArgs instead
     */
    export type UserCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = UserCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use SiteCountOutputTypeDefaultArgs instead
     */
    export type SiteCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = SiteCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use DeviceCountOutputTypeDefaultArgs instead
     */
    export type DeviceCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = DeviceCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use FirmwarePackageCountOutputTypeDefaultArgs instead
     */
    export type FirmwarePackageCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = FirmwarePackageCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use SimInfoCountOutputTypeDefaultArgs instead
     */
    export type SimInfoCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = SimInfoCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use AlertRuleCountOutputTypeDefaultArgs instead
     */
    export type AlertRuleCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = AlertRuleCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use AlertEventCountOutputTypeDefaultArgs instead
     */
    export type AlertEventCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = AlertEventCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use NotificationChannelCountOutputTypeDefaultArgs instead
     */
    export type NotificationChannelCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = NotificationChannelCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use TenantDefaultArgs instead
     */
    export type TenantArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = TenantDefaultArgs<ExtArgs>
    /**
     * @deprecated Use UserDefaultArgs instead
     */
    export type UserArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = UserDefaultArgs<ExtArgs>
    /**
     * @deprecated Use MembershipDefaultArgs instead
     */
    export type MembershipArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = MembershipDefaultArgs<ExtArgs>
    /**
     * @deprecated Use SiteDefaultArgs instead
     */
    export type SiteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = SiteDefaultArgs<ExtArgs>
    /**
     * @deprecated Use DeviceDefaultArgs instead
     */
    export type DeviceArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = DeviceDefaultArgs<ExtArgs>
    /**
     * @deprecated Use DeviceSecretDefaultArgs instead
     */
    export type DeviceSecretArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = DeviceSecretDefaultArgs<ExtArgs>
    /**
     * @deprecated Use TelemetryDefaultArgs instead
     */
    export type TelemetryArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = TelemetryDefaultArgs<ExtArgs>
    /**
     * @deprecated Use DeviceTwinDefaultArgs instead
     */
    export type DeviceTwinArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = DeviceTwinDefaultArgs<ExtArgs>
    /**
     * @deprecated Use CommandDefaultArgs instead
     */
    export type CommandArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = CommandDefaultArgs<ExtArgs>
    /**
     * @deprecated Use FirmwarePackageDefaultArgs instead
     */
    export type FirmwarePackageArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = FirmwarePackageDefaultArgs<ExtArgs>
    /**
     * @deprecated Use OtaJobDefaultArgs instead
     */
    export type OtaJobArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = OtaJobDefaultArgs<ExtArgs>
    /**
     * @deprecated Use SimInfoDefaultArgs instead
     */
    export type SimInfoArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = SimInfoDefaultArgs<ExtArgs>
    /**
     * @deprecated Use SimActionDefaultArgs instead
     */
    export type SimActionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = SimActionDefaultArgs<ExtArgs>
    /**
     * @deprecated Use AlertRuleDefaultArgs instead
     */
    export type AlertRuleArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = AlertRuleDefaultArgs<ExtArgs>
    /**
     * @deprecated Use AlertEventDefaultArgs instead
     */
    export type AlertEventArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = AlertEventDefaultArgs<ExtArgs>
    /**
     * @deprecated Use NotificationChannelDefaultArgs instead
     */
    export type NotificationChannelArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = NotificationChannelDefaultArgs<ExtArgs>
    /**
     * @deprecated Use NotificationEventDefaultArgs instead
     */
    export type NotificationEventArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = NotificationEventDefaultArgs<ExtArgs>
    /**
     * @deprecated Use DailyRollupDefaultArgs instead
     */
    export type DailyRollupArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = DailyRollupDefaultArgs<ExtArgs>
    /**
     * @deprecated Use EntitlementDefaultArgs instead
     */
    export type EntitlementArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = EntitlementDefaultArgs<ExtArgs>
    /**
     * @deprecated Use AuditLogDefaultArgs instead
     */
    export type AuditLogArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = AuditLogDefaultArgs<ExtArgs>
    /**
     * @deprecated Use WeatherDataDefaultArgs instead
     */
    export type WeatherDataArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = WeatherDataDefaultArgs<ExtArgs>

  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}